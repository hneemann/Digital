<?xml version="1.0" encoding="UTF-8"?>
<!--  IMPORTANT
Do not edit this file directly!
This makes it very difficult for me to continue to maintain the translation.
The only exception are simple typos.
Pull requests in which this file is modified beyond simple typos cannot be accepted.
In the file howTo.md you can find more details about translations.
--><resources>    <string name="addr">Indirizzo</string>
    <string name="tableOfContent">Indice</string>
    <string name="general">Generale</string>
    <string name="revision">Revisione</string>
    <string name="date">Data</string>
    <string name="settings">Di seguito la descrizione delle impostazioni del simulatore disponibili.</string>
    <string name="maxValue">Massimo</string>
    <string name="attr_dialogTitle">Attributi</string>
    <string name="attr_openCircuit">Circuito Aperto</string>
    <string name="attr_openCircuitLabel">Circuito incluso:</string>
    <string name="attr_openCircuit_tt">Apre il circuito in una nuova finestra.</string>
    <string name="attr_help">Aiuto</string>
    <string name="attr_help_tt">Mostra una breve descrizione di questo elemento.</string>
    <string name="attr_panel_primary">Base</string>
    <string name="attr_panel_secondary">Avanzato</string>
    <string name="btn_discard">Scarta Modifiche</string>
    <string name="btn_edit">Modifica</string>
    <string name="btn_editFurther">Continua a modificare</string>
    <string name="btn_load">Carica</string>
    <string name="btn_save">Salva</string>
    <string name="btn_create">Crea</string>
    <string name="btn_create_tt">Crea un circuito in una finestra separata</string>
    <string name="btn_editDetached">Modifica separatamente</string>
    <string name="btn_editDetached_tt">Apre il dialogo in una finestra non modale</string>
    <string name="btn_openInBrowser_tt">Apre il testo di aiuto nel browser. Consente di stampare il testo</string>
    <string name="btn_clearData">Pulisci</string>
    <string name="btn_clearData_tt">Tutti i valori sono stati impostati a zero!</string>
    <string name="btn_addTransitions">Transizioni</string>
    <string name="btn_addTransitions_tt">Tutte le transizioni possibili sono aggiunte come test case. Utilizzato per creare dei test case per testare il simulatore stesso.</string>
    <string name="btn_newName">Nuovo Nome</string>
    <string name="btn_saveAnyway">Salva comunque</string>
    <string name="btn_overwrite">Sovrascrivi</string>
    <string name="btn_apply">Applica</string>
    <string name="btn_editRom_tt">Modifica il contenuto della ROM/EEPROM selezionata</string>
    <string name="btn_clearRom_tt">Rimuove i dati memorizzati per la ROM selezionata. Il contenuto che è memorizzato nella ROM direttamente è invece utilizzato.</string>
    <string name="btn_saveTemplate_tt">Crea un template SVG che può poi essere modificato con Inkscape.</string>
    <string name="btn_loadSvg">Importa</string>
    <string name="btn_loadSvg_tt">Importa un file SVG. Per creare un file SVG, è più facile prima creare un template SVG e poi modificarlo.</string>
    <string name="msg_warning">Avvertimento</string>
    <string name="cancel">Annulla</string>
    <string name="expression">Espressione</string>
    <string name="elem_Help_inputs">Ingressi</string>
    <string name="elem_Help_outputs">Uscite</string>
    <string name="elem_Help_attributes">Attributi</string>
    <string name="msg_search">cerca</string>
    <string name="msg_errorPastingData">Errore durante l'incollamento dei dati!</string>
    <string name="elem_Basic_In">Il {0}. valore di ingresso per l''operazione logica.</string>
    <string name="elem_Basic_Out">Restituisce il risultato dell'operazione logica.</string>
    <string name="elem_And_tt">Porta AND binaria. Restituisce alto se e solo se tutti gli ingressi sono impostati ad alto. Si possono anche usare i
	bus con più bit come ingresso ed uscita. In tal caso, una AND bit-a-bit è applicata ad ogni ingresso.</string>
    <string name="elem_NAnd_tt">Una combinazione di AND e NOT. Restituisce basso solo se tutti gli ingressi sono impostati ad alto. Se
    	uno degli ingressi è impostato a basso, l'uscita è impostata alta. Si possono anche utilizzare i bus con più
    	bit. In tal caso, una NAND bit-a-bit è applicata ad ogni ingresso.</string>
    <string name="elem_Or_tt">Porta OR. Restituisce alto se almeno uno degli ingressi è alto. Se tutti gli ingressi sono bassi, l'uscita
    	sarà anch'essa bassa. Si possono anche utilizzare i bus con più bit. In tal caso, una OR bit-a-bit è applicata
    	ad ogni ingresso.</string>
    <string name="elem_NOr_tt">Una combinazione di OR e NOT. Restituisce basso se uno degli ingressi è alto. Se tutti gli ingressi sono bassi,
    	allora anche l'uscita sarà bassa. Si possono anche utilizzare i bus con più bit. In tal caso, una NOR bit-a-bit
    	è applicata ad ogni ingresso.</string>
    <string name="elem_XOr_tt">Se si utilizzano solo due ingressi, l'uscita è bassa se i bit di ingresso sono uguali. Altrimenti l'uscita è alta.
    	Se si utilizzano più, allora si comporta come una cascata di porte XOR ( A XOR B XOR C = (A XOR B)
    	XOR C ). Si possono anche utilizzare i bus con più bit. In tal caso, una XOR bit-a-bit è applicata ad ogni ingresso.</string>
    <string name="elem_XNOr_tt">Una combinazione di XOR e NOT. Gli ingressi sono combinati con l'operazione XOR. Il risultato è poi negato.
    	Si possono anche usare i bus con più bit. In tal caso, una XNOR bit-a-bit è applicata ad ogni ingresso.</string>
    <string name="elem_Not_tt">Inverte il valore dell'ingresso. Un valore alto diventa basso e viceversa. Si possono anche usare i bus con
    	più bit. In tal caso, una NOT bit-a-bit è applicata ad ogni ingresso.</string>
    <string name="elem_Not_pin_in">L'ingresso della porta NOT.</string>
    <string name="elem_Not_pin_out">L'ingresso invertito.</string>
    <string name="elem_LookUpTable">Tabella di Lookup</string>
    <string name="elem_LookUpTable_tt">Ottiene il valore dell'uscita da una tabella memorizzata. Così, questa porta può emulare ogni
    	porta combinatoria.</string>
    <string name="elem_LookUpTable_pin_in">Ingresso {0}. Questo ingresso in combinazione con tutti gli altri definisce
    	l''indirizzo del valore memorizzato che deve essere restituito.</string>
    <string name="elem_LookUpTable_pin_out">Restituisce il valore memorizzato all'indirizzo impostato tramite gli ingressi.</string>
    <string name="elem_Delay">Ritardo.</string>
    <string name="elem_Delay_tt">Ritarda il segnale di un tempo di ritardo di propagazione. Ritarda un segnale per un numero di
      	ritardo della porta configurabile. Tutti gli altri componenti in Digital hanno un ritardo di
      	porta equivalente ad un ritardo di propagazione. Questo componente può essere utilizzato per
        realizzare in qualsiasi tempo di propagazione necessario.</string>
    <string name="elem_Delay_pin_in">Ingresso del segnale su cui applicare un ritardo.</string>
    <string name="elem_Delay_pin_out">L'ingresso del segnale ritardato di un certo ritardo porta.</string>
    <string name="elem_Out">Uscita</string>
    <string name="elem_Out_tt">Può essere utilizzato per visualizzare il segnale d'uscita di un circuito. Questo elemento è anche utilizzato per
        connettere un circuito al suo padre. In questo caso la connessione è bidirezionale. Tramite questo si può anche assegnare
        un numero del pin, se il codice per CPLD o FPGA è generato.</string>
    <string name="elem_Out_pin_in">Questo valore è usato per la connessione dell'uscita.</string>
    <string name="elem_LED_tt">Un LED può essere utilizzato per visualizzare il valore di uscita. Accetta un bit singolo.
        Si illumina se l'ingresso è alto.</string>
    <string name="elem_LED_pin_in">Ingresso del LED. Si illumina se l'ingresso è alto.</string>
    <string name="elem_RGBLED">LED RGB</string>
    <string name="elem_RGBLED_tt">Un LED RGB il cui colore può essere controllato tramite tre ingressi.
        In ognuno dei tre ingressi, un canale del colore è connesso.</string>
    <string name="elem_RGBLED_pin_R">Il canale rosso del colore.</string>
    <string name="elem_RGBLED_pin_G">Il canale verde del colore.</string>
    <string name="elem_RGBLED_pin_B">Il canale blu del colore.</string>
    <string name="elem_In">Ingresso</string>
    <string name="elem_In_tt">Può essere utilizzato per manipolare in forma interattiva un segnale di ingresso in un
        circuito con il mouse. Questo elemento è anche utilizzato per connettere un circuito al suo
        padre. In questo caso, la connessione è bidirezionale. Tramite questo si può anche assegnare
        un numero del pin, se il codice per CPLD o FPGA è generato.</string>
    <string name="elem_In_pin_out">Restituisce il valore che è connesso a questo ingresso.</string>
    <string name="elem_DipSwitch">Interruttore DIP</string>
    <string name="elem_DipSwitch_tt">Semplice interruttore DIP il cui output può essere solo alto o basso.</string>
    <string name="elem_DipSwitch_pin_out">Il valore d'uscita dell'interruttore.</string>
    <string name="elem_Clock">Ingresso Clock</string>
    <string name="elem_Clock_tt">Un segnale di clock. Lo si può controllare da un clock a tempo reale. A seconda della complessità del circuito, la
        frequenza del clock raggiunta potrebbe essere minore di quella selezionata. Se la frequenza è più alta di 50Hz,
        la rappresentazione del circuito non sarà più aggiornata per ogni ciclo di clock in modo tale da non aggiornare
        più i colori dei cavi. Se il clock a tempo reale non è attivato, il clock stesso può essere controllato da click
        del mouse. Tramite questo si può anche assegnare un numero del pin, se il codice per CPLD o FPGA è generato.</string>
    <string name="elem_Clock_pin_C">Alterna da basso ad alto all'interno della frequenza di clock selezionata.</string>
    <string name="elem_Button">Bottone</string>
    <string name="elem_Button_tt">Un semplice bottone a pressione che ritorna al suo stato originale una volta rilasciato.</string>
    <string name="elem_Button_pin_out">Il segnale di uscita del bottone.</string>
    <string name="elem_ButtonLED">Bottone con LED</string>
    <string name="elem_ButtonLED_tt">Un semplice bottone a pressione che ha un LED che può essere attivato da un segnale di ingresso.</string>
    <string name="elem_ButtonLED_pin_out">Il segnale di uscita del bottone.</string>
    <string name="elem_ButtonLED_pin_in">L'ingresso per controllare il LED del bottone.</string>
    <string name="elem_Text">Testo</string>
    <string name="elem_Text_tt">Mostra un testo all'interno del circuito. Non ha alcun effetto sulla simulazione. Il testo può essere cambiato nel dialogo
        degli attributi.</string>
    <string name="elem_Rectangle">Rettangolo</string>
    <string name="elem_Rectangle_tt">Mostra un rettangolo nel circuito.</string>
    <string name="elem_Probe">Sonda</string>
    <string name="elem_Probe_tt">Un velore di misurazione che può essere mostrato nel grafico dei dati o nella tabella delle misurazioni.
        Questo componente può essere usato per osservare facilmente i valori nei circuiti incorporati.</string>
    <string name="elem_Probe_pin_in">Il valore della misurazione.</string>
    <string name="elem_LightBulb">Lampada</string>
    <string name="elem_LightBulb_tt">Una lampada con due connessione. Se la corrente scorre, la lampada si illumina. La direzione della corrente non
        importa. La lampada si accende quando gli ingressi hanno valori differenti. La lampada si comporta in maniera
        simile ad una porta XOR.</string>
    <string name="elem_LightBulb_pin_A">Connessione</string>
    <string name="elem_LightBulb_pin_B">Connessione</string>
    <string name="elem_PolarityAwareLED">LED con due connessioni.</string>
    <string name="elem_PolarityAwareLED_tt">Un LED con connessioni per anodo e catodo. Il LED si illumina se l'anodo è connesso ad un segnale alto
        ed il catodo ad un segnale basso. Questo LED non può essere utilizzato come un resistore pull-down. Agisce solamente
        come un elemento visivo. Il resistore è mostrato solo per simboleggiare il resistore in serie per limitare la corrente.</string>
    <string name="elem_PolarityAwareLED_pin_A">La connessione all'anodo del LED</string>
    <string name="elem_PolarityAwareLED_pin_C">La connessione al catodo del LED</string>
    <string name="elem_Seven-Seg">Display a Sette Segmenti</string>
    <string name="elem_Seven-Seg_tt">Display a sette segmenti, ogni segmento ha il suo ingresso di controllo.</string>
    <string name="elem_Seven-Seg_pin_a">Questo ingresso controlla la linea orizzontale in alto.</string>
    <string name="elem_Seven-Seg_pin_b">Questo ingresso controlla la linea verticale in alto a destra.</string>
    <string name="elem_Seven-Seg_pin_c">Questo ingresso controlla la linea verticale in basso a destra.</string>
    <string name="elem_Seven-Seg_pin_d">Questo ingresso controlla la linea orizzontale in basso.</string>
    <string name="elem_Seven-Seg_pin_e">Questo ingresso controlla la linea verticale in basso a sinistra.</string>
    <string name="elem_Seven-Seg_pin_f">Questo ingresso controlla la linea verticale in alto a sinistra</string>
    <string name="elem_Seven-Seg_pin_g">Questo ingresso controlla la riga orizzontale in mezzo.</string>
    <string name="elem_Seven-Seg_pin_dp">Questo ingresso controlla il punto decimale.</string>
    <string name="elem_Seven-Seg_pin_cc">Catodo comune. Per accendere i LED, questo ingresso deve essere basso.</string>
    <string name="elem_Seven-Seg_pin_ca">Anodo comune. Per accendere i LED, questo ingresso deveo essere alto.</string>
    <string name="elem_Seven-Seg-Hex">Display a Sette Segmenti Esadecimale</string>
    <string name="elem_Seven-Seg-Hex_tt">Display a sette segmenti con un ingresso a 4 bit esadecimali</string>
    <string name="elem_Seven-Seg-Hex_pin_d">Il valore in questo ingresso è visualizzata nel display.</string>
    <string name="elem_Seven-Seg-Hex_pin_dp">Questo ingresso controlla il punto decimale.</string>
    <string name="elem_SixteenSeg">Display a 16 Segmenti</string>
    <string name="elem_SixteenSeg_tt">Questo ingresso LED ha 16 bit che controllano i segmenti. Il secondo ingresso controlla il punto decimale.</string>
    <string name="elem_SixteenSeg_pin_led">Bus a 16 bit per controllare i LED.</string>
    <string name="elem_SixteenSeg_pin_dp">Questo ingresso controlla il punto decimale.</string>
    <string name="elem_LedMatrix">Matrice di LED</string>
    <string name="elem_LedMatrix_tt">Una matrice di LED. I LED sono mostrati in una finestra separata. I LED di una colonna del display sono controllati da
        una parola di bit. In un altro ingresso, la colonna corrente è selezionata. Quindi un display multiplexato è
        realizzato. I LED potrebbero rimanere accesi indefinitamente nella simulazione per prevenire sfarfallio del display.</string>
    <string name="elem_LedMatrix_pin_r-data">Lo stato della riga dei LED di una colonna. Ciascun bit in questa parola di bit rappresenta lo stato di una riga
        della colonna corrente.</string>
    <string name="elem_LedMatrix_pin_c-addr">Il numero della colonna corrente il cui stato è attualmente visibile nell'altro ingresso.</string>
    <string name="elem_Data">Grafico Dati</string>
    <string name="elem_Data_tt">Mostra un grafico all'interno del pannello del circuito. Puoi graficare cicli di clock completi o semplici cambiamenti
        delle porte. Non ha alcun effetto sulla simulazione.</string>
    <string name="elem_ScopeTrigger">Grafico Dati ad Attivazione</string>
    <string name="elem_ScopeTrigger_short">Oscilloscopio</string>
    <string name="elem_ScopeTrigger_tt">Mostra un grafico di valori misurati, dove ogni valore misurato è memorizzato soltanto se il segnale di ingresso
        cambia. La memorizzazione avviene quando il circuito si è stabilizzato. L'attivazione non dà origine alla misurazione
        come in un vero oscilloscopio, ma ogni evento di attivazione fa memorizzare un singolo valore di misurazione per ogni
        segnale mostrato. Come ingresso diretto c'è soltanto l'attivazione. Gli ingressi ed uscite del circuito, flip-flop e registri e i
        componenti sondi possono essere utilizzati come segnali. Questo può essere abilitato nei rispettivi componenti.</string>
    <string name="elem_ScopeTrigger_pin_T">Un cambiamento in questo ingresso causa la memorizzazione di un valore di misurazione.</string>
    <string name="elem_RotEncoder">Trasduttore di Posizione a Rotella</string>
    <string name="elem_RotEncoder_tt">Rotella con codificatore. Utilizzato per rilevare rotazioni.</string>
    <string name="elem_RotEncoder_pin_A">segnale A del codificatore</string>
    <string name="elem_RotEncoder_pin_B">segnale B del codificatore</string>
    <string name="elem_Keyboard">Tastiera</string>
    <string name="elem_Keyboard_tt">Una tastiera può essere utilizzata per inserire del testo. Questo componente bufferizza l'ingresso, che può poi
        essere letto. Una finestra separata sarà aperta per inserire il testo.</string>
    <string name="elem_Keyboard_pin_C">Clock. Un fronte di salita rimuove il carattere più vecchio dal buffer.</string>
    <string name="elem_Keyboard_pin_en">Se impostato alto, l'uscita D diventa attiva ed un carattere si presenta nell'uscita. Abilita anche l'ingresso del clock.</string>
    <string name="elem_Keyboard_pin_D">L'ultimo carattere scritto, oppure zero se nessun carattere è disponibile. L'uscita è il valore a 16 bit assegnato da Java.</string>
    <string name="elem_Keyboard_pin_av">Questa uscita indica che dei caratteri sono disponibili. Può essere utilizzata per attivare un interrupt.</string>
    <string name="elem_Terminal">Terminale</string>
    <string name="elem_Terminal_tt">Puoi scrivere caratteri ASCII nel terminale. Il terminale apre la propria finestra per visualizzare l'output.</string>
    <string name="elem_Terminal_pin_C">Clock. Un fronte di salita scrive il valore dell'ingresso nella finestra del terminale.</string>
    <string name="elem_Terminal_pin_D">Il dato da scrivere nel terminale</string>
    <string name="elem_Terminal_pin_en">Un valore alto in questo ingresso abilita l'input del clock.</string>
    <string name="elem_Telnet">Telnet</string>
    <string name="elem_Telnet_tt">Abilita una connessione Telnet al circuito. Si può ricevere ed inviare caratteri tramite Telnet.</string>
    <string name="elem_Telnet_pin_out">Uscita Dati</string>
    <string name="elem_Telnet_pin_av">Inserisce nell'uscita un dato, se presente.</string>
    <string name="elem_Telnet_pin_in">I dati da inviare.</string>
    <string name="elem_Telnet_pin_C">Input del clock</string>
    <string name="elem_Telnet_pin_wr">Se impostato, il byte nell'ingresso dati viene inviato.</string>
    <string name="elem_Telnet_pin_rd">Se impostato, il byte ricevuto viene visualizzato.</string>
    <string name="elem_VGA">Monitor VGA</string>
    <string name="elem_VGA_short">VGA</string>
    <string name="elem_VGA_tt">Analizza i segnali video in ingresso e visualizza la grafica corrispondente. Visto che la simulazione non può essere
        eseguita in tempo reale, il clock dei pixel è richiesto in aggiunta ai segnali video.</string>
    <string name="elem_VGA_pin_R">Il componente rosso del colore</string>
    <string name="elem_VGA_pin_G">Il componente verde del colore</string>
    <string name="elem_VGA_pin_B">Il componente blu del colore</string>
    <string name="elem_VGA_pin_H">Il segnale di sincronizzazione orizzontale</string>
    <string name="elem_VGA_pin_V">Il segnale di sincronizzazione verticale</string>
    <string name="elem_VGA_pin_C">Il clock dei pixel</string>
    <string name="elem_MIDI_tt">Utilizza il sistema MIDI per riprodurre delle note.</string>
    <string name="elem_MIDI_pin_N">Nota</string>
    <string name="elem_MIDI_pin_V">Volume</string>
    <string name="elem_MIDI_pin_OnOff">Se impostato, questo si traduce nella pressione di un tasto nella tastiera (evento tasto premuto), se non impostato
        allora questo si traduce nel rilascio (evento tasto rilasciato).</string>
    <string name="elem_MIDI_pin_en">Abilita il componente</string>
    <string name="elem_MIDI_pin_PC">Se alto, il valore in N è utilizzato per cambiare il programma (strumento).</string>
    <string name="elem_StepperMotorUnipolar">Motore Passo-Passo Unipolare</string>
    <string name="elem_StepperMotorUnipolar_tt">Motore passo-passo unipolare con due finecorsa. Sono supportati azionamento
        a passo completo, mezzo passo e passo d'onda.</string>
    <string name="elem_StepperMotorUnipolar_pin_S0">Finecorsa 0, diventa alto quando l'angolo del motore è di 0°.</string>
    <string name="elem_StepperMotorUnipolar_pin_S1">Finecorsa posizione 1, diventa alto quando l'angolo del motore è di 180°.</string>
    <string name="elem_StepperMotorUnipolar_pin_P0">Fase 0</string>
    <string name="elem_StepperMotorUnipolar_pin_P1">Fase 1</string>
    <string name="elem_StepperMotorUnipolar_pin_P2">Fase 2</string>
    <string name="elem_StepperMotorUnipolar_pin_P3">Fase 3</string>
    <string name="elem_StepperMotorUnipolar_pin_com">Collegamento comune della bobina centrale</string>
    <string name="elem_StepperMotorBipolar">Motore Passo-Passo Bipolare</string>
    <string name="elem_StepperMotorBipolar_tt">Motore passo-passo bipolare con due finecorsa. Sono supportati azionamento
        a passo completo, mezzo passo e passo d'onda.</string>
    <string name="elem_StepperMotorBipolar_pin_S0">Finecorsa 0, diventa alto quando l'angolo del motore è 0°.</string>
    <string name="elem_StepperMotorBipolar_pin_S1">Finecorsa 1, diventa alto quando l'angolo del motore è 180°.</string>
    <string name="elem_StepperMotorBipolar_pin_A+">Bobina A, positivo</string>
    <string name="elem_StepperMotorBipolar_pin_A-">Bobina A, negativo</string>
    <string name="elem_StepperMotorBipolar_pin_B+">Bobina B, positivo</string>
    <string name="elem_StepperMotorBipolar_pin_B-">Bobina B, negativo</string>
    <string name="elem_Ground">Massa</string>
    <string name="elem_Ground_tt">Una connessione a massa. L'uscita è sempre zero.</string>
    <string name="elem_Ground_pin_out">L'uscita restituisce sempre bassa.</string>
    <string name="elem_VDD">Tensione di alimentazione</string>
    <string name="elem_VDD_tt">Una connessione alla tensione di alimentazione. L'uscita è sempre alta.</string>
    <string name="elem_VDD_pin_out">Questa uscita è sempre alta.</string>
    <string name="elem_NotConnected">Non Connesso</string>
    <string name="elem_NotConnected_tt">Questo componente può essere usato per impostare un cavo ad alta impedenza. Se un ingresso di una porta logica è 
        impostato ad alta impedenza, il valore in lettura è indefinito. Nota che in realtà in molti casi un eccessivo
        consumo di corrente e anche danneggiamento può verificarsi se un ingresso difitale non è impostato ad alto o
        basso ma rimane scollegato.</string>
    <string name="elem_NotConnected_pin_out">Questa uscita è sempre ad alta impedenza.</string>
    <string name="err_notConnectedNotAllowed">Il simbolo NonConnesso non è consentito qua!</string>
    <string name="elem_Const">Valore costante</string>
    <string name="elem_Const_tt">Un componente che restituisce un valore come una semplice costante. Il valore può essere impostato nel dialogo degli attributi.</string>
    <string name="elem_Const_pin_out">Restituisce il valore sotto forma di costante.</string>
    <string name="elem_Tunnel_tt">Connette componenti senza un cavo. Tutti i componenti tunnel, che hanno lo stesso nome della rete, sono connessi
        insieme. Funziona soltanto localmente, quindi non è possibile connettere circuiti differenti. I tunnel senza
        nome sono silenziosamente ignorati.</string>
    <string name="elem_Tunnel_pin_in">La connessione al tunnel.</string>
    <string name="elem_Splitter_tt">Divide o crea un insieme di cavi o un bus dati con più di un bit. Con un bus è per esempio possibile generare
        connessioni a 16 bit senza aver bisogno di piazzare 16 cavi individuali. Tutte le 16 connessioni possono essere
        unite in un unico cavo. Lo splitter ha una direzione, ovvero può trasmettere segnali soltanto verso una direzione.</string>
    <string name="elem_Splitter_pin_in">I bit di ingresso {0}.</string>
    <string name="elem_Splitter_pin_in_one">Il bit di ingresso {0}.</string>
    <string name="elem_Splitter_pin_out">I bit di uscita {0}.</string>
    <string name="elem_Splitter_pin_out_one">Il bit di uscita {0}.</string>
    <string name="elem_BusSplitter">Splitter Bidirezionale</string>
    <string name="elem_BusSplitter_tt">Può essere usato per i bus dati e semplifica in particolare la costruzione di un modulo di memoria in un package DIL,
        visto che l'implementazione del bus dati è semplificata.</string>
    <string name="elem_BusSplitter_pin_OE">Quando impostato, il valore al terminale dati comune D è messo nell'uscita binaria D[i], altrimenti
        i bit D[i] sono inseriti nell'uscita comune D.</string>
    <string name="elem_BusSplitter_pin_D">La connessione dati comune.</string>
    <string name="elem_BusSplitter_pin_D_N">Il bit dati {0} dello splitter del bus.</string>
    <string name="elem_PullUp">Restitore di Pull-Up</string>
    <string name="elem_PullUp_pin_out">Un segnale alto "debole".</string>
    <string name="elem_PullUp_tt">Se una rete è in uno stato di alta impedenza, questo resistore porta la rete ad un valore alto.
        In qualsiasi altro caso, questo componente non ha effetto.</string>
    <string name="elem_PullDown">Resistore di Pull-Down</string>
    <string name="elem_PullDown_pin_out">Un segnale basso "debole".</string>
    <string name="elem_PullDown_tt">Se la rete è in uno stato di alta impedenza, questo resistore porta la rete ad un valore basso.
        In qualsiasi altro caso, questo componente non ha effetto.</string>
    <string name="elem_Driver_tt">Un driver può essere usato per connettere un valore di un segnale ad un altro cavo.
        Se l'ingresso di selezione è basso, l'uscita è in alta impedenza.
        Se l'ingresso di selezione è alto, l'uscita è impostata al valore in ingresso.</string>
    <string name="elem_Driver_pin_in">Il valore in ingresso del driver.</string>
    <string name="elem_Driver_pin_out">Se l'ingresso di selezione è alto, l'ingresso è assegnato a questa uscita.
        Se l'ingresso di selezione è basso, questa uscita è in alta impedenza.</string>
    <string name="elem_Driver_pin_sel">Pin per controllare il driver.
        Se il valore è alto, l'ingresso è impostato all'uscita.
        Se il valore è basso, l'uscita è in alta impedenza.</string>
    <string name="elem_DriverInvSel">Driver, selezione invertita</string>
    <string name="elem_DriverInvSel_tt">Un driver può essere utilizzato per connettere un valore di un segnale ad un altro cavo.
        Se l'ingresso di selezione è alto, l'uscita è in alta impedenza.
        Se l'ingresso di selezione è basso, l'uscita è impostata al valore di ingresso.</string>
    <string name="elem_DriverInvSel_pin_in">Il valore in ingresso del driver.</string>
    <string name="elem_DriverInvSel_pin_sel">Pin per controllare il driver.
        Se il valore è basso, l'ingresso è impostato all'uscita.
        Se il valore è alto, l'uscita è in alta impedenza.</string>
    <string name="elem_DriverInvSel_pin_out">Se l'ingresso di selezione è basso, l'ingresso è assegnato a questa uscita.
        Se l'ingresso di selezione è alto, questa uscita è in alta impedenza.</string>
    <string name="elem_PinControl">Controllo del Pin</string>
    <string name="elem_PinControl_tt">Logica di controllo per un pin bidirezionale.
        Questo componente è necessario soltanto nel contesto di una generazione VHDL o Verilog, per creare una porta
        HDL bidirezionale. Se non vuoi usare una porta di I/O bidirezionale su una FPGA, non usare questo componente!
        Questo componente non può essere usato in un circuito incorporato, ma solo nel circuito principale (ovvero quello di più
        alto livello).</string>
    <string name="elem_PinControl_pin_wr">Il dato da mettere nell'uscita.</string>
    <string name="elem_PinControl_pin_oe">Attiva l'uscita.</string>
    <string name="elem_PinControl_pin_rd">Il dato da leggere.</string>
    <string name="elem_PinControl_pin_pin">Il connettore per il pin. Solo una singola uscita deve essere collegata.</string>
    <string name="elem_Multiplexer_tt">Un componente che usa il valore di un pin di selezione per decidere quale valore
        di ingresso impostare nell'uscita.</string>
    <string name="elem_Multiplexer_input">Il {0}. ingresso dati del multiplexer.</string>
    <string name="elem_Multiplexer_output">Il valore dell'ingresso selezionato.</string>
    <string name="elem_Multiplexer_pin_sel">Questo ingresso è utilizzato per selezionare l'ingresso da riflettere nell'uscita.</string>
    <string name="elem_Demultiplexer_tt">Un componente che può mettere il valore in ingresso ad una delle sue uscite. Tutte le altre sono
        impostate al valore predefinito.</string>
    <string name="elem_Demultiplexer_pin_sel">Questo pin seleziona l'uscita da usare.</string>
    <string name="elem_Demultiplexer_pin_in">Il valore di questo ingresso è dato all'uscita dati selezionata.</string>
    <string name="elem_Demultiplexer_output">Uscita dati {0}.</string>
    <string name="elem_Decoder">Decodificatore</string>
    <string name="elem_Decoder_tt">Un pin dell'output selezionabile è impostato ad alto, tutte le altre uscite a basso.</string>
    <string name="elem_Decoder_output">Uscita {0}. Questa è alta se è selezionata dall''ingresso selezione.</string>
    <string name="elem_Decoder_pin_sel">Questo ingresso seleziona l'uscita abilitata.
        L'uscita selezionata è impostata ad alto, tutte le altre a basso.</string>
    <string name="elem_BitSelector">Selettore del Bit</string>
    <string name="elem_BitSelector_tt">Seleziona un singolo bit da un bus dati.</string>
    <string name="elem_BitSelector_pin_in">Il bus in ingresso</string>
    <string name="elem_BitSelector_pin_sel">Questo ingresso seleziona il bit</string>
    <string name="elem_BitSelector_pin_out">Il bit selezionato.</string>
    <string name="elem_PriorityEncoder">Codificatore a Priorità</string>
    <string name="elem_PriorityEncoder_short">Priorità</string>
    <string name="elem_PriorityEncoder_tt">Se uno degli ingressi è impostato, il suo numero è l'uscita.
        Se più di un ingresso è impostato simultaneamente, il numero più alto diventa l'uscita.</string>
    <string name="elem_PriorityEncoder_pin_num">Numero dell'ingresso impostato.</string>
    <string name="elem_PriorityEncoder_pin_any">Se questa uscita è impostata, almeno uno degli ingressi è impostato.</string>
    <string name="elem_PriorityEncoder_input">Il {0}. ingresso del codificatore a priorità.</string>
    <string name="elem_RS_FF_AS_tt">Un componente per memorizzare un singolo bit. Fornisce funzioni di "set" (memorizzazione di un valore alto) e "reset"
        (impostazione di un valore basso). Se entrambe gli ingressi sono alti, anche tutte e due le uscite saranno alte.
        Se entrambe gli ingressi sono reimpostati a basso nello stesso momento, lo stato finale è imprevedibile.</string>
    <string name="elem_RS_FF_AS_pin_S">L'ingresso di "set".</string>
    <string name="elem_RS_FF_AS_pin_R">L'ingresso di "reset".</string>
    <string name="elem_RS_FF_AS_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_RS_FF_AS_pin_~Q">Restituisce il valore memorizzato, negato.</string>
    <string name="elem_RS_FF">RS-Flip-flop con Clock</string>
    <string name="elem_RS_FF_tt">Un componente per memorizzare un singolo bit. Fornisce funzioni di "set" (memorizzazione di un valore alto) e "reset"
        (impostazione di un valore basso). Se entrambe gli ingressi (S, R) sono impostati nel fronte di salita del clock, lo
        stato finale è imprevedibile.</string>
    <string name="elem_RS_FF_pin_S">L'ingresso di "set".</string>
    <string name="elem_RS_FF_pin_C">L'ingresso del clock. Un fronte di salita indica una transizione di stato.</string>
    <string name="elem_RS_FF_pin_R">L'ingresso di "reset".</string>
    <string name="elem_RS_FF_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_RS_FF_pin_~Q">Restituisce il valore memorizzato, negato.</string>
    <string name="elem_JK_FF_tt">Ha la possibilità di memorizzare (J=K=0), impostare (J=1, K=0), resettare (J=0, K=1) o invertire (J=K=1) il
        valore memorizzato. Un cambiamento di stato ha luogo soltanto nel fronte di salita del clock all'ingresso C.</string>
    <string name="elem_JK_FF_pin_J">L'ingresso di "set" del flip-flop.</string>
    <string name="elem_JK_FF_pin_C">L'ingresso del clock. Un fronte di salita indica una transizione di stato.</string>
    <string name="elem_JK_FF_pin_K">L'ingresso di "reset" del flip-flop.</string>
    <string name="elem_JK_FF_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_JK_FF_pin_~Q">Restituisce il valore memorizzato, negato.</string>
    <string name="elem_D_FF_tt">Un componente usato per memorizzare un valore.
        Il valore nel pin D è memorizzato nel fronte di salita del clock C.
        Il numero di bit può essere selezionato, il ché consente di memorizzare più di un bit.</string>
    <string name="elem_D_FF_pin_D">L'ingresso del bit da memorizzare.</string>
    <string name="elem_D_FF_pin_C">L'ingresso del clock per memorizzare un valore.
        Il valore nell'ingresso D è memorizzato durante un fronte di salita su questo pin.</string>
    <string name="elem_D_FF_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_D_FF_pin_~Q">Restituisce il valore memorizzato, negato.</string>
    <string name="elem_T_FF_tt">Memorizza un singolo bit. Inverte lo stato con un fronte di salita sul clock C.</string>
    <string name="elem_T_FF_pin_T">Abilita la funzione di inversione.</string>
    <string name="elem_T_FF_pin_C">Ingresso del clock. Un fronte di salita inverte l'uscita, se l'ingresso T è alto.</string>
    <string name="elem_T_FF_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_T_FF_pin_~Q">Restituisce il valore memorizzato, negato.</string>
    <string name="elem_JK_FF_AS">JK-Flip-flop, asincrono</string>
    <string name="elem_JK_FF_AS_tt">Ha la possibilità di memorizzare (J=K=0), impostare (J=1, K=0), resettare (J=0, K=1) o invertire (J=K=1) il valore
        memorizzato. Un cambiamento di stato ha luogo soltanto durante il fronte di salita nell'ingresso del clock C.
        Ci sono due ingressi aggiuntivi che impostati o resettano il valore memorizzato immediatamente senza un segnale di clock.</string>
    <string name="elem_JK_FF_AS_pin_J">L'ingresso "set" del flip-flop.</string>
    <string name="elem_JK_FF_AS_pin_C">L'ingresso del clock. Un fronte di salita inizia un cambiamento di stato.</string>
    <string name="elem_JK_FF_AS_pin_K">L'ingresso "reset" del flip-flop.</string>
    <string name="elem_JK_FF_AS_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_JK_FF_AS_pin_~Q">Restituisce il valore memorizzato, negato.</string>
    <string name="elem_JK_FF_AS_pin_Set">"set" asincrono. Un valore alto effettua un "set" immediato nel flip-flop.</string>
    <string name="elem_JK_FF_AS_pin_Clr">"clear" asincrono. Un valore alto effettua un "clear" immediato nel flip-flop.</string>
    <string name="elem_D_FF_AS">D-Flip-flop, asincrono</string>
    <string name="elem_D_FF_AS_tt">Un componente utilizzato per memorizzare un valore.
        Il valore nel pin D è memorizzato durante un fronte di salita del pin del clock C.
        Ci sono due ingressi aggiuntivi che impostano o resettano lo stato immediatamente senza un segnale di clock.
        Il numero di bit può essere selezionato, il ché consente di memorizzare più bit.</string>
    <string name="elem_D_FF_AS_pin_D">Ingresso del bit da memorizzare.</string>
    <string name="elem_D_FF_AS_pin_C">Pin din controllo per memorizzare un bit. Il bit nell'ingresso D è memorizzato durante un fronte di salita di questo pin.</string>
    <string name="elem_D_FF_AS_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_D_FF_AS_pin_~Q">Restituisce il valore memorizzato, negato.</string>
    <string name="elem_D_FF_AS_pin_Set">"set" asincrono. Un valore alto imposta tutti i bit memorizzati ad un valore alto.</string>
    <string name="elem_D_FF_AS_pin_Clr">"clear" asincrono. Un valore alto imposta tutti i bit memorizzati ad un valore basso.</string>
    <string name="elem_Monoflop_tt">Il monoflop è impostato ad un fronte di salita del clock.
        Dopo un tempo di ritardo configurabile, il monoflop sarà resettato automaticamente.
        Il monoflop può essere riattivato. Può essere usato soltanto se c'è esattamente un solo componente di clock presente
        nel circuito.
        Questo componente di clock è utilizzato come la base temporale con cui vengono misurati ritardi di tempo.</string>
    <string name="elem_Monoflop_pin_R">Ingresso del reset. Un valore alto resetta il monoflop.</string>
    <string name="elem_Monoflop_pin_C">Ingresso del clock. Un fronte di salita imposta il monoflop.</string>
    <string name="elem_Monoflop_pin_Q">uscita</string>
    <string name="elem_Monoflop_pin_~Q">uscita invertita</string>
    <string name="elem_Register">Registro</string>
    <string name="elem_Register_tt">Un componente utilizzato per memorizzare valori. Il numero di bit della parola dati può essere selezionato.
        Al contrario di un D-Flip-flop, il registro forniisce un ingresso che abilita il clock.</string>
    <string name="elem_Register_pin_D">Pin di ingresso della parola dati da memorizzare.</string>
    <string name="elem_Register_pin_C">Ingresso del clock. Un fronte di salita memorizza il valore presente nel pin D.</string>
    <string name="elem_Register_pin_en">Pin di enable. La memorizzazione di un valore funziona soltanto se questo pin è impostato ad alto.</string>
    <string name="elem_Register_pin_Q">Restituisce il valore memorizzato.</string>
    <string name="elem_ROM_tt">Un componente di memoria non-volatile. I dati memorizzati possono essere modificati dal dialogo degli attributi.</string>
    <string name="elem_ROM_pin_A">Questo pin definisce un indirizzo della parola dati da mettere nell'uscita.</string>
    <string name="elem_ROM_pin_D">La parola dati selezionata se l'ingresso di selezione è alto.</string>
    <string name="elem_ROM_pin_sel">Se l'ingresso di selezione è alto, l'uscita è abilitata. Se è basso, l'uscita dati è in alta impedenza.</string>
    <string name="elem_ROMDualPort">ROM a doppia porta</string>
    <string name="elem_ROMDualPort_tt">Un componente di memoria non-volatile. I dati memorizzati possono essere modificati dal dialogo degli attributi.</string>
    <string name="elem_ROMDualPort_pin_A1">Questo pin definisce l'indirizzo della parola dati da mettere nell'uscita su D1.</string>
    <string name="elem_ROMDualPort_pin_D1">La parola dati selezionata se l'ingresso S1 è alto.</string>
    <string name="elem_ROMDualPort_pin_s1">Se l'ingresso è alto, l'uscita D1 è attivata. Se è basso, l'uscita dati è in alta impedenza.</string>
    <string name="elem_ROMDualPort_pin_A2">Questo pin definisce l'indirizzo della parola dati da mettere nell'uscita D2.</string>
    <string name="elem_ROMDualPort_pin_D2">La parola dati selezionata se l'ingresso di S2 è alto.</string>
    <string name="elem_ROMDualPort_pin_s2">Se l'ingresso è alto, l'uscita D2 è attivata. Se è basso, l'uscita dati è in alta impedenza.</string>
    <string name="elem_RAMDualPort">RAM, porte separate</string>
    <string name="elem_RAMDualPort_tt">Un modulo RAM con ingressi separati per memorizzare e uscite per leggere i dati memorizzati.</string>
    <string name="elem_RAMDualPort_pin_A">L'indirizzo da cui leggere o scrivere.</string>
    <string name="elem_RAMDualPort_pin_C">Ingresso del clock</string>
    <string name="elem_RAMDualPort_pin_Din">I dati da memorizzare nella RAM.</string>
    <string name="elem_RAMDualPort_pin_D">Il pin dell'uscita dati</string>
    <string name="elem_RAMDualPort_pin_ld">Se questo ingresso è alto allora l'uscita è attivata e i dati sono visibili.</string>
    <string name="elem_RAMDualPort_pin_str">Se questo ingresso è alto quando c'è un fronte di salita nel clock, i dati sono memorizzati.</string>
    <string name="elem_RAMAsync">RAM, asincrona</string>
    <string name="elem_RAMAsync_tt">Fino a quando il write-enable è impostato, l'ingresso è memorizzato. Corrisponde ad una semplice RAM, dove le linee di dati ed
        indirizzi sono direttamente connesse ai decodificatori delle celle di memoria.</string>
    <string name="elem_RAMAsync_pin_A">L'indirizzo in cui la lettura o scrittura ha luogo.</string>
    <string name="elem_RAMAsync_pin_D">I dati da memorizzare.</string>
    <string name="elem_RAMAsync_pin_we">Write enable. Fino a quando l'ingresso è alto, il valore applicato a D è memorizzato nell'indirizzo applicato su A in
        qualsiasi caso in cui A o D cambia.</string>
    <string name="elem_RAMAsync_pin_Q">Uscita corrispondente ai dati memorizzati.</string>
    <string name="elem_BlockRAMDualPort">Block-RAM, porte separate</string>
    <string name="elem_BlockRAMDualPort_tt">Un modulo RAM con ingressi di memorizzazione e uscite di lettura dati separati. La RAM aggiorna le sue
        uscite durante un fronte di salita del clock. Questo consente l'utilizzo di una Block-RAM su una FPGA.</string>
    <string name="elem_BlockRAMDualPort_pin_A">L'indirizzo da cui leggere o scrivere.</string>
    <string name="elem_BlockRAMDualPort_pin_C">L'ingresso del clock.</string>
    <string name="elem_BlockRAMDualPort_pin_Din">I dati da memorizzare nella RAM.</string>
    <string name="elem_BlockRAMDualPort_pin_D">Il pin dell'uscita dati.</string>
    <string name="elem_BlockRAMDualPort_pin_str">Se questo ingresso è alto e c'è un fronte di salita del clock, i dati sono memorizzati.</string>
    <string name="elem_EEPROMDualPort">EEPROM, porte separate</string>
    <string name="elem_EEPROMDualPort_tt">Un modulo EEPROM con ingressi per memorizzazione e uscite per lettura dati separati.</string>
    <string name="elem_EEPROMDualPort_pin_A">L'indirizzo da cui leggere o scrivere.</string>
    <string name="elem_EEPROMDualPort_pin_C">L'ingresso del clock</string>
    <string name="elem_EEPROMDualPort_pin_Din">I dati da memorizzare nella EEPROM.</string>
    <string name="elem_EEPROMDualPort_pin_D">Il pin di uscita dati.</string>
    <string name="elem_EEPROMDualPort_pin_ld">Se questo ingresso è alto l'uscita è attivata e i dati diventano visibili.</string>
    <string name="elem_EEPROMDualPort_pin_str">Se questo ingresso è alto e c'è un fronte di salita del clock, i dati sono memorizzati.</string>
    <string name="elem_RAMSinglePort">RAM, porte bidirezionali</string>
    <string name="elem_RAMSinglePort_tt">Un modulo RAM con pin bidirezionali per lettura e scrittura dei dati.</string>
    <string name="elem_RAMSinglePort_pin_A">L'indirizzo di scrittura o lettura dati.</string>
    <string name="elem_RAMSinglePort_pin_D">Connessione bidirezionale per i dati.</string>
    <string name="elem_RAMSinglePort_pin_ld">Se l'ingresso è alto l'uscita è attivata e i dati diventano visibili.</string>
    <string name="elem_RAMSinglePort_pin_str">Se l'ingresso è alto e c'è un fronte di salita del clock, i dati sono memorizzati.</string>
    <string name="elem_RAMSinglePortSel_tt">Un modulo RAM con una connessione bidirezionale per la lettura e scrittura dati.
        Se l'ingresso chip-select è basso, il componente è disabilitato.
        Questo consente la costruzione di una RAM più grande a partire da tanti altri moduli RAM più piccooli tramite
        l'utilizzo di un decodificatore di indirizzi.
        Il ciclo di scrittura funziona in questo modo: mettendo chip-select ad alto, il componente diventa selezionato;
        un fronte di salita nel write-enable scrive l'indirizzo e il fronte di discesa successivo memorizza i dati.</string>
    <string name="elem_RAMSinglePortSel_pin_A">L'indirizzo di lettura e scrittura dati.</string>
    <string name="elem_RAMSinglePortSel_pin_WE">Se impostato ad alto, i dati sono scritti nella RAM.</string>
    <string name="elem_RAMSinglePortSel_pin_D">La connessione dati bidirezionale.</string>
    <string name="elem_RAMSinglePortSel_pin_CS">Se impostato ad alto, questo modulo di RAM è abilitato. Altrimenti l'uscita sarà sempre in alta impedenza.</string>
    <string name="elem_RAMSinglePortSel_pin_OE">Se impostato ad alto, il valore memorizzato è presente nell'uscita.</string>
    <string name="elem_EEPROM_tt">Un modulo RAM con una connessione bidirezionale per la lettura e scrittura dati.
        Se l'ingresso chip-select è basso, il componente è disabilitato.
        I dati sono memorizzati come in una ROM. Vengono quindi preservati quando la simulazione termina e/o è riavviata.
        Il ciclo di scrittura funziona in questo modo: mettendo chip-select ad alto, il componente diventa selezionato;
        un fronte di salita nel write-enable scrive l'indirizzo e il fronte di discesa successivo memorizza i dati.</string>
    <string name="elem_EEPROM_pin_A">L'indirizzo di lettura o scrittura dati.</string>
    <string name="elem_EEPROM_pin_WE">Se impostato ad alto, i dati sono scritti nella EEPROM.</string>
    <string name="elem_EEPROM_pin_D">La connessione dati bidirezionale.</string>
    <string name="elem_EEPROM_pin_CS">Se impostato ad alto, la EEPROM è abilitata. Altrimenti l'uscita è sempre in alta impedenza.</string>
    <string name="elem_EEPROM_pin_OE">Se impostato ad alto, il valore memorizzato è presente nell'uscita.</string>
    <string name="elem_GraphicCard">RAM Grafica</string>
    <string name="elem_GraphicCard_tt">Utilizzato per mostrare una immagine grafica. Questo elemento si comporta come una RAM. In aggiunta,
        mostra il suo contenuto in uno schermo grafico. Ogni pixel è rappresentato da un indirizzo di memoria. Il valore
        memorizzato definisce il colore del pixel, usando una paletta di colori prefissata. Ci sono due buffer dello schermo
        implementati per supportare il page flipping. L'ingresso B seleziona quale buffer sarà mostrato. Quindi, la memoria
        totale sarà dx * dy * 2 parole.
        La paletta di colori utilizzata è strutturata come segue: gli indici 0-9 corrispondono ai colori bianco, nero,
        rosso, verde, blu, giallo, azzurro, viola, arancio e rosa. Gli indici 32-63 mappano valori di grigio e gli indici
        64-127 mappano 64 valori di colore ciascuno con due bit per canale.
        Questo risulta in una semplice paletta che può essere indirizzata con solo 7 bit. Se l'architettura supporta un
        indice a 16 bit, dall'indice 0x8000, una modalità di "high-color" con 5 bit per canale può essere usata, per un
        totale di 32768 colori.</string>
    <string name="elem_GraphicCard_pin_A">L'indirizzo di lettura o scrittura dati.</string>
    <string name="elem_GraphicCard_pin_str">Se impostato ad alto quando c'è un fronte di salita del clock, i dati sono memorizzati.</string>
    <string name="elem_GraphicCard_pin_ld">Se impostato ad alto, l'uscita è attivata e i dati sono resi visibili nell'uscita.</string>
    <string name="elem_GraphicCard_pin_B">Seleziona il buffer da visualizzare nello schermo.</string>
    <string name="elem_GraphicCard_pin_D">La connessione dati bidirezionale.</string>
    <string name="elem_RAMDualAccess">RAM, Doppia Porta</string>
    <string name="elem_RAMDualAccess_tt">Una RAM con una porta che consente di scrivere e leggere ed una seconda porta di sola lettura.
        Questa seconda porta può essere sata per fornire un accesso ai contenuti della memoria per la logica grafica. In
        questo modo, un processore può scrivere nella memoria video e la logica grafica visualizzerà il contenuto letto
        dalla RAM simultaneamente.</string>
    <string name="elem_RAMDualAccess_pin_1D">Porta di uscita 1</string>
    <string name="elem_RAMDualAccess_pin_2D">Porta di uscita 2</string>
    <string name="elem_RAMDualAccess_pin_1A">L'indirizzo in cui la porta 1 è letta o scritta.</string>
    <string name="elem_RAMDualAccess_pin_2A">L'indirizzo utilizzato per leggere dalla porta 2.</string>
    <string name="elem_RAMDualAccess_pin_1Din">I dati da memorizzare nella RAM.</string>
    <string name="elem_RAMDualAccess_pin_ld">Se impostato ad alto, l'uscita è attivata e i dati sono resi visibili nell'uscita 1D.</string>
    <string name="elem_RAMDualAccess_pin_str">Se impostato ad alto quando c'è un fronte di salita nel clock, i dati sono memorizzati.</string>
    <string name="elem_RegisterFile">File Registro</string>
    <string name="elem_RegisterFile_short">Registro</string>
    <string name="elem_RegisterFile_tt">Memoria con una oprta che consente di scrivere e due porte che consentono di leggere dalla memoria simultaneamente.
        Può essere usata per implementare i registri di un processore. Due registri possono essere letti simultaneamente
        ed un terzo può essere scritto.</string>
    <string name="elem_RegisterFile_pin_Da">-Porta d'uscita A</string>
    <string name="elem_RegisterFile_pin_Db">Porta d'uscita B</string>
    <string name="elem_RegisterFile_pin_Ra">Il registro visibile nella porta A.</string>
    <string name="elem_RegisterFile_pin_Rb">Il registro visibile nella porta B.</string>
    <string name="elem_RegisterFile_pin_Rw">Il registro in cui i dati sono scritti.</string>
    <string name="elem_RegisterFile_pin_we">Se impostato ad alto, durante un fronte di salita del clock, i dati sono memorizzati.</string>
    <string name="elem_RegisterFile_pin_Din">I dati da memorizzare nel registro Rw.</string>
    <string name="elem_Counter">Contatore</string>
    <string name="elem_Counter_short">Contatore</string>
    <string name="elem_Counter_tt">Un semplice contatore. L'ingresso del clock incrementa il contatore.
        Può essere resettato a zero con l'ingresso CLR. Il numero di bit può essere impostato nel dialogo degli attributi.</string>
    <string name="elem_Counter_pin_C">L'ingresso del clock. Un fronte di salita incrementa il contatore.</string>
    <string name="elem_Counter_pin_clr">Reset sincrono del contatore se impostato ad alto.</string>
    <string name="elem_Counter_pin_ovf">Uscita dell'overflow. Questo pin è impostato ad un valore alto se il contantore è al suo valore
        massimo e anche l'ingresso è impostato ad alto.</string>
    <string name="elem_Counter_pin_out">Restituisce il valore del contatore.</string>
    <string name="elem_Counter_pin_en">Se impostato ad alto, il contatore è abilitato.</string>
    <string name="elem_CounterPreset">Contatore con preset</string>
    <string name="elem_CounterPreset_tt">Un contatore il cui valore può essere impostato. In aggiunta, un valore massimo e una direzione
        di conteggio possono essere specificate.</string>
    <string name="elem_CounterPreset_short">Contatore</string>
    <string name="elem_CounterPreset_pin_out">Restituisce il valore del contatore.</string>
    <string name="elem_CounterPreset_pin_ovf">Uscita dell'overflow. Questo viene impostato ad alto se l'ingresso "en" è alto e se il contatore
        raggiunge il suo massimo valore quando conta verso l'alto oppure se ha raggiunto lo zero contando
        verso il basso.</string>
    <string name="elem_CounterPreset_pin_C">L'ingresso del clock. Un fronte di salita incrementa o decrementa il contatore.</string>
    <string name="elem_CounterPreset_pin_clr">Reset sincrono del contatore se impostato ad alto.</string>
    <string name="elem_CounterPreset_pin_en">Se impostato ad alto il contatore è abilitato.</string>
    <string name="elem_CounterPreset_pin_dir">Specifica la direzione del conteggio. Un valore basso significa un conteggio in avanti.</string>
    <string name="elem_CounterPreset_pin_ld">Se impostato, il valore all'ingresso "in" è memorizzato nel contatore al prossimo segnale di clock.</string>
    <string name="elem_CounterPreset_pin_in">Questa parola dati è memorizzata nel contatore quando "ld" è impostato.</string>
    <string name="elem_Add">Sommatore</string>
    <string name="elem_Add_tt">Un componente per semplici addizioni. Effettua l'addizione tra i due ingressi
        numerici interi A e B (A+B). Il risultato sarè incrementato di uno se l'ingresso del riporto è impostato.</string>
    <string name="elem_Add_pin_a">Primo ingresso da sommare.</string>
    <string name="elem_Add_pin_b">Secondo ingresso da sommare.</string>
    <string name="elem_Add_pin_s">Il risultato dell'addizione.</string>
    <string name="elem_Add_pin_c_i">Ingresso del riporto. Se impostato questo fa incrementare il risultato di uno.</string>
    <string name="elem_Add_pin_c_o">Uscita del riporto. Impostato se si è verificato un overflow.</string>
    <string name="elem_Sub">Sottrattore</string>
    <string name="elem_Sub_tt">Un componente per semplici sottrazioni.
        Sottrae numeri binari negli ingressi A e B (A-B).
        Se l'ingresso di riporto è impostato ad alto, allora il risultato è decrementato di uno.</string>
    <string name="elem_Sub_pin_c_i">Ingresso del riporto. Se impostato questo fa decrementare il risultato di uno.</string>
    <string name="elem_Sub_pin_a">Ingresso A per la sottrazione.</string>
    <string name="elem_Sub_pin_b">Ingresso B per la sottrazione.</string>
    <string name="elem_Sub_pin_s">Il risultato della sottrazione.</string>
    <string name="elem_Sub_pin_c_o">Impostato ad alto se si è verificato un underflow.</string>
    <string name="elem_Mul">Moltiplicatore</string>
    <string name="elem_Mul_tt">Un componente per la moltiplicazione.
        Moltiplica i numeri interi negli ingressi A e B.</string>
    <string name="elem_Mul_pin_a">Ingresso A per la moltiplicazione.</string>
    <string name="elem_Mul_pin_b">Ingresso B per la moltiplicazione.</string>
    <string name="elem_Mul_pin_mul">Uscita per il risultato della moltiplicazione.</string>
    <string name="elem_Div">Divisore</string>
    <string name="elem_Div_tt">Un componente per la divisione.
        Divide il numer intero applicato all'ingresso A per l'altro numero intero applicato all'ingresso B.
        Se il divisore è zero, è diviso per uno.
        Nella divisione con segno, il resto è sempre positivo.</string>
    <string name="elem_Div_pin_a">dividendo</string>
    <string name="elem_Div_pin_b">divisore</string>
    <string name="elem_Div_pin_q">quoziente</string>
    <string name="elem_Div_pin_r">resto</string>
    <string name="elem_BarrelShifter_tt">Un componente per lo scorrimento dei bit. Scorre i bit del valore di ingresso per un numero specificato
        dall'ingresso dello scorrimento bit.</string>
    <string name="elem_BarrelShifter_pin_in">L'ingresso dati contenente i bit da scorrere.</string>
    <string name="elem_BarrelShifter_pin_shift">L'ingresso che indica di quanti bit scorrere i dati.</string>
    <string name="elem_BarrelShifter_pin_out">L'uscita con il valore sul quale è stato applicato lo scorrimento dei bit.</string>
    <string name="elem_Comparator">Comparatore</string>
    <string name="elem_Comparator_tt">Un componente per comparare valori binari.
        Compara i numeri binari nei due ingressi A e B ed imposta le rispettive uscite.</string>
    <string name="elem_Comparator_pin_a">Ingresso A da comparare.</string>
    <string name="elem_Comparator_pin_b">Ingresso B da comparare.</string>
    <string name="elem_Comparator_pin_=">L'uscita è alta se i due ingressi sono uguali.</string>
    <string name="elem_Comparator_pin_&gt;">L'uscita è alta se l'ingresso A è più grande dell'ingresso B.</string>
    <string name="elem_Comparator_pin_&lt;">L'uscita è alta se l'ingresso A è più piccolo dell'ingresso B.</string>
    <string name="elem_Neg">Negazione</string>
    <string name="elem_Neg_pin_in">Ingresso della parola dati da negare con il complemento a due.</string>
    <string name="elem_Neg_pin_out">Restituisce il valore della negazione con complemento a due.</string>
    <string name="elem_Neg_tt">Negazione nel complemento a due.</string>
    <string name="elem_BitExtender">Estenditore del segno</string>
    <string name="elem_BitExtender_tt">Incrementa il numero di bit di un numero intero con segno mantenendo il segno.
        Se l'ingresso è un singolo bit, quel bit sarà impostato per ogni bit nell'uscita.</string>
    <string name="elem_BitExtender_pin_in">Valore di ingresso.
        Il numero di bit nell'ingresso deve essere più piccolo del numero di bit nell'uscita!</string>
    <string name="elem_BitExtender_pin_out">Valore di ingresso esteso.
        Il numero di bit nell'ingresso deve essere più piccolo del numero di bit nell'uscita!</string>
    <string name="elem_BitCount">Contatore di bit</string>
    <string name="elem_BitCount_tt">Restituisce il numero di bit ad 1 nel valore di ingresso.</string>
    <string name="elem_BitCount_pin_in">L'ingresso da cui i bit a 1 sono conteggiati.</string>
    <string name="elem_BitCount_pin_out">L'uscita con il numero di bit ad 1.</string>
    <string name="elem_PRNG">Generatore di Numeri Casuali</string>
    <string name="elem_PRNG_tt">Può essere utilizzato per generare numeri casuali.
        Quando la simulazione viene avviata, il generatore è reinizializzato così che una nuova sequenza di
        numeri pseudo-casuali verrà generata.
        Il generatore può essere inizializzato durante una simulazione già avviata con un seme per generare una
        sequenza di numeri predefinita e deterministica.</string>
    <string name="elem_PRNG_pin_S">Nuovo valore del seme per il generatore.</string>
    <string name="elem_PRNG_pin_se">Se impostato, il generatore è reinizializzato con il nuovo seme al prossimo fronte di salita del clock.</string>
    <string name="elem_PRNG_pin_ne">Se impostato, un nuovo numero casuale è impostato nell'uscita al prossimo fronte di salita del clock.</string>
    <string name="elem_PRNG_pin_C">L'ingresso del clock.</string>
    <string name="elem_PRNG_pin_R">Uscita del numero pseudo-casuale.</string>
    <string name="elem_DiodeForward">Diodo a VDD</string>
    <string name="elem_DiodeForward_tt">Un semplice diodo unidirezionale, usato per portare un cavo a VDD.
        Viene utilizzato per implementare una OR cablata.
        Quindi è necessario connettere un restistore pull-down all'uscita dei diodi.
        Nella simulazione i diodi si comportano come una porta attiva con una tabella di verità trivalente:
        Se l'ingresso è alto, l'uscita è anche alta. In tutti gli altri casi (ingresso basso o ad alta impedenza) l'uscita è
        in alta impedenza.
        Quindi due diodi anti-paralleli possono tenersi nello stato alto a vicenda, cosa che non è possibile con
        dei diodi reali.
        Questo è un diodo ideale: non c'è caduta di tensione in un diodo a polarizzazione diretta.</string>
    <string name="elem_DiodeForward_pin_in">Se l'ingresso è alto anche l'uscita lo sarà. In tutti gli altri casi l'uscita è in alta impedenza.</string>
    <string name="elem_DiodeForward_pin_out">Se l'ingresso è alto anche l'uscita lo sarà. In tutti gli altri casi l'uscita è in alta impedenza.</string>
    <string name="elem_DiodeBackward">Diodo a Massa</string>
    <string name="elem_DiodeBackward_tt">Un semplice diodo unidirezionale, usato per portare un cavo a massa.
        Viene utilizzato per implementare una AND cablata.
        Quindi è necessario connettere un restistore pull-up all'uscita dei diodi.
        Nella simulazione i diodi si comportano come una porta attiva con una tabella di verità trivalente:
        Se l'ingresso è basso, l'uscita è anche bassa. In tutti gli altri casi (ingresso alto o ad alta impedenza) l'uscita è
        in alta impedenza.
        Quindi due diodi anti-paralleli possono tenersi nello stato alto a vicenda, cosa che non è possibile con
        dei diodi reali.
        Questo è un diodo ideale: non c'è caduta di tensione in un diodo a polarizzazione diretta.</string>
    <string name="elem_DiodeBackward_pin_in">Se l'ingresso è basso l'uscita lo è anche. In tutti gli altri casi l'uscita è in alta impedenza.</string>
    <string name="elem_DiodeBackward_pin_out">Se l'ingresso è basso l'uscita lo è anche. In tutti gli altri casi l'uscita è in alta impedenza.</string>
    <string name="elem_Switch">Interruttore</string>
    <string name="elem_Switch_pin">Una delle connessioni all'interruttore.</string>
    <string name="elem_Switch_tt">Un semplice interruttore. Non c'è nessun ritardo di porta. Un cambiamento di segnale è propagato immediatamente.</string>
    <string name="elem_SwitchDT">Interruttore a Doppio Contatto</string>
    <string name="elem_SwitchDT_tt">Un semplice interruttore. Non c'è nessun ritardo di porta. Un cambiamento di segnale è propagato immediatamente.</string>
    <string name="elem_Fuse">Fusibile</string>
    <string name="elem_Fuse_tt">Un fusibile è usato per costruire una memoria programmabile una sola volta.</string>
    <string name="elem_Fuse_pin_out1">Una delle connessioni del fusibile.</string>
    <string name="elem_Fuse_pin_out2">Una delle connessioni del fusibile.</string>
    <string name="elem_Relay_tt">Un relay è un interruttore che può essere controllato da una bobina.
        Se una corrente scorre nella bobina, l'interruttore è chiuso o aperto.
        Non c'è nessun diodo di protezione quindi la direzione della corrente non importa.
        L'interruttore è attuato se gli ingressi hanno valori differenti.
        Il relay si comporta in maniera simile ad una porta XOR.</string>
    <string name="elem_Relay_pin_in1">Uno degli ingressi per controllare il relay.</string>
    <string name="elem_Relay_pin_in2">Uno degli ingressi per controllare il relay.</string>
    <string name="elem_RelayDT">Relay a Doppio Contatto</string>
    <string name="elem_RelayDT_tt">Un relay è un interruttore che può essere controllato da una bobina.
        Se una corrente scorre nella bobina, l'interruttore è chiuso o aperto.
        Non c'è nessun diodo di protezione quindi la direzione della corrente non importa.
        L'interruttore è attuato se gli ingressi hanno valori differenti.
        Il relay si comporta in maniera simile ad una porta XOR.</string>
    <string name="elem_RelayDT_pin_in1">Uno degli ingressi per controllare il relay.</string>
    <string name="elem_RelayDT_pin_in2">Uno degli ingressi per controllare il relay.</string>
    <string name="elem_PFET">FET a Canale P</string>
    <string name="elem_PFET_tt">Transistore ad effetto di campo a canale P.
        Il bulk è connesso alla corsia di tensione positiva ed il transistore è simulato senza un diodo di body.</string>
    <string name="elem_NFET">FET a Canale N</string>
    <string name="elem_NFET_tt">Transistore ad effetto di campo a canale N.
        Il bulk è connesso alla massa ed il transistore è simulato senza un diodo di body.</string>
    <string name="elem_FGPFET">FET a Canale P con Floating Gate</string>
    <string name="elem_FGPFET_tt">Transistore ad effetto di campo a canale P con floating gate.
        Il bulk è connesso alla massa ed il transistore è simulato senza un diodo di body.</string>
    <string name="elem_FGNFET">FET a Canale N con Floating Gate</string>
    <string name="elem_FGNFET_tt">Transistore ad effetto di campo a canale P con floating gate.
        Il bulk è connesso alla massa ed il transistore è simulato senza un diodo di body.
        Se c'è una carica immagazzinata nella floating gate, il FET non conduce anche se il gate è impostato ad alto.</string>
    <string name="elem_TransGate_tt">Una vera transmission gate è costruita da due soli transistor. Quindi, è spesso usato per risparmiare
        transistor durante l'implementazione su silicio.</string>
    <string name="elem_TransGate_pin_A">ingresso A</string>
    <string name="elem_TransGate_pin_B">ingresso B</string>
    <string name="elem_TransGate_pin_S">ingresso di controllo.</string>
    <string name="elem_TransGate_pin_~S">ingresso di controllo invertito</string>
    <string name="elem_Testcase_tt">Descrive un test case.
        In un test case puoi descrivere come un circuito dovrebbe comportarsi. Si può quindi controllare automaticamente
        che il comportamento corrisponda alla descrizione forniita. Se c'è una discrepanza, un messaggio di errore
        viene mostrato.</string>
    <string name="elem_GenericInitCode">Inizializzazione Generica</string>
    <string name="elem_GenericInitCode_tt">Codice che è eseguito per avviare un circuito generico direttamente.
        Se un circuito generico è avviato direttamente, questo componente deve essere presente.</string>
    <string name="elem_GenericCode">Codice</string>
    <string name="elem_GenericCode_tt">Codice che può essere eseguito quando un circuito generico viene reso concreto.
        Può essere usato, per esempio, per aggiungere componenti o cavi ad un circuito.</string>
    <string name="elem_AsyncSeq">Temporizzazione Asincrona</string>
    <string name="elem_AsyncSeq_tt">Consente la configurazione della temporizzazioen di un circuito sequenziale asincrono come per esempio una
        pipeline Muller. Il circuito deve essere avviato in modalità di porta a passo singolo e deve essere in grado di
        raggiungere uno stato stabile durante l'avvio. Il circuito sequenziale può quindi essere avviato interattivamente
        o con una porta di reset.
        Non viene consentito l'utilizzo di un clock in questa modalità.</string>
    <string name="elem_PowerSupply">Alimentazione</string>
    <string name="elem_PowerSupply_tt">Non ha alcuna funzionalità. Si assicura che alimentazione e massa siano connessi.
        Può essere usato nei circuiti 74xx per generare i pin per l'alimentazione, che sono testati per una corretta
        cablatura.</string>
    <string name="elem_PowerSupply_pin_VDD">Deve essere connesso all'alimentazione!</string>
    <string name="elem_PowerSupply_pin_GND">Deve essere connesso alla massa!</string>
    <string name="elem_Reset_pin_Reset">Uscita di Reset.</string>
    <string name="elem_Reset_tt">L'uscita di questo componente è mantenuta alta durante l'inizializzazione del circuito.
        Dopo che il circuito si è stabilizzato, l'uscita diventa bassa.
        Se l'uscita viene invertita si comporta nel modo opposto.</string>
    <string name="elem_Break">Interruzione</string>
    <string name="elem_Break_pin_brk">Ferma la simulazione veloce se un fronte di salita viene individuato.</string>
    <string name="elem_Break_tt">Se questo componente è usato nel circuito, il bottone "Avvia fino all'interruzione" tra "Avvia" ed "Interrompi"
        è abilitato. Il bottone fa funzionare il circuito fino a quando un fronte di salita nel componente viene
        rilevato. Questo elemento può essere usato per effettuare il debugging del circuito in qualsiasi punto di 
        interruzione (breakpoint). In questo modo una istruzione in assembly BRK può essere implementata. Questo
        consente l'esecuzione di un programma fino al raggiungimento di questo comando. Questa funzione può essere
        utilizzata soltanto se il clock a tempo reale è disattivato.</string>
    <string name="elem_Stop">Fermata</string>
    <string name="elem_Stop_tt">Un fronte di salita in questo componente ferma la simulazione.
        Ha lo stesso effetto del bottone "Stop" nella barra degli strumenti.</string>
    <string name="elem_Stop_pin_stop">Un fronte di salita ferma la simulazione.</string>
    <string name="elem_External">Esterno</string>
    <string name="elem_External_tt">Un componente che esegue un processo esterno per il calcolo della funzione logica.
        Può essere usato per specificare il comportamento di un componente da VHDl o Verilog.
        L'attuale comportamento della simulazione deve essere fatto da un simulatore esterno.
        Al momento soltanto il simulatore VHDL "ghdl" ed il simulatore Verilog "Icarus Verilog" sono supportati.
        L'etichetta del componente deve essere corrispondente al nome dell'entità o modulo!</string>
    <string name="elem_ExternalFile">File Esterno</string>
    <string name="elem_ExternalFile_tt">Un componente che esegue un processo esterno per il calcolo della funzione logica.
        Può essere usato per specificare il comportamento di un componente da VHDl o Verilog.
        L'attuale comportamento della simulazione deve essere fatto da un simulatore esterno.
        Al momento soltanto il simulatore VHDL "ghdl" ed il simulatore Verilog "Icarus Verilog" sono supportati.
        L'etichetta del componente deve essere corrispondente al nome dell'entità o modulo!</string>
    <string name="elem_Diode">Diodo</string>
    <string name="elem_Diode_tt">Diodo bidirezionale semplificato. Viene usato per implementare una AND o OR cablata.
        Questo è un diodo ideale: non c'è caduta di tensione in un diodo a polarizzazione diretta.</string>
    <string name="error">Errore</string>
    <string name="err_N_isNotInputOrOutput">Pin {0} nel componente {1} non è un ingresso o uscita.</string>
    <string name="err_aSingleClockNecessary">Un singolo clock è necessario. Tutti i flip-flop devono usare questo segnale.</string>
    <string name="err_analyseNoInputs">Il circuito non ha alcun ingresso etichettato.</string>
    <string name="err_analyseNoOutputs">Il circuito non ha alcuna uscita etichettata.</string>
    <string name="err_breakTimeOut">Nessuna interruzione rilevata dopo {0} cicli nel breakpoint "{1}". Probabilmetne il numero di cicli
        di timeout nel componente di interruzione deve essere incrementato.</string>
    <string name="err_builder_exprNotSupported">L''espressione {0} non è supportata.</string>
    <string name="err_builder_operationNotSupported">L''operazione {0} non è supportata.</string>
    <string name="err_builder_couldNotFillLUT">Errore nella creazione della tabella di lookup.</string>
    <string name="err_burnError">Più di una uscita è attiva sul cavo, causando un corto circuito.</string>
    <string name="err_pullUpAndDown">Non è consentito connettere un resistore pull-up ed uno pull-down alla stessa rete.</string>
    <string name="err_cannotAnalyse_N">Impossibile analizzare il nodo {0}</string>
    <string name="err_containsVarAndNotVar">Contiene [var] e [not var]</string>
    <string name="err_duplicatePinLabel">Il pin "{0}" nel componente "{1}" esiste due volte.</string>
    <string name="err_element_N_notFound">Il componente {0} non è stato trovato</string>
    <string name="err_exact_N0_valuesNecessaryNot_N1">Esattamente {0} valori sono necessari, non {1}</string>
    <string name="err_ffNeedsToBeConnectedToClock">Il flip-flop deve essere connesso al clock.</string>
    <string name="err_invalidFileFormat">Formato del file invalido</string>
    <string name="err_isAlreadyInitialized">La logica è già stata inizializzata</string>
    <string name="err_labelNotConnectedToNet_N">Un tunnel {0} non è connesso.</string>
    <string name="err_moreThanOneClockFound">C'è più di un clock.</string>
    <string name="err_clockIsNotUsed">Il componente clock non è stato usato!</string>
    <string name="err_needs_N0_bits_found_N2_bits">Ci sono {0} bit richiesti, ma {1} sono stati trovati</string>
    <string name="err_netOfPin_N_notFound">La rete del pin {0} non è stata trovata</string>
    <string name="err_noClockFound">Nessun clock trovato nella logica del circuito</string>
    <string name="err_noInputsAvailable">Nessun ingresso disponibile per l'impostazione</string>
    <string name="err_noShapeFoundFor_N">Nessuna figura trovata per il componente {0}</string>
    <string name="err_noValueSetFor_N0_atElement_N1">Non c''è niente connesso all''ingresso "{0}" nel componente "{1}". Ingressi aperti non sono consentiti.</string>
    <string name="err_notAllOutputsSameBits">Non tutte le uscite connesse hanno lo stesso numero di bit</string>
    <string name="err_notAllOutputsSupportHighZ">Se uscite multiple sono connesse insieme, tutte devono essere uscite a tre stati.</string>
    <string name="err_noOutConnectedToWire">Nessuna uscita connessa al cavo ({0}). Lo stato del cavo è indefinito.</string>
    <string name="err_oneResultIsRequired">Tabella troppo piccola: un risultato è richiesto!</string>
    <string name="err_output_N_notDefined">Uscita {0} non definita</string>
    <string name="err_pinMap_NoNameForPin_N">Nessuna etichetta per il pin {0}</string>
    <string name="err_pinMap_Pin_N_AssignedTwicePin">Pin {0} assegnato due volte!</string>
    <string name="err_pinMap_pin_N0_isNotAnInput">Pin {0} non è un ingresso!</string>
    <string name="err_pinMap_pin_N0_isNotAnOutput">Pin {0} non è un''uscita!</string>
    <string name="err_pinMap_noEqualsfound">Nessun = trovato!</string>
    <string name="err_pinMap_toMannyInputsDefined">Troppi ingressi utilizzati!</string>
    <string name="err_pinMap_toMannyOutputsDefined">Troppe uscite utilizzate!</string>
    <string name="err_pinNotPresent">Pin non presente</string>
    <string name="err_pinWithoutName">Trovato un pin senza un'etichetta.</string>
    <string name="err_clockWithoutName">Trovato un clock senza etichetta. Se il clock è incorporato, allora anch'esso ha bisogno di un'etichetta.</string>
    <string name="err_pin_N0_atElement_N1_notFound">Pin {0} non trovato nel componente {1}</string>
    <string name="err_pin_N_notFound">Pin {0} non trovato</string>
    <string name="err_customShapeHasNoPin_N">La figura personalizzata non definisce un pin {0}</string>
    <string name="err_pin_N_unknown">Pin {0} sconosciuto</string>
    <string name="err_seemsToOscillate">La logica sembra oscillare. Per analizzarla puoi avviare il circuito in modalità di porta a passo singolo.</string>
    <string name="err_portIsInUse">La porta remota è in uso! C'è un'altra istanza in esecuzione?</string>
    <string name="err_selectorInputCountMismatch">Il numero di ingressi non corrisponde al numero di bit del selettore</string>
    <string name="err_spitterDefSyntaxError">Errore di sintassi nella definizione dello splitter {0}</string>
    <string name="err_splitterBitsMismatch">Numero di bit dello splitter non corrispondente</string>
    <string name="err_splitterNotAllBitsDefined">Non tutti gli ingressi sono stati definiti!</string>
    <string name="err_splitterNotUnambiguously">I bit di ingresso sono stati definiti più volte!</string>
    <string name="err_spitterToManyBits">Solo 64 bit sono consentiti nello splitter!</string>
    <string name="err_tableBecomesToSmall">Due ingressi sono richiesti!</string>
    <string name="err_toManyInputs_max_N0_is_N1">Troppe variabili (ingressi + flip-flop), {0} sono consentite ma {1} sono state trovate.</string>
    <string name="err_toManyInputsIn_N0_max_N1_is_N2">Troppe variabili utilizzate in {0}, {1} sono consentite ma {2} sono state trovate.</string>
    <string name="err_varNotAllowedInCUPL_N">La variabile {0} non è consentita nel sorgente CUPL!</string>
    <string name="err_varNotDefined_N">La variabile {0} non è definita</string>
    <string name="err_parserUnexpectedToken_N">Carattere inaspettato {0}</string>
    <string name="err_parserMissingClosedParenthesis">Parentesi chiusa mancante</string>
    <string name="err_notANumber_N0_inLine_N1">Il valore {0} nella riga {1} non è un numero!</string>
    <string name="err_testDataExpected_N0_found_N1_numbersInLine_N2">Ci si aspettava {0} ma sono stati trovati {1} valori nella riga {2}!</string>
    <string name="err_unexpectedToken_N0_inLine_N1">Carattere inaspettato ({0}) nella riga {1}.</string>
    <string name="err_variable_N0_notFound">Variabile {0} non trovata!</string>
    <string name="err_noTestInputSignalsDefined">Nessun segnale di ingresso è stato definito nel test vector!</string>
    <string name="err_noTestOutputSignalsDefined">Nessun segnale di uscita è stato definito nel test vector!</string>
    <string name="err_noTestData">Nessun dato di test trovato.</string>
    <string name="err_pullUpAndDownNotAllowed">Non è consentito connettere un resistore pull-up e pull-down ad un singolo cavo.</string>
    <string name="err_openingDocumentation">Impossibile aprire il browser.</string>
    <string name="err_couldNotCreateFolder_N0">Impossibile creare la cartella "{0}"!</string>
    <string name="err_switchHasNoNet">Non è consentito connettere soltanto ingressi ad uno switch.</string>
    <string name="err_file_N0_ExistsTwiceBelow_N1">Il file {0} esiste più volte sotto {1}.</string>
    <string name="err_couldNotFindIncludedFile_N0">Impossibile trovare il file {0}.</string>
    <string name="err_postProcessErrorIn_N0">Errore durante l''esecuzione di "{0}".</string>
    <string name="err_processDoesNotTerminate_N">Il processo "{0}" non termina!</string>
    <string name="err_processExitedWithError_N1_N2">Il rpocesso restituisce un valore diverso dallo zero {0}: {1}</string>
    <string name="err_errorRunningFitter">Errore nell'avvio del fitter esterno!</string>
    <string name="err_noExpressionsAvailable">Non c'è alcuna equazione minimizzata.</string>
    <string name="msg_optimizationInProgress">Le equazioni stanno venendo calcolate. Per favore, attendi un momento!</string>
    <string name="err_varName_N_UsedTwice">La variabile {0} è usata due volte!</string>
    <string name="err_fileNeedsToBeSaved">Il file deve essere salvato!</string>
    <string name="err_recursiveNestingAt_N0">Il circuito {0} importa sé stesso!</string>
    <string name="err_minimizationFailed">Il risultato della minimizzazione non è corretto! I nomi delle variabili potrebbero non essere unici.</string>
    <string name="err_toManyIterations">Troppe iterazioni in un ciclo.</string>
    <string name="err_diodeNeedsPullUpResistorAtOutput">Il diodo ha bisogno di un resistore pull-up nell'uscita!</string>
    <string name="err_diodeNeedsPullDownResistorAtOutput">Il diodo ha bisogno di un resistore pull-down nell'uscita!</string>
    <string name="err_testSignal_N_notFound">Il segnale di test {0} non è stato trovato nel circuito!</string>
    <string name="err_toManyBits_Found_N0_maxIs_N1">Soltanto {1} bit sono consentiti, ma {0} sono stati trovati!</string>
    <string name="err_MultiBitFlipFlopFound">I flip-flop con più di un bit non sono consentiti!</string>
    <string name="err_invalidTransmissionGateState">I due ingressi di controllo di una porta di trasmissione devono essere invertiti!</string>
    <string name="err_nameUsedTwice_N">Il segnale {0} è usato due volte!</string>
    <string name="err_errorParsingTestdata">Errore nell'interpretazione dei dati di test.</string>
    <string name="err_backtrackOf_N_isImpossible">Il modello del componente {0} non può essere analizzato.</string>
    <string name="err_errorInPowerSupply">Errore nel cablaggio dell''alimentazione in {0}.</string>
    <string name="err_pinIsNotANumber_N">Il pin numero {0} non è un intero!</string>
    <string name="err_vhdlExporting">Errore durante l'esportazione in VHDL.</string>
    <string name="err_vhdlNoEntity_N">Nessun codice VHDL disponibile per {0}!</string>
    <string name="err_verilogNoElement_N">Nessun codice Verilog disponibile per {0}!</string>
    <string name="err_vhdlErrorWritingTestBench">Errore nella creazione di un test bench!</string>
    <string name="err_vhdlValuesOfType_N_notAllowed">I valori di tipo {0} non sono consentiti!</string>
    <string name="err_vhdlANameIsMissing">Un nome manca. Tutte le etichette dei pin sono state impostate, per esempio?</string>
    <string name="err_hdlMultipleOutputsConnectedToNet_N_N_N">Più uscite sono connesse tra di loro. Questo tipo di interconnessione non è supportata per una
        esportazione in HDL. ({0}, {1}, {2}).</string>
    <string name="err_hdlTestCaseHasGenericCode">I test case con una parametrizzazione generica non sono supportati per una esportazione HDL.</string>
    <string name="err_unnamedNet">rete senza nome</string>
    <string name="err_toManyVars">Troppe variabili!</string>
    <string name="err_invalidExpression">Espressione invalida!</string>
    <string name="err_function_N0_notFoundInLine_N1">Funzione {0} non trovata nella linea {1}!</string>
    <string name="err_wrongNumOfArgsIn_N0_InLine_N1_found_N2_expected_N3">Il numero di argomenti nella funzione {0} nella riga {1} non è corretto ({2} trovati, {3} previsti)!</string>
    <string name="err_invalidValue_N0_inFunction_N1">Valore {0} invalido nella funzione {1}!</string>
    <string name="err_Node_N_isAComponent">Il nome {0} non è una componente di un percorso.</string>
    <string name="err_loadingLibrary">Errore durante il caricamento di una libreria.</string>
    <string name="err_noManifestFound">Il file JAR non contiene un manifest!</string>
    <string name="err_noMainFoundInManifest">Il manifest non contiene il campo Main-Class!</string>
    <string name="err_mainClass_N_NotFound">Impossibile trovare la classe {0}!</string>
    <string name="err_couldNotInitializeMainClass_N">Impossibile creare un''istanza della classe {0}!</string>
    <string name="err_notMoreOutBitsThanInBits">Ci devono essere più bit di ingresso che uscita!</string>
    <string name="err_constantsNotAllowed">Non è possibile impostare pin fisici a valori costanti!</string>
    <string name="err_invalidNumberFormat_N_N">La stringa {0} non è un numero valido (posizione {1})!</string>
    <string name="err_invalidPinName_N">Il nome "{0}" non è consentito!</string>
    <string name="err_whiteSpaceNotAllowedInTT2Name">Nessuno spazio bianco consentito nel nome di un file TT2!</string>
    <string name="err_tableHasToManyResultColumns">La tabella ha troppe colonne!</string>
    <string name="err_errorExportingZip">Errore durante la scrittura del file ZIP.</string>
    <string name="err_moreThanOneFastClock">Soltanto un componente di clock ad alta frequenza è consentito.</string>
    <string name="err_circuitHasCycles">Il circuito contiene cicli. Non è possibile analizzare tale circuito. I cicli sorgono quando un'uscita di
        una porta è collegata ad uno degli ingressi della stesssa porta. L'utilizzo di interruttori, FET o relay
        può causare cicli.</string>
    <string name="err_monoflopRequiresOneClock">Se un monoflop è utilizzato, deve esserci esattamente un solo componente di clock!</string>
    <string name="err_couldNotCreateElement_N">Impossibile creare un componente di tipo {0}!</string>
    <string name="err_centralDefinedRomsAreNotSupported">Le ROM definite nelle impostazioni non sono supportate!</string>
    <string name="err_namesAreNotUnique_N">Il nome "{0}" non è unico!</string>
    <string name="err_errorWritingDataToProcess">Impossibile scrivere i valori al processo esterno!</string>
    <string name="err_errorReadingDataFromProcess">Impossibile leggere i valori dal processo esterno!</string>
    <string name="err_errorCreatingProcess">Impossibile creare il processo esterno!</string>
    <string name="err_timeoutReadingData_O">Tempo scaduto durante la lettura dei dati dal processo esterno!
        {0}</string>
    <string name="err_notEnoughDataReceived_O">Non abbastanza dati ricevuti!
        {0}</string>
    <string name="err_invalidCharacterReceived_N_O">I dati testuali ricevuti contengono un carattere invalido: {0}!
        {1}</string>
    <string name="err_processTerminatedUnexpected_O">Il processo ha terminato inaspettatamente!
        {0}</string>
    <string name="err_couldNotTerminateProcess">Impossibile terminare il processo!</string>
    <string name="err_couldNotStartProcess_N">Impossibile lanciare il processo: {0}</string>
    <string name="err_exitValueNotNull_N_O">Il valore di uscita dell''applicazione non è zero ma {0}:
        {1}</string>
    <string name="err_canOnlyExportExternalVHDL">Il codice esterno è supportato soltanto se è VHDL!</string>
    <string name="err_canOnlyExportExternalVerilog">Il codice esterno è supportato soltanto se è Verilog!</string>
    <string name="err_ifExternalComponentIsUsedTwiceCodeMustBeIdentical_N">Se un componente esterno è usato più volte, il codice deve essere identico! Effetti: {0}</string>
    <string name="err_writingToStdOut_O">Impossibile scrivere sullo standard output:
        {0}</string>
    <string name="err_ghdlNotInstalled">Il simulatore di VHDL "ghdl" non sembra essere installato. Installa ghdl (http://ghdl.free.fr/) e riprova.
        Se ci sono ancora problemi, controlla che il percorso in cui si trova l'eseguibile di ghdl sia nelle impostazioni
        di Digital.</string>
    <string name="err_iverilogNotInstalled">Il simulatore di Verilog "Icarus" non sembra essere installato. Installa IVerilog (http://iverilog.icarus.com/)
        e riprova. Se ci sono ancora problemi, controlla che il percorso in cui si trova l'eseguibile di IVerilog sia nelle 
        impostazioni di Digital.</string>
    <string name="err_errorLoadingHDLFile_N">Errore nel caricare il file HDL {0}</string>
    <string name="err_emptyLabelIsNotAllowed">Un'etichetta vuota non è consentita!</string>
    <string name="err_errorAnalysingCircuit_N">Errore nell''analisi del circuito: {0}</string>
    <string name="err_romNeedsALabelToBeExported">Ogni ROM ha bisogno di un'etichetta unica per essere esportata!</string>
    <string name="err_lutNeedsALabelToBeExported">Ogni LUT ha bisogno di un'etichetta unica per essere esportata!</string>
    <string name="err_counterNeedsMoreBits">Il contatore ha bisogno di almeno due bit.</string>
    <string name="err_clocksNotAllowedInAsyncMode">Gli elementi con clock non possono essere usati in modalità asincrona.</string>
    <string name="err_verilogExporting">Errore durante l'esportazione a Verilog.</string>
    <string name="err_noMemoryFound">Nessuna memoria "{0}" trovata nel modello!</string>
    <string name="err_multipleMemoriesFound">Più memorie "{0}" trovate nel modello!</string>
    <string name="err_errorLoadingRomData">Errore durante il caricamento dei dati in ROM.</string>
    <string name="err_parsingSVG">Errore durante l'interpretazione del file SVG.</string>
    <string name="err_morePinsDefinedInSVGAsNeeded">Il file SVG contiene dei pin che non esistono nel circuito.</string>
    <string name="err_allMemoriesNeedToHaveTheSameByteWidth">Tutte le memorie dove i dati saranno memorizzati hanno bisogno di un numero di bit uguale.</string>
    <string name="err_ProgMemLabelsNotDifferent">Se i programmi devono essere caricati in più RAM, tutte le RAM devono avere nomi differenti. L'ordine
        lessicografico determina l'ordine delle RAM.</string>
    <string name="err_midiSystemNotAvailable">Il sistema MIDI non è disponibile.</string>
    <string name="err_midiChannel_N_NotAvailable">Il canale MIDI {0} non è disponibile.</string>
    <string name="err_midiInstrument_N_NotAvailable">Lo strumento MIDI {0} non è disponibile.</string>
    <string name="err_midiInstrumentsNotAvailable">Gli strumenti MIDI non sono disponibili.</string>
    <string name="err_whileExecutingTests_N0">Durante l''esecuzione dei test "{0}" si è verificato un errore!</string>
    <string name="err_hdlNotKnown_N">HDL non noto: {0}</string>
    <string name="msg_errorStartCommand_N">Errore nel lancio del comando {0}</string>
    <string name="err_thereIsAUnnamedIO">C'è un ingresso o uscita senza nome!</string>
    <string name="err_NameOfIOIsInvalidOrNotUnique_N">Il nome del segnale "{0}" è invalido o usato più volte!</string>
    <string name="err_substitutingError">Errore durante la sostituzione dei componenti per l'analisi.</string>
    <string name="err_evaluatingGenericsCode_N_N">Errore nella valutazione del codice generico del circuito. Il codice
        {1}
        nel componente: {0}</string>
    <string name="msg_errParsingGenerics">Errore durante l'interpretazione del codice generico-</string>
    <string name="err_noGenericInitCode">Nessuna inizializzazione del codice per i componenti generici è stata trovata.
        Un rispettivo componente deve essere aggiunto al circuito per farlo partire.</string>
    <string name="err_multipleGenericInitCodes">Più codici di inizializzazione per i componenti generici.</string>
    <string name="err_inGenericInitCode">Errore durante l'analisi del codice generico di inizializzazione.</string>
    <string name="err_writeInCodeComponentsOnly">Le variabili globali possono essere dichiarate soltanto nel codice dei componenti.</string>
    <string name="err_vgaModeNotDetected_N">La modalità video non è stata rilevata ({0})</string>
    <string name="err_ROM_noFileGivenToLoad">Non c'è nessun nome file specificato per il ricaricamento automatico!</string>
    <string name="err_virtualSignal_N_DeclaredTwiceInLine_N">Il segnale virtuale {0} è stato dichiarato due volte nella linea {1}!</string>
    <string name="err_csvNoHeaderFound">Nessuna intestazione trovata!</string>
    <string name="err_csvNoOutputValuesFound">Nessun valore di uscita trovato!</string>
    <string name="err_csvNotEnoughValues">Non ci sono abbastanza valori per una linea!</string>
    <string name="err_csvToManyValues">Troppi valori per una linea!</string>
    <string name="err_errorWritingFile_N">Errore durante la scrittura del file {0}.</string>
    <string name="err_circuitContainsNoComponents">Il circuito non contiene componenti!</string>
    <string name="err_couldNotCreateServer">Impossibile avviare il server!</string>
    <string name="key_AddrBits">Bit di Indirizzo</string>
    <string name="key_AddrBits_tt">Numero dei bit di indirizzo utilizzati.</string>
    <string name="key_Bits">Bit di Dati</string>
    <string name="key_Color">Colore</string>
    <string name="key_Color_tt">Il colore dell'elemento.</string>
    <string name="key_backgroundColor">Colore di Sfondo</string>
    <string name="key_backgroundColor_tt">Il colore di sfondo del circuito quando viene incorporato dentro un altro circuito. Non è utilizzato per
        package DIL.</string>
    <string name="key_Cycles">Cicli di Timeout</string>
    <string name="key_Cycles_tt">Se questo numero di cicli di timeout è raggiunto senza un segnale di interruzione, un errore viene generato.</string>
    <string name="key_Data">Dati</string>
    <string name="key_Data_tt">I valori memorizzati in questo elemento.</string>
    <string name="key_Default">Predefinito</string>
    <string name="key_Default_tt">Questo valore è impostato quando il circuito viene avviato.
        Nel demultiplexer, questo valore è impostato per uscite non selezionate.</string>
    <string name="key_InDefault">Predefinito</string>
    <string name="key_InDefault_tt">Questo valore è impostato se il circuito è avviato. Una "Z" significa uno stato di alta impedenza.</string>
    <string name="key_isHighZ">Ingresso a tre stati</string>
    <string name="key_isHighZ_tt">Se impostato, all'ingresso viene consentito di essere in alta impedenza. Questo viene consentito anche all'ingresso
        del componente se l'alta impedenza ("Z") è impostata come valore predefinito.</string>
    <string name="key_avoidActiveLow">Nessuna uscita bassa.</string>
    <string name="key_avoidActiveLow_tt">Evita un'uscita bassa. Questo è specialmente utile quando si impostano circuiti di relay.
        Può essere attivato soltanto se una uscita ad alta impedenza è consentita.</string>
    <string name="key_Description">Descrizione</string>
    <string name="key_Description_tt">Una breve descrizione di questo elemento e del suo utilizzo.</string>
    <string name="key_Frequency">Frequenza/Hz</string>
    <string name="key_Frequency_tt">La frequenza in tempo reale utilizzata per questo clock.</string>
    <string name="key_IEEEShapes">Utilizza forme IEEE 91-1984</string>
    <string name="key_IEEEShapes_tt">Utilizza forme IEEE 91-1984 anziché forme rettangolari</string>
    <string name="key_Inputs">Numero di ingressi</string>
    <string name="key_Inputs_tt">Numero di ingressi utilizzati. Ogni ingresso deve essere connesso.</string>
    <string name="key_Label">Etichetta</string>
    <string name="key_Label_tt">Il nome di questo elemento.</string>
    <string name="key_Size">Dimensione</string>
    <string name="key_Size_tt">La dimensione della figura del circuito.</string>
    <string name="key_small">Piccola Figura</string>
    <string name="key_small_tt">Se selezionato, una figura più piccola sarà utilizzata.</string>
    <string name="key_Language">Lingua</string>
    <string name="key_Language_tt">La lingua dell'interfaccia. Cambierà soltanto dopo un riavvio.</string>
    <string name="key_NetName">Nome di rete</string>
    <string name="key_NetName_tt">Tutte le reti hanno un nome identico se connesse insieme.</string>
    <string name="key_InputSplitting">Splitting dell'ingresso</string>
    <string name="key_InputSplitting_tt">Se per esempio quattro bit, due bit e due altri bit sono usati per l'ingresso, questo può essere configurato
        come "4,2,2". Il numero indica il numero di bit. Per convenienza, l'asterisco può essere usato con "[Bit]*[Numero]"
        come "1*16". Si può anche specificare i bit da utilizzare direttamente in qualsiasi ordine. Per esempio "4-7,0-3"
        configura i bit 4-7 e 0-3. Questa notazione consente qualsiasi configurazione di bit.
        I bit di ingresso devono essere specificati completamente e senza ambiguità.</string>
    <string name="key_OutputSplitting_tt">Se per esempio quattro bit, due bit e due altri bit sono usati per l'ingresso, questo può essere configurato
        come "4,2,2". Il numero indica il numero di bit. Per convenienza, l'asterisco può essere usato con "[Bit]*[Numero]"
        come "1*16". Si può anche specificare i bit da utilizzare direttamente in qualsiasi ordine. Per esempio "4-7,0-3"
        configura i bit 4-7 e 0-3. Questa notazione consente qualsiasi configurazione di bit.
        I bit di ingresso devono essere specificati completamente e senza ambiguità.</string>
    <string name="key_SelectorBits">Numero dei bit di Selezione</string>
    <string name="key_SelectorBits_tt">Numero dei bit utilizzati per l'input di selezione.</string>
    <string name="key_Signed">Operazione con Segno</string>
    <string name="key_Signed_tt">Se selezionato l'operazione è effettuata con il segno (complemento a due).</string>
    <string name="key_remainderPositive">Resto sempre positivo</string>
    <string name="key_remainderPositive_tt">Se impostato, il resto di una operazione con segno sarà sempre positivo.</string>
    <string name="key_Closed">Chiuso</string>
    <string name="key_Closed_tt">Imposta lo stato iniziale dell'interruttore.</string>
    <string name="key_Value">Valore</string>
    <string name="key_Value_tt">Il valore della costante.</string>
    <string name="key_Width">Larghezza</string>
    <string name="key_Width_tt">Larghezza del simbolo se questo circuito è utilizzato come un componente in un altro circuito.</string>
    <string name="key_Height">Altezza</string>
    <string name="key_Height_tt">Altezza del simbolo se questo circuito è utilizzato come un componente in un altro circuito.</string>
    <string name="key_autoReload">Ricarica all'avvio del modello</string>
    <string name="key_autoReload_tt">Ricarica il file esadecimale ogni volta che il modello viene avviato.</string>
    <string name="key_lastDataFile_tt">Il file da caricare nella ROM.</string>
    <string name="key_flipSelPos">Inverti la posizione del selettore</string>
    <string name="key_flipSelPos_tt">Questa opzione ti consente di spostare il pin di selezione dal lato opposto del plexer.</string>
    <string name="key_intFormat">Formato Numerico</string>
    <string name="key_intFormat_tt">Il formato utilizzato per mostrare i numeri.</string>
    <string name="key_intFormat_bin">Binario</string>
    <string name="key_intFormat_dec">Decimale</string>
    <string name="key_intFormat_decSigned">Decimale con segno</string>
    <string name="key_intFormat_def">Predefinito</string>
    <string name="key_intFormat_hex">Esadecimale</string>
    <string name="key_intFormat_oct">Ottale</string>
    <string name="key_intFormat_fixed">A virgola fissa</string>
    <string name="key_intFormat_fixedSigned">A virgola fissa con segno</string>
    <string name="key_intFormat_floating">A virgola mobile</string>
    <string name="key_fixedPoint">Cifre decimali</string>
    <string name="key_fixedPoint_tt">Il numero delle cifre decimali binarie</string>
    <string name="key_barrelSigned">L'ingresso del registro a scorrimento ha il segno</string>
    <string name="key_barrelSigned_tt">L'ingresso dati del registro a scorrimento ha il formato in complemento a due</string>
    <string name="key_barrelShifterMode">Modalità</string>
    <string name="key_barrelShifterMode_tt">Modalità del registro a scorrimento</string>
    <string name="key_barrelShifterMode_logical">Logica</string>
    <string name="key_barrelShifterMode_rotate">Rotazione</string>
    <string name="key_barrelShifterMode_arithmetic">Aritmetica</string>
    <string name="key_direction">Direzione</string>
    <string name="key_direction_tt">Imposta la direzione.</string>
    <string name="key_direction_left">sinistra</string>
    <string name="key_direction_right">destra</string>
    <string name="key_maxStepCount">Massimo numero dei passaggi da mostrare</string>
    <string name="key_maxStepCount_tt">Il massimo numero dei valori memorizzati. Quando il massimo viene raggiunto il valore più vecchio è scartato.</string>
    <string name="key_microStep">Mostra i passaggi singoli.</string>
    <string name="key_microStep_tt">Mostra tutti i passaggi singoli nel grafico.</string>
    <string name="key_rotation">Rotazione</string>
    <string name="key_rotation_tt">L'orientazione dell'elemento nel circuito.</string>
    <string name="key_mirror">Specchio</string>
    <string name="key_mirror_tt">Specchia il componente nel circuito.</string>
    <string name="key_runRealTime">Avvia il clock a tempo reale</string>
    <string name="key_runRealTime_tt">Se abilitato, il clock a tempo reale è avviato quando il circuito è avviato</string>
    <string name="key_showDataGraph">Mostra il grafico delle misurazioni durante l'avvio della simulazione.</string>
    <string name="key_showDataGraph_tt">Quando la simulazione si avvia, un grafico con i valori misurati viene mostrato.</string>
    <string name="key_showDataGraphMicro">Mostra il grafico della misurazione in modalità a passo singolo all'avvio della simulazione</string>
    <string name="key_showDataGraphMicro_tt">Quando la simulazione si avvia, il grafico con i valori misurati nella modalità a passo
        singolo viene mostrato. Tutti i cambiamenti delle porte sono inclusi nel grafico.</string>
    <string name="key_addValueToGraph">Mostra nel Grafico Misurazioni</string>
    <string name="key_addValueToGraph_tt">Mostra il valore nel grafico delle misurazioni.</string>
    <string name="key_showDataTable">Mostra i valori di misurazione all'avvio della simulazione.</string>
    <string name="key_showDataTable_tt">Quando la simulazione si avvia, una tabella con i valori misurati è mostrata.</string>
    <string name="key_termHeight">Linee</string>
    <string name="key_termHeight_tt">Il numero di linee da mostrare.</string>
    <string name="key_termWidth">Caratteri per Linea</string>
    <string name="key_termWidth_tt">Il numero di caratteri mostrato per una singola linea.</string>
    <string name="key_valueIsProbe">Usa come valore di misurazione</string>
    <string name="key_valueIsProbe_tt">Se impostato, il valore è una misurazione e appare nel grafico e nella tabella dati.
        In aggiunta, una etichetta deve essere specificata che serve per l'identificazione del valore.</string>
    <string name="key_Testdata">Dati di Test</string>
    <string name="key_Testdata_tt">La descrizione del test case.
        Dettagli della sintassi possono essere trovati nel dialogo di aiuto dell'editor dei dati di test.</string>
    <string name="key_graphicWidth">Larghezza in pixel</string>
    <string name="key_graphicWidth_tt">La larghezza dello schermo in pixel.</string>
    <string name="key_graphicHeight">Altezza in pixel</string>
    <string name="key_graphicHeight_tt">L'altezza dello schermo in pixel.</string>
    <string name="key_isProgramMemory">Memorial del Programma</string>
    <string name="key_isProgramMemory_tt">Rende questa ROM una memoria del programma. In questo modo può essere programmata da un IDE esterno.</string>
    <string name="key_isProgramCounter_tt">Rende questo registro un "program counter". Il valore di questo registro è restituito all'assemblatore
        o IDE esterno per marcare la linea di codice corrente durante il debug.</string>
    <string name="key_Blown">Programmato</string>
    <string name="key_Blown_tt">Se impostato, il diodo è impostato come "esploso" o "programmato". In un FET a floating gate, la floating
        gate è caricata. Puoi cambiare questa impostazione con il tasto [P].</string>
    <string name="key_ExpressionFormat">Formato</string>
    <string name="key_ExpressionFormat_tt">Formato delle espressioni nello schermo.</string>
    <string name="key_relayNormallyClosed">Il relay è normalmente chiuso.</string>
    <string name="key_relayNormallyClosed_tt">Se impostato il relay è chiuso se l'ingresso è basso.</string>
    <string name="key_poles">Numero di poli</string>
    <string name="key_poles_tt">Numero dei poli disponibili.</string>
    <string name="key_commonCathode">Connessione Comune</string>
    <string name="key_commonCathode_tt">Se selezionato, anche un ingresso catodo o anodo comune è simulato.</string>
    <string name="key_commonConnectionType">Comune</string>
    <string name="key_commonConnectionType_tt">Tipologia di connessione comune.</string>
    <string name="key_commonConnectionType_cathode">Catodo</string>
    <string name="key_commonConnectionType_anode">Anodo</string>
    <string name="key_ledPersistence">Evita lo Sfarfallio</string>
    <string name="key_ledPersistence_tt">Non è possibile incrementare la frequenza così tanto da far sparire lo sfarfallio. Per sopprimerlo, un "afterglow"
        può essere impostato come attivo per i LED con questa opzione.
        Se abilitato, i LED rimangono accesi anche se uno dei pin cambia valore verso alta impedenza.
        Questo simula una frequenza al di sopra della soglia di frequenza di fusione dello sfarfallio.</string>
    <string name="key_atf1502Fitter_tt">Percorso al fitter per il ATF15xx.
        Inserisci la cartella che contiene il file fit15xx.exe fornito da Microchip (precedentemente ATMEL).</string>
    <string name="key_pin">Numero del pin</string>
    <string name="key_pin_tt">Un campo vuoto significa che il segnale non è assegnato ad un pin.</string>
    <string name="key_rowDataBits">Righe</string>
    <string name="key_rowDataBits_tt">Specifica il numero di righe tramite la specifica del numero di bit nella parola della riga.</string>
    <string name="key_colAddrBits">Bit di indirizzo delle colonne</string>
    <string name="key_colAddrBits_tt">Indirizza le colonne individualmente. Tre bit significano otto colonne.</string>
    <string name="key_lockedMode">Modifica bloccata</string>
    <string name="key_lockedMode_tt">Il circuito è bloccato. Si può configurare diodi e FGF-FET.</string>
    <string name="key_pinNumber">Numero del pin</string>
    <string name="key_pinNumber_tt">Numero di questo pin. Usato per la rappresentazione di un circuito in un package DIL e per l'assegnazione
        del pin durante la programmazione di un CPLD.
        Se ci sono più bit, tutti i numeri di pin possono essere specificati in una lista separata da virgola.</string>
    <string name="key_pinCount">Numero di pin DIL</string>
    <string name="key_pinCount_tt">Numero dei pin. Uno zero significa che il numero dei pin è determinato automaticamente.</string>
    <string name="key_defTreeSelect">La vista della gerarchia dei componenti è visibile all'avvio.</string>
    <string name="key_defTreeSelect_tt">Se impostato, la vista della gerarchia dei componenti è visibile all'avvio.</string>
    <string name="key_inverterConfig">Ingressi invertiti</string>
    <string name="key_inverterConfig_tt">Puoi selezionare gli ingressi che devono essere invertiti.</string>
    <string name="key_fontSize">Dimensione del Font dei Menù [%]</string>
    <string name="key_fontSize_tt">Dimensione dei font utilizzati nel menù espressa in percentuale rispetto a quella predefinita.</string>
    <string name="key_withEnable">Ingresso Enable</string>
    <string name="key_withEnable_tt">Se abilitato un ingresso enable (T) è disponibile.</string>
    <string name="key_unidirectional">Unidirezionale</string>
    <string name="key_unidirectional_tt">I transistori unidirezionali propagano un segnale soltanto dal source al drain. Sono molto più veloci da
        simulare piuttosto che quelli bidirezionali. Visto che non c'è nessun feedback da drain a source, in
        questa modalità il transistore non fa corto circuito con i cavi connessi quando conduce. Quindi, questa modalità
        è necessaria per simulare certi circuiti CMOS.</string>
    <string name="key_activeLow">Attivo Basso</string>
    <string name="key_activeLow_tt">Se selezionato l'uscita è bassa se il componente è attivo.</string>
    <string name="key_libraryPath">Libreria</string>
    <string name="key_libraryPath_tt">La cartella che contiene la libreria con dei circuiti predefiniti.
        Contiene, per esempio, i componenti della serie 74xx. Puoi anche aggiungere i tuoi circuiti posizionandoli
        in questa cartella.
        Bisogna assicurarsi che tutti i nomi dei file e sottocartelle siano univoci.</string>
    <string name="key_grid">Mostra la Griglia</string>
    <string name="key_grid_tt">Mostra una griglia nella finestra principale.</string>
    <string name="key_wireToolTips">Suggerimenti sui Cavi.</string>
    <string name="key_wireToolTips_tt">Se impostato, le linee sono evidenziate quando il cursore passa sopra di esse.</string>
    <string name="key_mapToKey">Mappa a tastiera</string>
    <string name="key_mapToKey_tt">Un bottone è mappato alla tastiera. Per usare i tasti del cursore, usa UP (Sù), DOWN (Giù), RIGHT (Destra)
        e LEFT (Sinistra) come etichette.</string>
    <string name="key_jarPath">Libreria Java</string>
    <string name="key_jarPath_tt">Un file JAR contenente componenti aggiuntivi implementati in Java.</string>
    <string name="key_showWireBits">Mostra il numero di cavi in un bus.</string>
    <string name="key_showWireBits_tt">ATTENZIONE: Il valore è aggiornato solamente quando la simulazione viene avviata.</string>
    <string name="key_inputBits">Numero dei Bit in Ingresso</string>
    <string name="key_inputBits_tt">Il numero dei bit in uscita deve essere più grande di quello in ingresso.</string>
    <string name="key_outputBits">Numero di Bit in Uscita</string>
    <string name="key_outputBits_tt">Il numero dei bit in uscita deve essere più grande di quello in ingresso.</string>
    <string name="key_textFontSize">Dimensione del Font</string>
    <string name="key_textFontSize_tt">Imposta la dimensione del font per questo testo.</string>
    <string name="key_delayTime">Durata</string>
    <string name="key_delayTime_tt">Tempo di ritardo in unità del ritardo di propagazione di porta comune.</string>
    <string name="key_invertOutput">Uscita invertita</string>
    <string name="key_invertOutput_tt">Se selezionato l'uscita è invertita.</string>
    <string name="key_timerDelay">Larghezza dell'Impulso</string>
    <string name="key_timerDelay_tt">La larghezza dell'impulso è misurata in cicli di clock.</string>
    <string name="key_splitterSpreading_tt">Configura lo spreading degli ingressi ed uscite nel circuito.</string>
    <string name="key_romContent">Contenuto delle ROM</string>
    <string name="key_romContent_tt">Contenuto di tutte le ROM utilizzate</string>
    <string name="key_applicationType">Applicazione</string>
    <string name="key_applicationType_tt">Definisce quale applicazione utilizzare.</string>
    <string name="key_applicationType_Generic">Generica</string>
    <string name="key_externalInputs">Ingressi</string>
    <string name="key_externalInputs_tt">Gli ingressi del processo esterno.
        Questa è una lista di nomi di segnali separati da virgola. Per ogni nome, un numero di bit separato
        da un due punti (:) può essere specificato. Gli ingressi di un sommatore ad 8 bit potrebbero essere quindi
        specificati come "a:8,b:8,c_in".</string>
    <string name="key_externalOutputs">Uscite</string>
    <string name="key_externalOutputs_tt">Le uscite del processo esterno.
        Questa è una lista di nomi di segnali separati da virgola. Per ogni nome, un numero di bit separato
        da un due punti (:) può essere specificato. Le uscite di un sommatore ad 8 bit potrebbero essere quindi
        specificate come "s:8,c_out".</string>
    <string name="key_Code">Codice del Programma</string>
    <string name="key_Code_tt">Il codice del programma da eseguire dall'applicazione esterna.</string>
    <string name="key_CodeFile">Codice del Programma</string>
    <string name="key_CodeFile_tt">Il file contenente il codice del programma da eseguire dall'applicazione esterna.</string>
    <string name="attr_panel_Options">Opzioni</string>
    <string name="key_ghdlPath_tt">Percorso all'eseguibile GHDL. Solamente necessario se si vuole usare GHDL per simulare i componenti
        definiti con VHDL.</string>
    <string name="key_ghdlOptions">Opzioni GHDL</string>
    <string name="key_ghdlOptions_tt">Opzioni che sono utilizzate per tutti i passi di processo da GHDL.</string>
    <string name="key_iverilogOptions">Opzioni IVerilog.</string>
    <string name="key_iverilogOptions_tt">Opzioni che sono utilizzate per tutti i passi di processo da IVerilog.</string>
    <string name="key_iverilogPath_tt">Percorso all'eseguibile IVerilog. Solamente necessario se si vuole usare IVerilog per simulare i componenti
        definiti con VHDL.</string>
    <string name="key_maxValue">Valore Massimo</string>
    <string name="key_maxValue_tt">Se uno zero è inserito, il valore massimo è usato (tutti i bit ad uno).</string>
    <string name="key_dipDefault">Uscita Alta</string>
    <string name="key_dipDefault_tt">Il valore d'uscita predefinito di un interruttore DIP quando la simulazione parte.</string>
    <string name="key_macMouse">Utilizza il click del mouse di macOS.</string>
    <string name="key_macMouse_tt">Utilizza Ctrl+Click anziché il click destro.</string>
    <string name="key_tunnelRenameDialog">Mostra il dialogo per rinominare automaticamente i tunnel.</string>
    <string name="key_tunnelRenameDialog_tt">Se impostato, una finestra di dialogo viene mostrata per rinominare automaticamente i tunnel con lo stesso nome
        dopo aver rinominato un tunnel.</string>
    <string name="key_ATMISP_tt">Percorso dell'eseguibile atmisp.exe. Se impostato, il software ATMISP può essere avviato automaticamente!</string>
    <string name="key_customShape">Figura Personalizzata</string>
    <string name="key_customShape_tt">Importa un file SVG</string>
    <string name="key_preloadProgram">Precarica la memoria contenente il programma all'avvio.</string>
    <string name="key_preloadProgram_tt">Quando si simula un processore che utilizza una RAM come la memoria per il programma, è difficile avviare iil
        processore perché il contenuto della RAM è sempre inizializzato con zeri all'avvio della simulazione.
        Questa impotazione consente il caricamento dei dati durante l'avvio.
        La memoria va indicata come tale.</string>
    <string name="key_preloadProgramFile">File del Programma</string>
    <string name="key_preloadProgramFile_tt">Il file che deve essere caricato nella memoria del programma all'avvio della simulazione.</string>
    <string name="key_RectWidth">Larghezza</string>
    <string name="key_RectWidth_tt">Larghezza in unità di griglia</string>
    <string name="key_RectHeight">Altezza</string>
    <string name="key_RectHeight_tt">Altezza in unità di griglia</string>
    <string name="key_RectInside">Testo Contenuto</string>
    <string name="key_RectInside_tt">Testo contenuto all'interno del rettangolo.</string>
    <string name="key_RectBottom">Testo in basso</string>
    <string name="key_RectBottom_tt">Testo in fondo al rettangolo.</string>
    <string name="key_RectRight">Testo a destra</string>
    <string name="key_RectRight_tt">Testo a destra del rettangolo.</string>
    <string name="key_wideShape">Figura Larga</string>
    <string name="key_wideShape_tt">Utilizza una figura più larga per visualizzare la porta.</string>
    <string name="key_shapeType">Figura</string>
    <string name="key_shapeType_tt">La figura da utilizzare per la rappresentazione del circuito in un circuito che lo incorpora.
        Nella modalità "semplice", gli ingressi sono rappresentati sulla sinista e le uscite sulla destra di un
        semplice rettangolo.
        Con la modalità "layout", la posizione degli ingressi e delle uscite e la loro orientazione nel circuito
        determina il posizionamento dei pin. Qui è possibile avere pin in alto o in basso.
        Quando si seleziona "chip DIL", un alloggiamento DIL è utilizzato per mostrare il circuito. I numeri dei pin
        degli ingressi e delle uscite determina la posizione dei pin nel case.</string>
    <string name="key_shapeType_DEFAULT">Predefinita</string>
    <string name="key_shapeType_SIMPLE">Semplice</string>
    <string name="key_shapeType_DIL">Chip DIL</string>
    <string name="key_shapeType_CUSTOM">Definita dall'Utente</string>
    <string name="key_textOrientation">Orientamento</string>
    <string name="key_textOrientation_tt">Posizione delle coordinate relative al testo.</string>
    <string name="key_textOrientation_LEFTBOTTOM">in basso a sinistra</string>
    <string name="key_textOrientation_CENTERBOTTOM">in basso al centro</string>
    <string name="key_textOrientation_RIGHTBOTTOM">in basso a destra</string>
    <string name="key_textOrientation_RIGHTCENTER">a destra al centro</string>
    <string name="key_textOrientation_RIGHTTOP">in alto a destra</string>
    <string name="key_textOrientation_CENTERTOP">in alto al centro</string>
    <string name="key_textOrientation_LEFTTOP">in alto a sinistra</string>
    <string name="key_textOrientation_LEFTCENTER">a sinistra al centro</string>
    <string name="key_textOrientation_CENTERCENTER">centrato</string>
    <string name="key_midiChannel">Canale MIDI</string>
    <string name="key_midiChannel_tt">Seleziona il canale MIDI da usare.</string>
    <string name="key_midiInstrument">Strumento MIDI</string>
    <string name="key_midiInstrument_tt">Seleziona lo strumento MIDI da usare.</string>
    <string name="key_midiProgChange">Consenti la modifica del programma</string>
    <string name="key_midiProgChange_tt">Aggiunge un nuovo ingresso PC. Se questo ingresso è altoo, il valore all'ingresso N è utilizzare
        per cambiare il programma (strumento).</string>
    <string name="key_enabled">Abilitato</string>
    <string name="key_enabled_tt">Abilita o disabilita questo componente.</string>
    <string name="key_toolChainConfig">Configurazione della Toolchain</string>
    <string name="key_toolChainConfig_tt">Utilizzato per configurare l'integrazione di una toolchain. Consente l'utilizzo di strumenti esterno, come per
        esempio la programmazione di una FPGA.</string>
    <string name="key_generic">Parametrizzazione Generica</string>
    <string name="key_generic_tt">Dichiarazioni utilizzate per rendere generico il circuito.</string>
    <string name="key_isGeneric">Il circuito è generico</string>
    <string name="key_isGeneric_tt">Consente di creare un circuito generico</string>
    <string name="key_showTutorial">Mostra il tutorial all'avvio</string>
    <string name="key_showTutorial_tt">Abilita il tutorial.</string>
    <string name="key_switchActsAsInput">L'interruttore si comporta come un ingresso</string>
    <string name="key_switchActsAsInput_tt">Se il modello è analizzato, l'interruttore si comporta come un ingresso dove "aperto" corrisponde a zero e
        "chiuso" corrisponde ad uno.</string>
    <string name="menu_exportSVGSettings">Impostazioni di esportazione SVG</string>
    <string name="key_SVG_LaTeX">Testo in notazione LaTeX</string>
    <string name="key_SVG_LaTeX_tt">Il testo è inserito in notazione LaTeX. Inkscape è richiesto per ulteriore processamento.</string>
    <string name="key_SVG_pinsInMathMode">Etichette dei pin in modalità matematica</string>
    <string name="key_SVG_pinsInMathMode_tt">Per le etichette dei pin, utilizza la modalità matematica anche se nessun indice è contenuto.</string>
    <string name="key_SVG_hideTest">Nascondi i test case</string>
    <string name="key_SVG_hideTest__">I test case non sono esportati.</string>
    <string name="key_SVG_noShapeFilling">Figure vuote</string>
    <string name="key_SVG_noShapeFilling_tt">Poligoni vuoti.</string>
    <string name="key_SVG_smallIO">Ingressi ed uscite piccole</string>
    <string name="key_SVG_smallIO_tt">Gli ingressi e le uscite sono rappresentate da piccoli cerchietti.</string>
    <string name="key_SVG_noPinMarker">Ometti Marcatore del Pin</string>
    <string name="key_SVG_noPinMarker_tt">I marcatori rossi e blu del pin nei simboli sono omessi.</string>
    <string name="key_SVG_highContrast">Contrasto Elevato</string>
    <string name="key_SVG_highContrast_tt">I cavi e il testo dei pin sono visualizzati in nero-</string>
    <string name="key_SVG_monochrome">Monocromo</string>
    <string name="key_SVG_monochrome_tt">Soltanto sfumature di grigio sono utilizzate.</string>
    <string name="key_SVG_thinnerLines">Linee Sottili</string>
    <string name="key_SVG_thinnerLines_tt">Se impostato, le linee sono disegnate leggermente più sottile.</string>
    <string name="key_equalsInsteadOfPlus">Usa il Tasto Uguale</string>
    <string name="key_equalsInsteadOfPlus_tt">Utilizza il tasto "Uguale" piuttosto che il tasto "Più". Questo è sempre utile se il segno più non è una
        chiave primaria, ma la seconda assegnazione del carattere uguale come per esempio nelle tastiere francesi
        ed americane.</string>
    <string name="key_snapToGrid">Allinea alla Griglia</string>
    <string name="key_snapToGrid_tt">Se impostato, il componente è allineato alla griglia.</string>
    <string name="key_layoutShapeDelta">Separazione tra i Pin</string>
    <string name="key_layoutShapeDelta_tt">Utilizzato dal tipo di forma della figura. Imposta la distanza rispetto al pin precedente.</string>
    <string name="key_trigger">Attivatore</string>
    <string name="key_trigger_tt">Condizione di attivazione per la registrazione dei dati.</string>
    <string name="key_trigger_rising">fronte di salita</string>
    <string name="key_trigger_falling">fronte di discesa</string>
    <string name="key_trigger_both">entrambe i fronti</string>
    <string name="key_probeMode">Modalità di Visualizzazione</string>
    <string name="key_probeMode_tt">Definisce se il valore o un contatore viene mostrato.</string>
    <string name="key_probeMode_VALUE">Mostra Valore</string>
    <string name="key_probeMode_UP">Conteggia i Fronti di Salita</string>
    <string name="key_probeMode_DOWN">Conteggia i Fronti di Discesa</string>
    <string name="key_probeMode_BOTH">Conteggia Entrambe i Fronti</string>
    <string name="key_telnetEscape">Modalità Telnet</string>
    <string name="key_telnetEscape_tt">Se impostato, i comandi di controllo Telnet sono valutati.
        In aggiunta, il server invia i comandi SGA e ECHO. Se questa opzione è disabilitata,
        il server è un semplice server TCP.</string>
    <string name="key_port">Porta</string>
    <string name="key_port_tt">La porta che viene aperta dal server.</string>
    <string name="key_colorScheme">Schema di colori</string>
    <string name="key_colorScheme_DEFAULT">Normale</string>
    <string name="key_colorScheme_DARK">Scuro</string>
    <string name="key_colorScheme_COLOR_BLIND">Daltonismo Rosso/Verde</string>
    <string name="key_colorScheme_CUSTOM">Definito dall'Utente</string>
    <string name="key_customColorScheme">Colori Definiti dall'Utente</string>
    <string name="colorName_BACKGROUND">Sfondo</string>
    <string name="colorName_MAIN">Principale</string>
    <string name="colorName_WIRE">Cavi</string>
    <string name="colorName_WIRE_HIGH">Cavo con valore alto</string>
    <string name="colorName_WIRE_LOW">Cavo con valore basso</string>
    <string name="colorName_WIRE_VALUE">Valore del cavo</string>
    <string name="colorName_WIRE_OUT">Uscita</string>
    <string name="colorName_WIRE_Z">Cavo in alta impedenza</string>
    <string name="colorName_ERROR">Errore</string>
    <string name="colorName_PINS">Pin</string>
    <string name="colorName_GRID">Griglia</string>
    <string name="colorName_DISABLED">Disabilitato</string>
    <string name="colorName_ASYNC">Asincrono</string>
    <string name="colorName_HIGHLIGHT">Evidenziato</string>
    <string name="mod_insertWire">Cavo inserito.</string>
    <string name="mod_insertCopied">Inserisci dalla clipboard.</string>
    <string name="mod_setKey_N0_in_element_N1">Valore "{0}" nel componente "{1}" modificato.</string>
    <string name="mod_setAttributesIn_N">Attributi del componente "{0}" modificati.</string>
    <string name="mod_wireDeleted">Cavo eliminato.</string>
    <string name="mod_movedOrRotatedElement_N">Componente "{0}" spostato o ruotato.</string>
    <string name="mod_movedWire">Cavo spostato.</string>
    <string name="mod_deletedSelection">Selezione eliminata.</string>
    <string name="mod_insertedElement_N">Componente "{0}" inserito.</string>
    <string name="mod_deletedElement_N">Componente "{0}" eliminato.</string>
    <string name="mod_insertedWire">Cavo inserito.</string>
    <string name="mod_movedSelected">Selezione spostata.</string>
    <string name="mod_undo_N">Annulla: {0}</string>
    <string name="mod_redo_N">Rifai: {0}</string>
    <string name="mod_circuitAttrModified">Modificati gli attributi del circuito.</string>
    <string name="mod_modifiedMeasurementOrdering">Misurazioni ordinate.</string>
    <string name="mod_groupEdit">Modificati gli attributi dei componenti selezionati.</string>
    <string name="mod_splitWire">Divide un singolo cavo in due cavi.</string>
    <string name="mod_modifiedByRunningModel">Cambiamenti effettuati dalla simulazione avviata.</string>
    <string name="lib_Logic">Logica</string>
    <string name="lib_arithmetic">Aritmetica</string>
    <string name="lib_flipFlops">Flip-Flop</string>
    <string name="lib_memory">Memoria</string>
    <string name="lib_mux">Plexer</string>
    <string name="lib_wires">Cavi</string>
    <string name="lib_switching">Interruttori</string>
    <string name="lib_displays">Schermi</string>
    <string name="lib_mechanic">Meccanici</string>
    <string name="lib_peripherals">Periferiche</string>
    <string name="lib_misc">Altro</string>
    <string name="lib_more">di più</string>
    <string name="lib_decoration">Decorazioni</string>
    <string name="lib_generic">Generici</string>
    <string name="cli_cli">Interfaccia a Linea di Comando</string>
    <string name="cli_nonOptionalArgumentMissing_N">L''argomento obbligatorio {0} è mancante.</string>
    <string name="cli_notABool_N">Il valore {0} non è un booleano.</string>
    <string name="cli_notANumber_N">Il valore {0} non è un numero.</string>
    <string name="cli_noArgument_N_available">L''argomento {0} non è definito.</string>
    <string name="cli_notEnoughArgumentsGiven">Non ci sono abbastanza argomenti.</string>
    <string name="cli_toMuchArguments">Ci sono troppi argomenti.</string>
    <string name="cli_invalidType_N">Tipo invalido.</string>
    <string name="cli_command_N_hasNoSubCommand_N">Il comando {0} non ha nessun sottocomando {1}.</string>
    <string name="cli_options">Opzioni:</string>
    <string name="cli_help_test">Il primo nome di file specifica il circuito da testare.
        Se un secondo nome di file è specificato, i test case sono eseguiti da questo file.
        Se nessun secondo nome è specificato, i test case sono eseguiti dal primo file.</string>
    <string name="cli_help_test_circ">Nome del file da testare.</string>
    <string name="cli_help_test_tests">Nome di un file con i test case.</string>
    <string name="cli_help_test_allowMissingInputs">Consente la mancanza di ingressi nel circuito definiti nel test case. Questo può essere utile quando ci
        sono più possibili soluzioni che possono dipendere da ingressi differenti.</string>
    <string name="cli_help_test_verbose">Se impostato, la tabella dei valori viene visualizzata nel caso di un errore.</string>
    <string name="cli_thereAreTestFailures">I test hanno fallito.</string>
    <string name="cli_errorExecutingTests">Un errore si è verificato durante l'esecuzione dei test.</string>
    <string name="cli_help_svg">Può essere utilizzato per creare un file SVG da un circuito.</string>
    <string name="cli_help_svg_dig">Il nome del file che rappresenta il circuito.</string>
    <string name="cli_help_svg_svg">Il nome del file SVG che verrà scritto.</string>
    <string name="cli_help_svg_ieee">Usa i simboli IEEE.</string>
    <string name="cli_errorCreatingSVG">Errore durante la creazione del file SVG!</string>
    <string name="cli_help_stats">Crea un file SVG che contiene le statistiche del circuito.
        Tutti i componenti sono elencati nel file CSV.</string>
    <string name="cli_help_stats_dig">Nome del file del circuito.</string>
    <string name="cli_help_stats_csv">Nome del file CSV da creare. Se questa opzione manca, la tabella è scritta nello standard output.</string>
    <string name="cli_errorCreatingStats">Errore durante la creazione dei file di statistica!</string>
    <string name="menu_window">Finestre</string>
    <string name="menu_about">Informazioni su</string>
    <string name="menu_analyse">Analisi</string>
    <string name="menu_analyse_tt">Analizza il circuito corrente</string>
    <string name="menu_cut">Taglia</string>
    <string name="menu_copy">Copia</string>
    <string name="menu_copy_tt">Copia nella clipboard</string>
    <string name="menu_custom">Personalizzato</string>
    <string name="menu_library">Libreria</string>
    <string name="menu_delete">Elimina componenti</string>
    <string name="menu_delete_tt">Elimina il componente singolo selezionato o il gruppo di componenti.</string>
    <string name="menu_edit">Modifica</string>
    <string name="menu_editAttributes">Impostazioni specifiche del circuito</string>
    <string name="menu_editAttributes_tt">Le impostazioni specifiche del circuito hanno effetto sul comportamento del circuito aperto.
        Per esempio, la figura che rappresenta il circuito quando è incorporato in altri circuiti.
        Queste impostazioni sono memorizzate insieme al circuito.</string>
    <string name="menu_editSettings">Impostazioni</string>
    <string name="menu_editSettings_tt">Le impostazioni globali del simulatore specificano, tra l'altro, la lingua, il formato dei simboli
        da utilizzare e i percorsi per strumenti esterni.</string>
    <string name="menu_element">Ferma la Simulazione</string>
    <string name="menu_element_tt">Ferma la simulazione e consente la modifica del circuito.</string>
    <string name="menu_elements">Componenti</string>
    <string name="menu_export">Esporta</string>
    <string name="menu_exportPNGLarge">Esporta in formato PNG grande</string>
    <string name="menu_exportPNGSmall">Esporta in formato PNG piccolo</string>
    <string name="menu_exportSVG">Esporta in formato SVG</string>
    <string name="menu_exportAnimatedGIF">Esporta in formato GIF animata</string>
    <string name="menu_fast">Esegui fino all'Interruzione</string>
    <string name="menu_fast_tt">Esegue la logica del circuito fino a quando una interruzione viene identificata da un componente BRK.</string>
    <string name="menu_help">Aiuto</string>
    <string name="menu_update">Aggiorna</string>
    <string name="menu_update_tt">Aggiorna il menù dei componenti.</string>
    <string name="menu_maximize">Adatta alla Finestra</string>
    <string name="menu_micro">Porta a Passo Singolo</string>
    <string name="menu_micro_tt">Esegue il circuito in modalità porta a passo singolo</string>
    <string name="menu_new">Nuovo</string>
    <string name="menu_new_tt">Crea un nuovo circuito vuoto.</string>
    <string name="menu_newSub">Nuovo Circuito Incorporato</string>
    <string name="menu_newSub_tt">Apre una nuova finestra per creare un nuovo circuito incorporato, che può essere poi usato in questo circuito.</string>
    <string name="menu_open">Apri</string>
    <string name="menu_openRecent">Apri Recente</string>
    <string name="menu_openRecentNewWindow">Apre Recente in una Nuova Finestra</string>
    <string name="menu_openWin">Apri in una Nuova Finestra</string>
    <string name="menu_openWin_tt">Apre un circuito in una nuova finestra</string>
    <string name="menu_orderInputs">Ordina Ingressi</string>
    <string name="menu_orderInputs_tt">Ordina gli ingressi per l'uso in un circuito incorporato.</string>
    <string name="menu_orderMeasurements">Ordina i valori di misurazione</string>
    <string name="menu_orderMeasurements_tt">Ordina i valori di misurazione nella vista grafica e nella tabella</string>
    <string name="menu_orderOutputs">Ordina Uscite</string>
    <string name="menu_orderOutputs_tt">Ordina le uscite nell'uso di un circuito incorporato.</string>
    <string name="menu_paste">Incolla</string>
    <string name="menu_rotate">Ruota</string>
    <string name="menu_sim">Simulazione</string>
    <string name="menu_run">Avvio della Simulazione</string>
    <string name="menu_run_tt">Avvia la simulazione del circuito.</string>
    <string name="menu_save">Salva</string>
    <string name="menu_saveAs">Salva Come</string>
    <string name="menu_saveData">Salva Dati</string>
    <string name="menu_saveData_tt">Salva Dati come File CSV</string>
    <string name="menu_speedTest">Test di Velocità</string>
    <string name="menu_speedTest_tt">Esegue un test di velocità calcolando la frequenza massima.</string>
    <string name="menu_step">Avanza di un Passo</string>
    <string name="menu_step_tt">Calcola un singolo passo della porta</string>
    <string name="menu_runToBreakMicro">Esegui fino all'Interruzione in Modalità Passo Singolo</string>
    <string name="menu_runToBreakMicro_tt">Esegue tutti i passi singoli della porta fino a quando un fronte di salita è individuato su un
        componente di interruzione. Se non c'è tale componente, i passi rimanenti sono anch'essi eseguiti.</string>
    <string name="menu_synthesise">Sintesi</string>
    <string name="menu_synthesise_tt">Genera le minime espressioni booleane descritte dalla tabella di verità.</string>
    <string name="menu_scale">Imposta la Scala</string>
    <string name="menu_table_N_variables">{0} variabili</string>
    <string name="menu_table_create">Crea</string>
    <string name="menu_table_createCUPL_tt">Crea un file sorgente CUPL contenente la definizione del circuito.</string>
    <string name="menu_table_createTT2_tt">Crea un file sorgente contenente la definizione del circuito in maniera simile al formato 
        Berkeley Logic Interchange Format (BLIF). Dopo questo, il fitter ATMEL è avviato per creare il file JEDEC.</string>
    <string name="menu_table_createCircuit">Circuito</string>
    <string name="menu_table_createCircuit_tt">Crea un circuito che riproduce le tabelle di verità.</string>
    <string name="menu_table_createCircuitJK">Circuito con Flip-Flop JK</string>
    <string name="menu_table_createCircuitJK_tt">Crea un circuito che riproduce le tabelle di verità. Utilizza i flip-flop JK.</string>
    <string name="menu_table_createCircuitLUT">Circuito con LUT</string>
    <string name="menu_table_createCircuitLUT_tt">Crea un circuito che riproduce le tabelle di verità. Utilizza le tabelle di lookup per creare le espressioni.</string>
    <string name="menu_table_createNAnd">Circuito con porte NAND</string>
    <string name="menu_table_createNAndTwo">Circuito con porte NAND con due ingressi</string>
    <string name="menu_table_createNAndTwo_tt">Utilizza soltanto porte NAND con due ingressi.</string>
    <string name="menu_table_createNAnd_tt">Crea un circuito che riproduce le tabelle di verità utilizzando soltanto porte NAND.</string>
    <string name="menu_table_createNOr">Circuito con porte NOR</string>
    <string name="menu_table_createNOrTwo">Circuito con porte NOR con due ingressi</string>
    <string name="menu_table_createNOrTwo_tt">Utilizza soltanto porte NOR con due ingressi.</string>
    <string name="menu_table_createNOr_tt">Crea un circuito che riproduce le tabelle di verità utilizzando soltanto porte NOR.</string>
    <string name="menu_table_create_hardware">Dispositivo</string>
    <string name="menu_table_create_jedec_tt">Crea un file JEDEC per il dispositivo</string>
    <string name="menu_table_exportTableLaTeX">Esporta LaTeX</string>
    <string name="menu_table_exportTablePlainText">Esporta in Testo Semplice</string>
    <string name="menu_table_createFunctionFixture">Esporta Test Case</string>
    <string name="menu_table_createFunctionFixture_tt">Crea una descrizione del test case che può essere utilizzata in un test case.</string>
    <string name="menu_table_createFunctionFixture_isSequential">Il test case è funzionale se e solo se il circuito è combinatorio.</string>
    <string name="menu_table_exportHex">Esadecimale</string>
    <string name="menu_table_exportHex_tt">Puoi caricare il file esadecimale all'interno di una ROM o tabella di lookup.</string>
    <string name="menu_table_exportCSV_tt">Un file CSV contenente la tabella di verità completa.</string>
    <string name="menu_table_exportCSVCondensed">CSV, Implicanti Primi</string>
    <string name="menu_table_exportCSVCondensed_tt">Un file CSV contenente soltanto gli implicanti primi.</string>
    <string name="menu_table_new">Nuovo</string>
    <string name="menu_table_new_combinatorial">Combinatorio</string>
    <string name="menu_table_new_sequential">Sequenziale</string>
    <string name="menu_table_new_sequential_bidir">Sequenziale Bidirezionale</string>
    <string name="menu_table_reorder_inputs">Riordina/Elimina Variabili d'Ingresso</string>
    <string name="menu_table_reorder_outputs">Riordina/Elimina Colonne d'Uscita</string>
    <string name="menu_table_columnsAdd">Aggiungi Colonna d'Uscita</string>
    <string name="menu_table_columnsAdd_tt">Aggiunge una nuova colonna risultato alla tabella.</string>
    <string name="menu_table_columnsAddVariable">Aggiungi Variabile d'Ingresso</string>
    <string name="menu_table_columnsAddVariable_tt">Aggiunge una nuova variabile d'ingresso alla tabella.</string>
    <string name="menu_table_setXTo0">Imposta X a zero</string>
    <string name="menu_table_setXTo0_tt">Imposta i valori non importanti a zero.</string>
    <string name="menu_table_setXTo1">Imposta X a uno</string>
    <string name="menu_table_setXTo1_tt">Imposta i valori non importanti a uno.</string>
    <string name="menu_table_JK">Crea espressioni J/K</string>
    <string name="menu_table_setAllToX">Imposta tutto ad X</string>
    <string name="menu_table_setAllToX_tt">Imposta tutto a valore non importante.</string>
    <string name="menu_table_setAllTo0">Imposta tutto a zero</string>
    <string name="menu_table_setAllTo0_tt">Imposta tutti i valori a zero.</string>
    <string name="menu_table_setAllTo1">Imposta tutto a uno</string>
    <string name="menu_table_setAllTo1_tt">Imposta tutti i valori ad uno</string>
    <string name="menu_table_invert">Inverti tutti i bit</string>
    <string name="menu_table_invert_tt">Un'uno diventa uno zero e viceversa. Il resto rimane uguale.</string>
    <string name="menu_table_showAllSolutions">Mostra la finestra di dialogo dei risultati</string>
    <string name="menu_table_showAllSolutions_tt">Mostra la finestra di dialogo dei risultati se è stata chiusa manualmente.</string>
    <string name="menu_terminalDelete">Elimina</string>
    <string name="menu_terminalDelete_tt">Elimina i contenuti del terminale.</string>
    <string name="menu_view">Visualizza</string>
    <string name="menu_zoomIn">Incrementa Zoom</string>
    <string name="menu_zoomOut">Decrementa Zoom</string>
    <string name="menu_expression">Espressione</string>
    <string name="menu_expression_tt">Crea un circuito da un'espressione.</string>
    <string name="menu_runTests">Esegui Test</string>
    <string name="menu_runTests_tt">Esegue tutti i test case del circuito</string>
    <string name="menu_actualToDefault">Imposta gli Ingressi Predefiniti</string>
    <string name="menu_actualToDefault_tt">Utilizza i valori correnti degli ingressi come valori predefiniti.</string>
    <string name="menu_restoreAllFuses">Resetta tutti i diodi e FGFET</string>
    <string name="menu_restoreAllFuses_tt">Resetta tutti i diodi (fusibili) e FGFET allo stato "non programmato". La configurazione
        corrente dei fusibili viene persa!</string>
    <string name="menu_programDiode">Programma Diodo</string>
    <string name="menu_help_elements">Componenti</string>
    <string name="menu_help_elements_tt">Mostra una lista di tutti i componenti disponibili.</string>
    <string name="menu_viewHelp">Visualizza Aiuto</string>
    <string name="menu_viewHelp_tt">Mostra la finestra di dialogo dell'aiuto che descrive il circuito corrente.</string>
    <string name="menu_probe_memory">Memoria</string>
    <string name="menu_probe_memory_tt">Mostra i contenuti della memoria per il componente.</string>
    <string name="menu_insertAsNew">Incolla in una nuova finestra</string>
    <string name="menu_insertAsNew_tt">I contenuti della clipboard sono incollati in una nuova finestra.</string>
    <string name="menu_treeSelect">Vista Gerarchia Componenti</string>
    <string name="menu_treeSelect_tt">Mostra una vista gerarchica dei componenti disponibili nel lato sinistro.</string>
    <string name="menu_special">Funzioni 74xx Speciali</string>
    <string name="menu_addPrefix">Aggiungi Prefisso IO</string>
    <string name="menu_addPrefix_tt">Un prefisso è aggiunto a tutti gli ingressi e le uscite selezionate.
        Viene utilizzato per simplificare il raddoppiamento dei circuiti all'interno di un circuito 74xx.</string>
    <string name="menu_removePrefix">Rimuovi Prefisso IO</string>
    <string name="menu_removePrefix_tt">Il primo carattere dalle etichette degli ingressi ed uscite viene rimosso.
        Viene utilizzato per simplificare il raddoppiamento dei circuiti all'interno di un circuito 74xx.</string>
    <string name="menu_numbering">Procedura Guidata Pin</string>
    <string name="menu_numbering_tt">Una procedura guidata per applicare un numero ai pin degli ingressi ed uscite.</string>
    <string name="menu_removePinNumbers">Rimuovi Numeri dei Pin</string>
    <string name="menu_removePinNumbers_tt">Rimuove tutti i numeri dei pin del circuito.</string>
    <string name="menu_undo">Annulla</string>
    <string name="menu_undo_tt">Annulla l'ultima modifica.</string>
    <string name="menu_redo">Rifai</string>
    <string name="menu_redo_tt">Riapplica l'ultima modifica annullata.</string>
    <string name="menu_showDataAsGraph">Mostra Grafico</string>
    <string name="menu_showDataAsGraph_tt">Mostra i dati sotto forma di grafico.</string>
    <string name="menu_showDataAsTable">Mostra Tabella</string>
    <string name="menu_showDataAsTable_tt">Mostra i dati sotto forma di tabella.</string>
    <string name="menu_addPowerSupply">Aggiungi alimentazione</string>
    <string name="menu_addPowerSupply_tt">Aggiunge una alimentazione al circuito.</string>
    <string name="menu_exportVHDL">Esporta a VHDL</string>
    <string name="menu_exportVHDL_tt">Esporta il circuito nel formato VHDL</string>
    <string name="menu_exportVerilog">Esporta a Verilog</string>
    <string name="menu_exportVerilog_tt">Esporta il circuito nel formato Verilog</string>
    <string name="menu_karnaughMap_tt">Mostra una mappa di Karnaugh della tabella!</string>
    <string name="menu_pdfDocumentation">Documentazione</string>
    <string name="menu_openPdfDocumentation">Apri {0}</string>
    <string name="menu_showDataTable">Mostra la tabella dei valori di misurazione</string>
    <string name="menu_showDataTable_tt">Mostra la tabella con i valori misurati in una finestra separata.</string>
    <string name="menu_showDataGraph">Mostra grafico delle misurazioni.</string>
    <string name="menu_showDataGraph_tt">Mostra un grafico con i valori misurati in una finestra separata.</string>
    <string name="menu_exportZIP">Esporta a file ZIP</string>
    <string name="menu_exportZIP_tt">Esporta il circuito sotto forma di file ZIP.
        Il file ZIP contiene tutti i file necessari per l'operazione del circuito.</string>
    <string name="menu_labelPins">Etichetta Ingressi ed Uscite</string>
    <string name="menu_labelPins_tt">Applica un'etichetta a tutti gli ingressi e le uscite che sono senza.</string>
    <string name="menu_tutorial">Avvia Tutorial</string>
    <string name="menu_tutorial_tt">Avvia il tutorial per principianti.</string>
    <string name="menu_stats">Statistiche Circuito</string>
    <string name="menu_stats_tt">Mostra una lista dei componenti utilizzati.</string>
    <string name="stat_number">Numeri</string>
    <string name="stat_part">Componenti</string>
    <string name="stat_inputs">Ingressi</string>
    <string name="stat_bits">Bit</string>
    <string name="stat_addrBits">Bit di Indirizzo</string>
    <string name="msg_errorOpeningDocumentation">Errore durante l'apertura del file PDF!</string>
    <string name="message">&lt;h1&gt;Digital&lt;/h1&gt;
        &lt;p&gt;Un semplice simulatore per circuiti digitali.&lt;/p&gt;
        &lt;p&gt;Scritto da H. Neemann nel 2016-2023.&lt;/p&gt;
        &lt;p&gt;Le icone sono prese dal &lt;a href="http://tango.freedesktop.org"&gt;Tango Desktop Project&lt;/a&gt;.&lt;/p&gt;
        &lt;p&gt;Visita il progetto su &lt;a href="https://github.com/hneemann/[[name]]"&gt;GitHub&lt;/a&gt;.
        Su GitHub puoi anche &lt;a href="https://github.com/hneemann/[[name]]/releases/latest"&gt;scaricare&lt;/a&gt;
        l'ultima versione.&lt;/p&gt;
        &lt;p&gt;Puoi anche inviare un &lt;a href="https://github.com/hneemann/[[name]]/issues/new?body=version:%20[[version]]&amp;labels=bug"&gt;problema&lt;/a&gt;
        o suggerire
        un &lt;a href="https://github.com/hneemann/[[name]]/issues/new?labels=enhancement"&gt;miglioramento&lt;/a&gt;.&lt;/p&gt;</string>
    <string name="msg_N_nodes">{0} nodi</string>
    <string name="msg_analyseErr">Errore durante l'analisi del circuito</string>
    <string name="msg_color">Colore</string>
    <string name="msg_errorCalculatingStep">Errore nel calcolo del passo</string>
    <string name="msg_errorCreatingModel">Errore nella creazione del circuito</string>
    <string name="msg_errorDuringCalculation">Errore durante la semplificazione</string>
    <string name="msg_errorDuringHardwareExport">Errore durante la creazione della configurazione dell'hardware.</string>
    <string name="msg_errorEditingValue">Errore nella modifica di un valore dell'attributo.</string>
    <string name="msg_errorImportingModel_N0">Errore nell''importazione del circuito {0}!</string>
    <string name="msg_errorUpdatingLibrary">Errore durante l'aggiornamento della libreria componenti!</string>
    <string name="msg_errorReadingFile">Errore nella lettura del file</string>
    <string name="msg_remoteUnknownCommand">Comando {0} sconosciuto!</string>
    <string name="msg_errorWritingFile">Errore nella scrittura del file</string>
    <string name="msg_frequency_N">La frequenza massima è {0} kHz</string>
    <string name="msg_missingShape_N">Manca la figura {0}</string>
    <string name="msg_pins">Assegnazione Pin</string>
    <string name="msg_restartNeeded">Un riavvio è richiesto per applicare le modifiche!</string>
    <string name="msg_enterAnExpression">Inserisci un'espressione:</string>
    <string name="msg_runningTestError">Errore durante l'esecuzione dei test:</string>
    <string name="msg_testResult">Risultato dei test</string>
    <string name="msg_test_N_Passed">{0} passati</string>
    <string name="msg_test_N_Failed">{0} falliti</string>
    <string name="msg_test_missingLines">(Troppi risultati!)</string>
    <string name="msg_test_missingLines_tt">Tutti i test case sono stati eseguiti ma non tutti i risultati sono mostrati.
        La valotazione dei test case è comunque corretta!</string>
    <string name="msg_testExp_N0_found_N1">P: {0} / T: {1}</string>
    <string name="msg_creatingHelp">Errore nella creazione dell'aiuto!</string>
    <string name="msg_clipboardContainsNoImportableData">La clipboard non contiene dati importabili!</string>
    <string name="msg_selectAnEmptyFolder">Seleziona una cartella vuota!</string>
    <string name="msg_fitterResult">Messaggio dal fitter esterno</string>
    <string name="msg_startExternalFitter">Esecuzione del fitter esterno</string>
    <string name="msg_actualCircuit">Circuito Attuale</string>
    <string name="msg_fileNotAccessible">Il nome file selezionato non è importabile dal progetto corrente!</string>
    <string name="msg_fileIsNotUnique">Il nome file non è unico!
        Tutti i file nella cartella di lavoro e tutte le sotto cartelle devono avere nomi unici. Questo si applica anche
        alle cartelle delle librerie. Se la tua cartella di lavoro ha un file 7400.dig, non puoi usare questo nome o il
        file 7400.dig dalla libreria, perché questo nome file non può più essere assegnato univocamente.</string>
    <string name="msg_duplicateLibraryFiles">Ci sono più file con lo stesso nome, che non possono essere assegnati univocamente! Quelli coinvolti sono:</string>
    <string name="msg_and_N_More">ed altri {0}.</string>
    <string name="msg_fileNotImportedYet">Il file non è ancora stato importato.</string>
    <string name="msg_fileExists">Il file {0} esiste già. Vuoi sovrascriverlo?</string>
    <string name="msg_isLocked">La modifica del circuito è disabilitata. Puoi togliere il blocco a "{0} -&gt; {1} -&gt; {2}". La copia dei componenti 
        e la configurazione dei diodi e FGFET con il tasto [p] è possibile anche in modalità di modifica bloccata.</string>
    <string name="msg_speedTestError">Errore durante il test di velocità.</string>
    <string name="msg_numberingWizard">Procedura Guidata di Numerazione</string>
    <string name="msg_pin_numbering_N">Seleziona il pin {0}:</string>
    <string name="msg_framesWritten_N">Frame scritti: {0}</string>
    <string name="msg_errorWritingGif">Errore durante la scrittura del file GIF!</string>
    <string name="btn_gifComplete">Pronta</string>
    <string name="btn_gifComplete_tt">Il file GIF è stato finalizzato e chiuso.</string>
    <string name="msg_gifExport">Esportazione GIF</string>
    <string name="msg_errCausedBy">causato da</string>
    <string name="msg_inputsToInvert">Ingressi da invertire</string>
    <string name="msg_none">nessuno</string>
    <string name="msg_errGettingPinNames">Impossibile determinare i nomi dei pin.</string>
    <string name="msg_errInFile_N">Verificatosi nel file {0}.</string>
    <string name="msg_affectedComponentsAre_N">Quelli coinvolti sono: {0}.</string>
    <string name="msg_signal_N">Segnale {0}</string>
    <string name="msg_thereAreMissingPinNumbers">Nessun numero di pin è stato assegnato ai pin {0}!
        I pin liberi vengono automaticamente assegnati. Il circuito non può quindi essere usato su hardware reale nella
        maggior parte dei casi!</string>
    <string name="msg_modelHasErrors">Puoi esportare soltanto un circuito senza errori!</string>
    <string name="msg_noKVMapAvailable">Nessuna mappa KV disponibile!</string>
    <string name="msg_dataNotUpdatedAnymore">I dati non saranno più aggiornati!</string>
    <string name="msg_modifyThisAttribute">Modifica questo Valore</string>
    <string name="msg_invalidEditorValue">Uno dei campi contiene un valore invalido!</string>
    <string name="msg_create CHNFile">Creazione del file CHN.</string>
    <string name="msg_tableHasManyRowsConfirm">La tabella è molto grande; l'esportazione potrebbe richiedere un po' di tempo. Procedere con l'esportazione?</string>
    <string name="msg_circuitIsRequired">Per creare una descrizione dell'hardware, un circuito deve prima essere creato ed analizzato.
        Una tabella di verità individuale non può essere utilizzata per generare una descrizione dell'hardware.</string>
    <string name="msg_noData">nessun dato</string>
    <string name="msg_errorClosingExternalProcess">Impossibile chiudere il processo esterno!</string>
    <string name="msg_checkResult">Risultato della Verifica:</string>
    <string name="btn_checkCode">Verifica</string>
    <string name="btn_checkCode_tt">Avvia l'applicazione per verificare che il codice inserito sia corretto. Se il codice non è corretto, il messaggio
        di errore dall'applicazione esterna viene visualizzato. Se possibile, le definizioni degli ingressi ed uscite
        sono anch'esse adattate al codice corrente.</string>
    <string name="msg_codeNotConsistent">Le definizioni degli ingressi ed uscite non possono essere create automaticamente.
        Per favore, controlla le impostazioni!</string>
    <string name="msg_applicationFileNotFound">File eseguibile "{0}" non trovato!</string>
    <string name="msg_enterText">Inserisci il Testo!</string>
    <string name="btn_startATMISP">Avvia ATMISP</string>
    <string name="btn_startATMISP_tt">Avvia il programma esterno ATMISP. Questo deve essere stato precedentemente installato.</string>
    <string name="msg_errorStartingATMISP">Errore durante l'avvio di ATMISP!
        Il percorso corretto al file eseguibile atmisp.exe è stato specificato nelle impostazioni?</string>
    <string name="msg_ATMISPIsStillRunning">ATMISP è ancora in esecuzione!
        Quando questa finestra di dialogo viene chiusa, ATMISP verrà terminato!
        Assicurati che il processo di flash sia completo prima di chiudere questa finestra!</string>
    <string name="menu_runAllTests">Avvia Tutti i Test</string>
    <string name="menu_runAllTests_tt">Esegue tutti i test nella cartella corrente.</string>
    <string name="msg_testPassed_N">{0} righe di test passate</string>
    <string name="msg_testFile">File Testati</string>
    <string name="msg_truthTable">Tabella di Verità</string>
    <string name="msg_truthTableCSV">Valori Separati da Virgola, CSV</string>
    <string name="msg_errorImportingSvg">Errore durante l'importazione del file SVG.</string>
    <string name="msg_errorCreatingSvgTemplate">Errore nella creazione del template SVG.</string>
    <string name="msg_couldNotCreateStats">Le statistiche non sono state create.</string>
    <string name="menu_createBehavioralFixture">Crea Test Case per Dispositivo Comportamentale</string>
    <string name="menu_createBehavioralFixture_tt">Crea una fixture comportamentale dal circuito.
        Una fixture comportamentale è un test case che risolve il comportamento corrente.</string>
    <string name="msg_fixesCreated_N">Fixture: {0}</string>
    <string name="btn_createTestLine">Crea Fixture</string>
    <string name="btn_createTestLine_tt">Crea una nuova fixture nel test case.</string>
    <string name="btn_BehavioralFixtureComplete">Completa</string>
    <string name="btn_BehavioralFixtureComplete_tt">Crea il componente di test case</string>
    <string name="msg_errorCreatingTestCase">Errore nella creazione del test case.</string>
    <string name="msg_errorReadingToolchainConfig_N">Errore durante la lettura della configurazione della toolchain {0}.</string>
    <string name="msg_commandStarted_N">Il comando "{0}" è stato avviato! Il processo potrebbe richiedere un po'' di tempo!</string>
    <string name="msg_commandEnded_N">Il comando "{0}" ha finito!</string>
    <string name="msg_renameNet">Rinomina Rete</string>
    <string name="msg_renameNet_N_OLD_NEW">Ci sono {0} altri tunnel con il nome di rete "{1}". Vuoi rinominare tutti {0} a "{2}"?</string>
    <string name="msg_dataWillBeLost_n">Vuoi veramente scartare le modifiche nel campo "{0}"?</string>
    <string name="btn_copyToClipboard_tt">Copia il testo nella clipboard.</string>
    <string name="msg_supportsHDL">Esportabile su VHDL/Verilog.</string>
    <string name="msg_errorSettingModelToTestCase">Errore nell'impostazione della riga del test case.</string>
    <string name="stat_clocks">Interrompi dopo {0} mezzi cicli nel punto di interruzione "{1}".</string>
    <string name="tt_deleteItem">Elimina l'elemento selezionato</string>
    <string name="tt_moveItemDown">Muove l'elemento in basso</string>
    <string name="tt_moveItemUp">Muove l'elemento in alto</string>
    <string name="win_allSolutions">Tutte le possibili soluzioni</string>
    <string name="win_testdata_N">Dati di test {0}</string>
    <string name="win_data">Dati</string>
    <string name="win_confirmExit">Conferma l'uscita!</string>
    <string name="win_measures">Misurazioni</string>
    <string name="win_measures_fullstep">Misurazioni a passo di clock completo</string>
    <string name="win_measures_microstep">Misurazione a passo di porta singolo</string>
    <string name="win_saveChanges">Salvare le Modifiche?</string>
    <string name="win_stateChanged">Stato Cambiato!</string>
    <string name="win_table">Tabella</string>
    <string name="win_table_exportDialog">Esporta</string>
    <string name="win_itempicker_title">Seleziona</string>
    <string name="win_valueInputTitle_N">Ingresso {0}</string>
    <string name="win_karnaughMap">Mappa di Karnaugh</string>
    <string name="win_romDialog">ROM Incluse</string>
    <string name="btn_help">Aiuto</string>
    <string name="msg_keyAsGenericAttribute">Nome da utilizzare nei circuiti generici: {0}</string>
    <string name="attr_createConcreteCircuitLabel">Crea Circuito Concreto</string>
    <string name="attr_createConcreteCircuit">Crea</string>
    <string name="attr_createConcreteCircuit_tt">Crea un circuit concreto da questo generico utilizzando i parametri specificati nell'elemento.</string>
    <string name="attr_createConcreteCircuitErr">Errore durante la creazione del circuito concreto!</string>
    <string name="win_romDialogHelpTitle">Contenuto ROM Centrale</string>
    <string name="msg_romDialogHelp">&lt;html&gt;
        &lt;h3&gt;Motivazione&lt;/h3&gt;
        Quando un circuito contenente un componente ROM viene incorporato più volte, i contenuti della ROM
        sono normalmente utilizzati per ogni istanza del circuito. Sotto alcune circostanze però,
        potrebbe essere desiderabile per tale circuito essere incorporato più volte ma utilizzare contenuti della
        ROM differenti per ogni istanza.
        Questo problema si verifica quando per esempio una ROM 74xx viene utilizzata più volte con differenti
        valori di memoria.&lt;br/&gt;
        &lt;h3&gt;Funzione&lt;/h3&gt;
        A questa locazione pertanto, i contenuti della memoria possono essere definiti per tutte le ROM nel circuito.
        Quando il modello di simulazione viene generato, ogni ROM è inizializzata con i contenuti memorizzati
        direttamente nelle rispettive memorie. Viene poi verificato se un contenuto alternativo è stato definito. Se
        è il caso, il contenuto definito qua viene caricato nella ROM rispettiva.
        &lt;h3&gt;Utilizzo&lt;/h3&gt;
        Si noti che ogni ROM richiede un nome univoco per essere identificata.
        Per fare ciò, l'asterisco ("*") può essere utilizzato come nome. L'asterisco è successivamente sostituito con
        il percorso completo costruito dai nomi dei circuiti incorporati.
        Se il circuito contiene soltanto una ROM, allora è sufficente utilizzare l'asterisco come una etichetta.
        Tutti i circuiti incorporati devono essere nominati per far sì che un nome univoco possa essere generato
        automaticamente per ogni ROM.
        &lt;/html&gt;</string>
    <string name="msg_newRelease_N">&lt;html&gt;
        &lt;h1&gt;Nuova versione {0} disponibile&lt;/h1&gt;
        &lt;p&gt;C''è una nuova versione del simulatore disponibile.&lt;/p&gt;
        &lt;p&gt;Nelle &lt;a href="https://github.com/hneemann/[[name]]/releases/latest"&gt;note di rilascio&lt;/a&gt;
        puoi trovare i cambiamenti ed i miglioramenti.&lt;/p&gt;
        &lt;p&gt;Qui puoi &lt;a href="https://github.com/hneemann/[[name]]/releases/latest"&gt;scaricare&lt;/a&gt; la nuova versione.&lt;/p&gt;
        &lt;/html&gt;</string>
    <string name="msg_expressionHelpTitle">Espressioni</string>
    <string name="msg_expressionHelp">&lt;p&gt;Per definire un'espressione puoi utilizzare tutte le notazioni più comuni:&lt;/p&gt;
        &lt;p&gt;
        AND: "&amp;", "&amp;&amp;", "*", "∧"&lt;br/&gt;
        OR: "|", "||", "+", "∨", "#"&lt;br/&gt;
        XOR: "^", "⊻"&lt;br/&gt;
        NOT: "!", "~", "¬"
        &lt;/p&gt;
        &lt;p&gt;Come al solito, una AND precede OR e XOR.&lt;/p&gt;
        &lt;p&gt;Espressioni multiple possono essere separate con "," o ";".
        Se vuoi dare un nome alle espressioni, puoi usare il comento let: "let U=A+B, let V=A*B".&lt;/p&gt;</string>
    <string name="msg_testVectorHelpTitle">Test Vector</string>
    <string name="msg_testVectorHelp">&lt;html&gt;
    &lt;head&gt;&lt;style&gt;pre { background-color: #E0E0E0;}&lt;/style&gt;&lt;/head&gt;
    &lt;body&gt;
&lt;h3&gt;Generale&lt;/h3&gt;
&lt;p&gt;La prima linea deve contenere i nomi degli ingressi ed uscite.
Le linee successive devono contenere i valori che ci si aspetta.
Una "X" rappresenta un valore qualsiasi, una "Z" rappresenta un valore di alta impedenza.
Se una "C" è utilizzata, all'inizio tutti gli altri valori vengono impostati, dopodiché un ciclo di clock viene
eseguito e i valori sono comparati. Così è più facile verificare la logica sequenziale.
Una linea che inizia con un cancelletto ("#") è un commento.&lt;/p&gt;

&lt;p&gt;Un test per un contatore a due bit potrebbe essere scritto così:&lt;/p&gt;

&lt;pre&gt;
C Q1 Q0
0 0  0
C 0  1
C 1  0
C 1  1
C 0  0
&lt;/pre&gt;

&lt;p&gt;I test sono eseguiti da Esegui-&gt;Esegui Test.&lt;/p&gt;
&lt;p&gt;
Per rendere più semplice la creazione di questi test vector, c'è una dichiarazione "repeat([n])":
Se una linea inizia con quello, [n] linee di test sono generate. La variabile "n" può essere usata per generare i dati
di test. Con "repeat(16)", 16 linee verranno create, con n che va da 0 a 15. Se ci sono ingressi a più bit e questi devono
essere impostati insieme ad un valore binario, si può usare la dichiarazione "bits([bits], [value])". Questo crea [bits] bit
con il valore [value].&lt;/p&gt;

&lt;p&gt;Il seguente è un esempio con un sommatore a 4 bit:&lt;/p&gt;

&lt;pre&gt;
           C_i-1  A_3 A_2 A_1 A_0  B_3 B_2 B_1 B_0  C_i S_3 S_2 S_1 S_0
repeat(256)  0    bits(4,n&gt;&gt;4)     bits(4,n)        bits(5,(n&gt;&gt;4)+(n&amp;15))
repeat(256)  1    bits(4,n&gt;&gt;4)     bits(4,n)        bits(5,(n&gt;&gt;4)+(n&amp;15)+1)
&lt;/pre&gt;

&lt;p&gt;
I segnali di ingresso sono il carry (C_i-1) e gli otto bit A_3-A_0 e B_3-B_0.
I quattro bit di ingresso sono generati con l'istruzione "bits". Il risutato (C_i, S_3-S_0) è anch'esso
generato dall'istruzione "bits".
Questo si verifica una volta quando C_i-1=0 e nella linea successiva con C_i-1=1.
In questo modo, 512 linee di test vengono generate che coprono tutte le possibili configurazioni di ingresso.&lt;/p&gt;
&lt;p&gt;
Se più linee devono venir ripetute, o se cicli annidati sono richiesti, la dichiarazione "loop" può essere utilizzata.
L'esempio soprastante può infatti essere realizzato come segue:&lt;/p&gt;

&lt;pre&gt;
           C_i-1  A_3 A_2 A_1 A_0  B_3 B_2 B_1 B_0  C_i S_3 S_2 S_1 S_0
loop(a,16)
  loop(b,16)
             0    bits(4,a)        bits(4,b)        bits(5,a+b)
             1    bits(4,a)        bits(4,b)        bits(5,a+b+1)
  end loop
end loop
&lt;/pre&gt;

&lt;p&gt;
In alcune circostanze potrebbe essere necessario reagire allo stato iniziale del
circuito. Quindi i segnali forniti nel circuito possono essere utilizzati all'interno
del test case. Per esempio, se un contatore che parte in uno stato indefinito deve
essere testato, può essere impostato ad un valore definito dopo il clock:&lt;/p&gt;

&lt;pre&gt;C Q_3 Q_2 Q_1 Q_0

# contatore clock a 1111
while(!(Q_3 &amp; Q_2 &amp; Q_1 &amp; Q_0))
C x x x x
end while

# inizio dell'esecuzione del test
repeat(16) C bits(4,n)
&lt;/pre&gt;

&lt;p&gt;
Può essere utile generare numeri casuali nei test case.
Questi possono essere creati con la funzione "random([n])". Il numero generato è
compreso tra zero e [n]-1. Considerando un moltiplicatore a 16 bit come esempio,
un test completo non può essere generato visto che ci sono 2^32 combinazioni di
ingressi. IN questo caso un test di regressione può moltiplicare 10000 numeri casuali:&lt;/p&gt;

&lt;pre&gt;
   A    B      Y
loop(i,100000)
  let a = random(1&amp;lt;&amp;lt;16);
  let b = random(1&amp;lt;&amp;lt;16);
  (a)  (b)   (a*b)
end loop
&lt;/pre&gt;

&lt;p&gt;
Un ingresso che consente valori ad alta impedenza può anche essere usato come risultato del test.
In questo caso, il nome del segnale deve essere scritto con "_out" alla fine per la lettura e verifica del valore attuale.
Per questa cosa, l'ingresso corrispondente deve essere impostato al valore di alta impedenza ("Z").&lt;/p&gt;

&lt;pre&gt;OE CLK D D_out
0   0  0 0
0   C  1 1
1   0  z 1
0   C  0 0
1   0  z 0
&lt;/pre&gt;

&lt;p&gt;
Il circuito per questo test ha soltanto un ingresso "D", ma esso può essere impostato in alta impedenza.
Quindi, il segnale "D_out" è anche disponibile per controllare il valore in questo caso.&lt;/p&gt;

&lt;p&gt;
In situazioni particolare, potrebbe essere desiderabile utilizzare dei segnali che sono forniti dal circuito
per derivare un nuovo segnale, che è poi testato. Un esempio potrebbe essere un segnale del bus con più bit, dove
solo un singolo bit deve essere testato e non tutti quanti. In questo caso, un nuovo segnale può essere generato nel test
stesso, che contiene questo singolo bit.&lt;/p&gt;
&lt;p&gt;Questo è fatto con la dichiarazione "declare":&lt;/p&gt;
&lt;pre&gt;A B Bit

declare Bit = (Bus&gt;&gt;3)&amp;1;

0 0  0
0 1  0
1 0  1
1 1  0
&lt;/pre&gt;
&lt;p&gt;In questo esempio, il terzo bit è isolato dal segnale "Bus" e reso disponibile come segnale "Bit" per il test. Il
circuito stesso non contiene un'uscita "Bit".&lt;/p&gt;
&lt;h3&gt;Funzioni&lt;/h3&gt;
&lt;p&gt;Le funzioni disponibili sono:
&lt;dl&gt;
&lt;dt&gt;signExt([bits],[value])&lt;/dt&gt;
&lt;dd&gt;Estende il valore [value] preservando il segno a [bits] bit.&lt;/dd&gt;
&lt;dt&gt;random([max])&lt;/dt&gt;
&lt;dd&gt;Restituisce un numero intero casuale. Il valore massimo è specificato con [max].&lt;/dd&gt;
&lt;dt&gt;ite([cond],[then],[else])&lt;/dt&gt;
&lt;dd&gt;Se la condizione [cond] è vera, il valore [then] è restituito, altrimenti [else].&lt;/dd&gt;
&lt;/dl&gt;
&lt;/p&gt;

&lt;h3&gt;Processori&lt;/h3&gt;
&lt;p&gt;
Se i processori devono essere testati, una inizializzazione del processore è di solito richiesta.
Si può effettuare questa inizializzazione all'interno del test case.
In questo modo, più test possono trovarsi in un circuito ed ogni test utilizza la sua inizializzazione.
Ci sono tre istruzioni per effettuare questa inizializzazione:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
La dichiarazione "program" può essere usata per sovrascrivere la memoria del programma del processore.
L'istruzione &lt;pre&gt;program(0x8000,0x2d11,0x8000,0x2f21)&lt;/pre&gt; scrive quattro parole di bit all'inizio della memoria
del programma. Tutte le altre sono impostate a zero.&lt;/li&gt;.
&lt;li&gt;
L'istruzione "memory" può essere utilizzata per scrivere in un componente RAM:
&lt;pre&gt;memory mem(3)=7;&lt;/pre&gt;
Questo esempio scrive 7 bit nella memoria con etichetta "mem" all'indirizzo 3.&lt;/li&gt;
&lt;li&gt;
Un registro con nome può essere sovrascritto con l'istruzione "init".
&lt;pre&gt;init R0=22;&lt;/pre&gt;
Questa istruzione sovrascrive iil valore del registro con etichetta "R0" col valore 22.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Si noti che tutte le inizializzazioni sono applicate una volta prima dell'esecuzione del test. Non importa in che riga
del test case queste dichiarazioni si trovano.
Comunque, non devono trovarsi sopra la riga di intestazione che elenca i nomi dei segnali.&lt;/p&gt;.
&lt;/body&gt;&lt;/html&gt;</string>
    <string name="fsm_title">Macchina a Stati Finiti</string>
    <string name="fsm_noMove">Nessun movimento</string>
    <string name="fsm_moveTrans">Transizioni</string>
    <string name="fsm_moveStates">Transizioni e Stati</string>
    <string name="fsm_set_N">insieme {0}</string>
    <string name="menu_fsm">Macchina a Stati Finiti</string>
    <string name="menu_fsm_tt">Apre una finestra di dialogo per modificare una macchina a stati finiti.</string>
    <string name="menu_fsm_create">Crea</string>
    <string name="menu_fsm_create_table">Tabella delle Transizioni degli Stati</string>
    <string name="menu_fsm_create_counter">Crea un Contatore</string>
    <string name="menu_fsm_create_counter_N">{0} Stati</string>
    <string name="menu_fsm_Help_tt">Aiuto per l'operazione dell'editor delle macchine a stati finiti.</string>
    <string name="key_stateNum">Numero dello Stato</string>
    <string name="key_stateNum_tt">Il numero che rappresenta questo stato.</string>
    <string name="key_isInitialState">Stato Iniziale</string>
    <string name="key_isInitialState_tt">Se impostato, questo stato diventerà quello di partenza.</string>
    <string name="key_stateValues">Uscite</string>
    <string name="key_stateValues_tt">Definisce i valori di uscita.
        Con assegnazioni semplici come "A=1, B=0" le uscite possono essere impostate.
        Con istruzioni come "A=101", uscite a bit multipli possono essere create.
        Le uscite che non sono definite qua avranno un valore a zero.
        Per le transizioni, le uscite non specificate rimangono invariate.</string>
    <string name="key_transCond">Condizione</string>
    <string name="key_transCond_tt">Un'espressione booleana</string>
    <string name="key_transRad">Raggio</string>
    <string name="key_transRad_tt">Raggio del cerchio nel diagramma</string>
    <string name="err_notDeterministic_N">La macchina a stati finiti non è deterministica: {0}</string>
    <string name="err_fsmNumberUsedTwice_N">Numero di stato {0} utilizzato due volte.</string>
    <string name="err_fsmNoInitialState">Non c'è nessuno stato iniziale (stato con numero zero).</string>
    <string name="err_fsmState_N_notFound">Stato "{0}" non trovato!</string>
    <string name="err_fsmInvalidOutputAssignment_N">Assegnazione errata per l''uscita ("{0}")!</string>
    <string name="err_fsmErrorInCondition_N">Errore nella condizione "{0}"!</string>
    <string name="msg_fsm_errorLoadingFile">Errore nel caricamento di un file!</string>
    <string name="msg_fsm_errorStoringFile">Errore nella memorizzazione di un file!</string>
    <string name="msg_fsmTransition">Transizione</string>
    <string name="msg_fsmState">Stato</string>
    <string name="msg_fsmNewState">Nuovo Stato</string>
    <string name="msg_fsmCantCreateTable">Impossibile creare la tabella della transizione di stati.</string>
    <string name="msg_fsmHelpTitle">Aiuto dell'Editor FSM</string>
    <string name="msg_fsm_optimizer">Ottimizzatore FSM</string>
    <string name="menu_fsm_optimize_state_numbers">Ottimizza il Numero di Stati</string>
    <string name="menu_fsm_optimize_state_numbers_tt">Ottimizza il numero di stati così che una implementazione abbia il numero minimo di lavoro da effettuare.
        L'esecuzione aumenta molto velocemente con l'aumentare della complessità della macchina (O(n!)).</string>
    <string name="menu_fsm_optimize_state_numbers_err">Errore durante l'ottimizzazione!</string>
    <string name="msg_fsm_optimizer_initial">Complessità iniziale:</string>
    <string name="msg_fsm_optimizer_best">Miglior risultato fino ad ora:</string>
    <string name="msg_fsmHelp">&lt;html&gt;&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;h3&gt;Operazioni col Mouse:&lt;/h3&gt;
  &lt;dl&gt;
    &lt;dt&gt;Crea uno stato:&lt;/dt&gt;
    &lt;dd&gt;Clicca con il tasto destro su un'area libera.&lt;/dd&gt;
    &lt;dt&gt;Creazione di una transizione:&lt;/dt&gt;
    &lt;dd&gt;Premi il tasto destro sull'inizio dello stato e trascinamento verso lo stato di destinazione.&lt;/dd&gt;
    &lt;dt&gt;Eliminazione di uno stato o transizione:&lt;/dt&gt;
    &lt;dd&gt;Sposta il mouse sull'oggetto e premi il tasto [Del].&lt;/dd&gt;
    &lt;dt&gt;Spostare una transizione o stato:&lt;/dt&gt;
    &lt;dd&gt;Premi il tasto sinistro sull'oggetto e trascina.&lt;/dd&gt;
    &lt;dt&gt;Editing a state or a transition:&lt;/dt&gt;
    &lt;dd&gt;Clicca con il tasto destro su una transizione o stato.&lt;/dd&gt;
  &lt;/dl&gt;
  &lt;h3&gt;Funzione di Posizionamento Assistito&lt;/h3&gt;
  &lt;dl&gt;
    &lt;dt&gt;Nessun movimento:&lt;/dt&gt;
    &lt;dd&gt;La funzione di posizionamento assistito è disabilitata.&lt;/dd&gt;
    &lt;dt&gt;Transizioni:&lt;/dt&gt;
    &lt;dd&gt;La funzione sposta le frecce di transizione per evitare sovrapposizioni.&lt;/dd&gt;
    &lt;dt&gt;Transizioni e Stati:&lt;/dt&gt;
    &lt;dd&gt;La funzione sposta le frecce di transizione per evitare sovrapposizioni ed anche gli stati per creare un grafo
      bilanciato.&lt;/dl&gt;
  &lt;h3&gt;Interpretazione delle Transizioni:&lt;/h3&gt;
  Per semplificare la generazione di un automa deterministico, transizioni senza condizioni sono trattate in un modo
  speciale: una transizione senza condizione è eseguita soltanto se nessun'altra transizione soddisfa la condizione
  della transizione.
  Quindi ci può essere sia una transizione con che senza condizione che partono dallo stesso stato.
  Una transizione senza condizione determina quindi in che stato la macchina a stati verrà messa se nessun'altra
  condizione di transizione viene raggiunta.
  Se non ci sono transizioni senza condizione da uno stato, la macchina a stati starà in quello stato fino a quando
  una condizione viene verificata.
&lt;/body&gt;&lt;/html&gt;</string>
    <string name="msg_graphHelpTitle">Il grafico delle misurazioni</string>
    <string name="msg_graphHelp">&lt;html&gt;&lt;body&gt;
        &lt;h3&gt;Cosa può essere mostrato nel grafico?&lt;/h3&gt;
        Al contrario di un vero analizzatore di logica, l'asse X delle misurazioni non mostra il tempo.
        Invece, un contatore è visualizzato che conteggia i cambiamenti di stato nel circuito.
        Quando c'è un cambiamento nello stato, il contanto viene incrementato e il nuovo stato visualizzato.
        Puoi anche pensarla come un analizzatore di logica classico, dove non vengono salvati dati per
        l'ottimizzazione se nulla è cambiato nel circuito.
        Comunque, questo significa anche ch enon è possibile leggere dal grafico fino a quando troppo o troppo poco
        tempo è passato tra due cambiamenti nel circuito.&lt;br/&gt;
        Questo comportamento è causato dalla natura della simulazione: la simulazione del circuito non conosce
        il concetto di tempo. Un cambiamento è applicato sul circuito, il nuovo stato del circuito viene calcolato
        e così via. Questi cambiamenti sono conteggiati e il valore del contatore è mostrato nell'asse X del grafico.&lt;br/&gt;
        Tra l'altro, questo significa anche che su un circuito non può essere fatto overclocking, perché gli effetti del
        fronte di discesa del clock non sono calcolati fino a quando il circuito si è stabilizzato dopo il precedente
        fronte di salita.
        &lt;/body&gt;&lt;/html&gt;</string>
    <string name="tutorial1">In questo breve tutorial capirai come creare il tuo primo circuito:

        Prima, inserisci un ingresso nel circuito. Troverai l'ingresso nel menù Componenti▸IO.</string>
    <string name="tutorial2">Ora aggiungi un secondo ingresso al circuito. Puoi anche cliccare sull'ingresso dalla barra degli strumenti.

        Si ritiene che sia ottimale piazzare il secondo ingresso leggermente sotto il primo.
        Puoi spostare il circuito tenendo premuto il tasto destro del mouse.
        Cliccando sui componenti potrai spostarli.</string>
    <string name="tutorial3">Ora, una porta "XOR" deve essere inserita.
        Puoi trovare questa porta sotto il menù Componenti▸Logica.
        Posiziona questo componente con un po' di distanza dalla destra degli ingressi.</string>
    <string name="tutorial4">L'ultimo componente da inserire è un'uscita.
        Posiziona questo componente con un po' di distanza rispetto alla destra della porta XOR.</string>
    <string name="tutorial5">Per completare il circuito, i cavi di connessione devono essere disegnati.

        Clicca sul punto rosso nel primo ingresso e connettilo all'ingresso della porta XOR,
        cliccando sul punto blu della stessa porta XOR.
        Non trascinare con il bottone del mouse premuto!</string>
    <string name="tutorial6">Connetti il punto rosso del secondo ingresso al secondo punto blu della porta XOR e l'uscita con punto
        rosso della porta XOR all'uscita con punto blu.</string>
    <string name="tutorial7">Il tuo primo circuito è ora funzionale.
        Per avviare la simulazione, puoi cliccare sul pulsante Avvia nella barra degli strumenti.
        Se sposti il cursore sopra la barra, i suggerimenti ti verranno mostrati.</string>
    <string name="tutorial8">La simulazione è ora attiva. Inverti gli ingressi cliccando sopra di essi.</string>
    <string name="tutorial9">Per fermare la simulazione, clicca nel pulsante Interrompi nella barra degli strumenti.</string>
    <string name="tutorial10">Per completezza, gli ingressi e le uscite dovrebbero essere etichettate.

        Fai click destro su un ingresso per aprire la finestra di dialogo. Su macOS, Control-click viene usato.
        Qui l'ingresso può essere nominato.</string>
    <string name="tutorial11">Etichetta tutti gli ingressi ed uscite.</string>
    <string name="tutorialUniqueIdents">Gli ingressi e le uscite devono sempre essere nominati univocamente.</string>
    <string name="tutorialNotNeeded">Salta il tutorial</string>
    <string name="elem_LookUpTable_short">Tabella di ricerca</string>
    <string name="elem_Splitter">Scissione/Divisione</string>
    <string name="elem_RS_FF_AS">Flip-flop RS</string>
    <string name="elem_JK_FF">Flip-flop JK</string>
    <string name="elem_D_FF">Flip-flop D</string>
    <string name="elem_T_FF">Flip-flop D</string>
    <string name="elem_GraphicCard_short">Memoria RAM grafica</string>
    <string name="err_noRomFound">Nessuna memoria del programma trovata! La memoria del programma deve essere etichettata come tale.</string>
    <string name="err_multipleRomsFound">Più di una memoria del programma trovata! Solo la presenza di una memoria è consentita.</string>
    <string name="key_Bits_tt">Numero di bit dati utilizzati.</string>
    <string name="key_OutputSplitting">Divisione dell'uscita</string>
    <string name="key_splitterSpreading">Spargimento</string>
    <string name="key_skipHDL">Salta l'esportazione Verilog/VHDL</string>
    <string name="key_skipHDL_tt">Salta l'esportazione della generazione dei componenti interni al circuito in Verilog/VHDL.
    	I riferimenti ai circuiti sono mantenuti, rendendo possibile la sovrascrittura della loro implementazione.</string>
    <string name="menu_colorSchemePreset">Configurazione preimpostata</string>
    <string name="colorName_TESTCASE">Caso di prova</string>
    <string name="menu_karnaughMap">Mappa di Karnaugh</string>
    <string name="btn_copyToClipboard">Appunti</string>
    <string name="key_defaultsDC">Imposta i valori non definiti a DC</string>
    <string name="key_defaultsDC_tt">Imposta tutti i valori non definiti (seguendo gli stati e le uscite) a "Non importa".</string>
    <string name="btn_openInBrowser">Apri nel browser</string>
    <string name="btn_saveTemplate">Salva template</string>
    <string name="elem_BitExtender_short">Estenditore del segno</string>
    <string name="elem_BitCount_short">Contatore di bit</string>
    <string name="elem_TransGate">Transmission gate</string>
    <string name="key_persistTime">Persistenza della visione</string>
    <string name="key_persistTime_tt">Specifica la durata dell'afterglow. Più grande il valore, più lunga la durata dell'effetto.</string>
    <string name="key_oscillationDetectionCounter">Identificazione dell'oscillazione</string>
    <string name="key_oscillationDetectionCounter_tt">Numero di propagazioni oltre il quale un'oscillazione viene identificata se il circuito non si è ancora stabilizzato.</string>
    <string name="key_openRemotePort">Consenti la connessione remota</string>
    <string name="key_openRemotePort_tt">Se impostato, una porta TCP/IP viene aperta, attraverso la quale è possibile il controllo del simulatore.</string>
    <string name="key_remotePort">Numero della porta</string>
    <string name="key_remotePort_tt">La porta sulla quale il server remoto viene aperto.</string>
    <string name="msg_bigEndian">Big endian</string>
    <string name="key_bigEndian">Usa il big endian durante l'importazione.</string>
    <string name="key_bigEndian_tt">Utilizza l'ordinamento dei byte "big endian" durante l'importazione.</string>
    <string name="menu_table_createCircuitMore">Varianti del Circuito</string>
    <string name="menu_table_maxInputs_N">Utilizza porte con al massimo {0} ingressi</string>
    <string name="menu_presentationMode">Modalità Presentazione</string>
    <string name="menu_presentationMode_tt">Una vista semplificata dove, per esempio, sono omessi i test case, che può essere utile per presentazioni.</string>
    <string name="menu_find">Cerca</string>
    <string name="menu_find_tt">Trova etichette, nomi di reti e numeri di pin</string>
    <string name="menu_calcMaxPathLen">Percorso più Lungo</string>
    <string name="menu_calcMaxPathLen_tt">La lunghezza massima del percorso è il percorso più lungo tra uno degli ingressi ed una delle uscite.</string>
    <string name="msg_maxPathLen">Il percorso più lungo consiste di {0} porte.</string>
    <string name="msg_couldNotCalculateMaxPathLen">Impossibile calcolare il percorso più lungo.</string>
    <string name="key_source">Sorgente di Dati</string>
    <string name="key_source_noData">non caricare nessun dato</string>
    <string name="key_source_dataField">dati salvati</string>
    <string name="err_could_not_load_rom">Impossibile caricare i dati della ROM!</string>
</resources>
