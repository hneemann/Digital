<?xml version="1.0" encoding="UTF-8"?>
<!--  IMPORTANT
Do not edit this file directly!
This makes it very difficult for me to continue to maintain the translation.
The only exception are simple typos.
Pull requests in which this file is modified beyond simple typos cannot be accepted.
In the file howTo.md you can find more details about translations.
--><resources>
    <string name="addr">Endereço</string>
    <string name="tableOfContent">Índice</string>
    <string name="general">Geral</string>
    <string name="revision">Revisão</string>
    <string name="date">Data</string>
    <string name="maxValue">Valor máximo</string>
    <string name="settings">A seguir descrevem-se as configurações disponíveis no simulador.</string>
    <string name="attr_dialogTitle">Atributos</string>
    <string name="attr_openCircuit">Abrir circuito</string>
    <string name="attr_openCircuitLabel">Incluir circuito:</string>
    <string name="attr_openCircuit_tt">Abrir circuito em um nova janela.</string>
    <string name="attr_help">Ajuda</string>
    <string name="attr_help_tt">Mostrar uma breve descrição desse elemento.</string>
    <string name="attr_panel_primary">Básico</string>
    <string name="attr_panel_secondary">Avançado</string>
    <string name="btn_discard">Descartar alterações</string>
    <string name="btn_edit">Editar</string>
    <string name="btn_editFurther">Continuar edição</string>
    <string name="btn_load">Carregar</string>
    <string name="btn_save">Salvar</string>
    <string name="btn_create">Criar</string>
    <string name="btn_create_tt">Criar circuito em janela separada</string>
    <string name="btn_editDetached">Editar em separado</string>
    <string name="btn_editDetached_tt">Abrir diálogo como não modal</string>
    <string name="btn_openInBrowser">Navegador</string>
    <string name="btn_openInBrowser_tt">Abrir texto de ajuda no navegador. Permite-se a impressão do texto.</string>
    <string name="btn_clearData">Limpar</string>
    <string name="btn_clearData_tt">Atribuir zeros a todos os valores!</string>
    <string name="btn_addTransitions">Transições</string>
    <string name="btn_addTransitions_tt">Todas as possíveis transições serão adicionadas como casos de testes. É usada
        para criar casos de testes para o próprio simulador.
    </string>
    <string name="btn_newName">Novo nome</string>
    <string name="btn_saveAnyway">Salvar incondicionalmente</string>
  <string name="btn_overwrite">Substituir</string>
  <string name="btn_apply">Aplicar</string>
  <string name="btn_editRom_tt">Editar o conteúdo da ROM/EEPROM selecionada</string>
  <string name="btn_clearRom_tt">Remover os dados armazenados na ROM selecionada. O conteúdo anterior armazenado na ROM será usado.</string>
  <string name="btn_saveTemplate">Modelo</string>
  <string name="btn_saveTemplate_tt">Criar modelo SVG que possa ser editado pelo Inkscape.</string>
  <string name="btn_loadSvg">Importar</string>
  <string name="btn_loadSvg_tt">Importar arquivo SVG. Para criar arquivo SVG adequado, é mais fácil criar o modelo SVG primeiro, e depois editá-lo.</string>
  <string name="msg_warning">Aviso</string>
  <string name="cancel">Cancelar</string>
  <string name="digital">Digital</string>
  <string name="expression">Expressão</string>
  <string name="elem_Help_inputs">Entradas</string>
  <string name="elem_Help_outputs">Saídas</string>
  <string name="elem_Help_attributes">Atributos</string>
  <!-- logic -->
  <string name="elem_Basic_In">Valor de entrada para a operação lógica em {0}.</string>
  <string name="elem_Basic_Out">Retornar o resultado da operação lógica.</string>
  <string name="elem_And">AND</string>
  <string name="elem_And_tt">Porta AND. Retornará 1 somente se todas as entradas também estiverem em 1.
        É possível usar barramentos com vários bits tanto para entradas quanto para saídas. Nesse caso, serão executados bit-a-bit.
        Isso significa que os bits de menor ordem de todas as entradas estarão conectados à AND e sua saída também será a de menor ordem.
        O mesmo ocorrerá para o bit 1, bit 2 e assim por diante.</string>
  <string name="elem_NAnd">NAND</string>
  <string name="elem_NAnd_tt">Combinação de AND e NOT.
        Retornará 0 somente se todas as entradas estiverem em 1. Se alguma das entradas estiver em 0 a saída irá para 1.
        Também é possível usar barramentos com vários bits para as entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.</string>
  <string name="elem_Or">OR</string>
  <string name="elem_Or_tt">Porta OR. Retornará 1 se alguma das entradas estiver em 1.
        Se todas as entradas estiverem em 0 a saída também irá para 0.
        Também é possível usar barramentos com vários bits tanto para entradas quanto para saídas. Nesse caso, serão executados bit-a-bit.
        Isso significa que os bits de menor ordem de todas as entradas estarão conectados à OR e sua saída também será a de menor ordem.
        O mesmo ocorrerá para o bit 1, bit 2 e assim por diante.</string>
  <string name="elem_NOr">NOR</string>
  <string name="elem_NOr_tt">Combinação de OR e NOT.
        Retornará 0 se alguma das entradas estiver em 1. Se todas as entradas estiverem em 0 a saída irá para 1.
        Também é possível usar barramentos vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.</string>
  <string name="elem_XOr">XOR</string>
  <string name="elem_XOr_tt">Se todas as entradas forem usadas, a saída será 0 para cada par de bits iguais.
        Caso contrário a saída será 1.
        Se mais do que duas entradas forem usadas, se comportará como portas XOR em cascata ( A XOR B XOR C = (A XOR B) XOR C ).
        Também é possível usar barramentos com vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.</string>
  <string name="elem_XNOr">XNOR</string>
  <string name="elem_XNOr_tt">Combinação de XOR e NOT. As entradas serão combinadas pela operação XOR.
        O resultado dessa operação será então invertido.
        Também é possível usar barramentos com vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.</string>
  <string name="elem_Not">NOT</string>
  <string name="elem_Not_tt">Inverterá o valor à entrada. Um valor igual a 1 se tornará 0 e um 0 se tornará 1.
        Também é possível usar barramentos com vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.</string>
  <string name="elem_Not_pin_in">A entrada da porta NOT.</string>
  <string name="elem_Not_pin_out">O valor invertido da entrada.</string>
  <string name="elem_LookUpTable">LookUpTable</string>
  <string name="elem_LookUpTable_short">LUT</string>
  <string name="elem_LookUpTable_tt">Obterá o valor da saída a partir de uma tabela armazenada.
        Dessa forma poderá emular qualquer porta combinatória.</string>
  <string name="elem_LookUpTable_pin_in">Entrada {0}. Essa entrada em combinação com todas as outras definirá o
        endereço do valor armazenado que será retornado.</string>
  <string name="elem_LookUpTable_pin_out">Retornará o valor armazenado no endereço definido pelas entradas.</string>
  <string name="elem_Delay">Atraso</string>
  <string name="elem_Delay_tt">Atrasará o sinal no tempo de propagação.
        Atrasará um sinal por um número de atrasos de porta regulável.
        Todos os outros componentes no simulador têm um atraso de porta no tempo de propagação.
        Esse componente pode ser usado para implementar qualquer atraso de propagação necessário.</string>
  <string name="elem_Delay_pin_in">Entrada do sinal a ser atrasado.</string>
  <string name="elem_Delay_pin_out">O sinal de entrada atrasado pelo tempo correspondente a um atraso de porta.</string>
  <!-- IO -->
  <string name="elem_Out">Saída</string>
  <string name="elem_Out_tt">Pode ser usada para mostrar um sinal de saída do circuito.
        Esse elemento também é usado para conectar um circuito a outro integrado.
        Nesse caso a conexão é bidirecional.
        Também é usado para atribuir um número PIN, se código para CPLD ou FPGA for gerado.</string>
  <string name="elem_Out_pin_in">Este valor é usado para a conexão de saída.</string>
  <string name="elem_LED">LED</string>
  <string name="elem_LED_tt">Um LED pode ser usado para visualizar um valor de saída. Aceita um único bit.
        Acenderá se a entrada estiver em 1.</string>
  <string name="elem_LED_pin_in">Entrada do LED que acenderá se estiver em 1.</string>
  <string name="elem_RGBLED">LED RGB</string>
  <string name="elem_RGBLED_tt">Um LED RGB pode ter sua cor controlada através de três entradas.
        Em cada uma das três entradas, um canal de cor estará ligado.</string>
  <string name="elem_RGBLED_pin_R">O canal da cor vermelha.</string>
  <string name="elem_RGBLED_pin_G">O canal da cor verde.</string>
  <string name="elem_RGBLED_pin_B">O canal da cor azul.</string>
  <string name="elem_PolarityAwareLED">LED com duas conexões.</string>
  <string name="elem_PolarityAwareLED_tt">LED com conexões para o cátodo e o ânodo. O LED acenderá,
        se o ânodo estiver ligado em nível alto e o cátodo estiver ligado em nível baixo.
        Esse LED não poderá ser usado como resistor pull-down. Só servirá como elemento para exibição.
        O resistor representado servirá apenas para simbolizar o equivalente aos necessários resistores em série 
        usados para limitar a corrente.</string>
  <string name="elem_PolarityAwareLED_pin_A">A conexão do ânodo do LED.</string>
  <string name="elem_PolarityAwareLED_pin_C">A conexão do cátodo do LED.</string>
  <string name="elem_In">Entrada</string>
  <string name="elem_In_tt">Poderá ser usado para manipuar interativamente um sinal de entrada em um circuito com o
        mouse. Esse elemento também poderá ser usado para ligar um circuito a outro integrado.
        Nesse caso a conexão é bidirecional.
        Também é usado para atribuir um número PIN, se código para CPLD ou FPGA for gerado.</string>
  <string name="elem_In_pin_out">Fornece o valor ao qual está ligada a essa entrada.</string>
  
  <string name="elem_DipSwitch_tt">Chave DIP que pode ter a saída alta ou baixa.</string>
  <string name="elem_DipSwitch_pin_out">O valor da chave de saída.</string>
  <string name="elem_Clock">Entrada do Clock</string>
  <string name="elem_Clock_tt">Um sinal de clock. É possível controlá-lo por um clock de tempo real.
        Dependendo da complexidade do circuito, a frequência de clock alcançada pode ser menor que a do valor selecionado.
        Se a frequência for maior que 50Hz, a representação gráfica do circuito não será mais atualizada a
        cada ciclo de clock de modo que as cores dos fios também não mais serão atualizadas.
        Se um clock de tempo real não estiver ativado, o elemento poderá ser controlado por clicks do mouse.
        Também é usado para atribuir um número PIN, se código para CPLD ou FPGA for gerado.</string>
  <string name="elem_Clock_pin_C">Alternará entre 0 e 1, de acordo com a frequência selecionado do clock.</string>
  <string name="elem_Button">Botão</string>
  <string name="elem_Button_tt">Botão simples que voltará ao seu estado original quando liberado.</string>
  <string name="elem_Button_pin_out">O sinal de saída do botão.</string>
  <string name="elem_Text">Texto</string>
  <string name="elem_Text_tt">Mostrar um texto no circuito.
        Não afeta a simulação.
        O texto poderá ser alterado pela caixa do diálogo do atributo.</string>
  <string name="elem_Rectangle">Retângulo</string>
  <string name="elem_Rectangle_tt">Mostrarã um retângulo no circuito.
        Isso não afetará a simulação. Se um sinal negativo (-) for usado no cabeçalho, esse será omitido.</string>
  <string name="elem_Probe">Ponta de prova</string>
  <string name="elem_Probe_tt">Valor medido que poderá ser exibido na saída gráfica de dados ou na tabela de medições.
        Esse componente poderá ser usado para observar facilmente valores de circuitos integrados.
        Não afeta a simulação.</string>
  <string name="elem_Probe_pin_in">O valor da medição.</string>
  <!-- IO - more -->
  <string name="elem_LightBulb">Lâmpada</string>
  <string name="elem_LightBulb_tt">Lâmpada com duas conexões. Se houver fluxo de corrente, a lâmpada acenderá!
        A direção da corrente não importa. A lâmpada acenderá quando as entradas tiverem valores diferentes.
        A lâmpada tem funcionamento similar ao da porta XOR.</string>
  <string name="elem_LightBulb_pin_A">Conexão</string>
  <string name="elem_LightBulb_pin_B">Conexão</string>
  <string name="elem_Seven-Seg">Display de 7-Segmentos</string>
  <string name="elem_Seven-Seg_tt">Display de 7-Segmentos, cada segmento possui sua própria entrada de controle.</string>
  <string name="elem_Seven-Seg_pin_a">Essa entrada controlará a linha horizontal superior.</string>
  <string name="elem_Seven-Seg_pin_b">Essa entrada controlará a linha vertical superior direita.</string>
  <string name="elem_Seven-Seg_pin_c">Essa entrada controlará a linha vertical inferior direita.</string>
  <string name="elem_Seven-Seg_pin_d">Essa entrada controlará a linha horizontal inferior.</string>
  <string name="elem_Seven-Seg_pin_e">Essa entrada controlará a linha vertical inferior esquerda.</string>
  <string name="elem_Seven-Seg_pin_f">Essa entrada controlará a linha vertical superior esquerda.</string>
  <string name="elem_Seven-Seg_pin_g">Essa entrada controlará a linha horizontal ao meio.</string>
  <string name="elem_Seven-Seg_pin_dp">Essa entrada controlará o ponto decimal.</string>
  <string name="elem_Seven-Seg_pin_cc">Cátodo comum. Para ligar os LEDs, essa entrada deverá estar em nível baixo.</string>
  <string name="elem_Seven-Seg-Hex">Display de 7-Segmentos Hexadecimal</string>
  <string name="elem_Seven-Seg-Hex_tt">Display de 7-Segmentos com entrada hexadecimal de 4 bits</string>
  <string name="elem_Seven-Seg-Hex_pin_d">O valor dessa entrada será exibido no display.</string>
  <string name="elem_Seven-Seg-Hex_pin_dp">Essa entrada controlará o ponto decimal.</string>
  <string name="elem_SixteenSeg">Display de 16 Segmentos</string>
  <string name="elem_SixteenSeg_tt">A entrada do LED input tem 16 bits que controlarão os segmentos. A segunda entrada controlará o ponto decimal.</string>
  <string name="elem_SixteenSeg_pin_led">Barramento de 16-bits para controlar os LEDs.</string>
  <string name="elem_SixteenSeg_pin_dp">Essa entrada controlará o ponto decimal.</string>
  <string name="elem_LedMatrix">Matriz de LEDs</string>
  <string name="elem_LedMatrix_tt">A matriz de LEDs. Os LEDs serão exibidos em uma janela em separado.
        Os LEDs de uma coluna do display serão controlados por uma palavra de controle. Em outra entrada, a coluna corrente será
      selecionada. Dessa forma um display multiplexado será obtido.
      Os LEDs são capazes de se manter acesos indefinidamente durante a simulação para evitar que o display fique
      piscando.
  </string>
    <string name="elem_LedMatrix_pin_r-data">A fileira de LEDs de uma coluna.
        Cada bit nessa palavra de dados representa o estado da coluna corrente.
    </string>
    <string name="elem_LedMatrix_pin_c-addr">O número da coluna corrente cujo estado estará visível segundo a outra
        entrada.
    </string>
    <string name="elem_Data">Gráfico de dados</string>
    <string name="elem_Data_tt">Mostrará um gráfico dentro do painel de circuito.
        Será possível exibir ciclos completos de clock ou mudanças de portas individuais.
        Não afeta a simulação.
    </string>
    <string name="elem_RotEncoder">Codificador rotativo</string>
    <string name="elem_RotEncoder_tt">Disco giratório com codificador rotativo. Usado para detectar movimentos de
        rotação.
    </string>
    <string name="elem_RotEncoder_pin_A">sinal A do codificador</string>
    <string name="elem_RotEncoder_pin_B">sinal A do codificador</string>
    <string name="elem_Keyboard">Teclado</string>
    <string name="elem_Keyboard_tt">Um teclado poderá ser usado para realizar entrada de texto.
        Esse componente receberá a entrada, a qual poderá ser lida posteriormente.
        Uma janela em separado será aberta para a entrada do texto.
    </string>
    <string name="elem_Keyboard_pin_C">Clock. Quando da borda de subida, o caractere mais antigo será removido do
        buffer.
    </string>
    <string name="elem_Keyboard_pin_en">Se em nível alto, a saída D estará ativa e um caractere estará à saída.
        Isso também habilitará a entrada de clock.
    </string>
    <string name="elem_Keyboard_pin_D">O último caractere digitado, ou zero se nenhum caractere estiver disponível.
        A saída será um caractere Java com 16 bits.
    </string>
    <string name="elem_Keyboard_pin_av">Essa saída indicará que caracteres estarão disponíveis.
        Isso poderá ser usado para chavear uma interrupção.
    </string>
    <string name="elem_Terminal">Terminal</string>
    <string name="elem_Terminal_tt">Será possível escrever caracteres ASCII nesse terminal.
        O terminal abrirá sua própria janela para exibir a saída.
    </string>
    <string name="elem_Terminal_pin_C">Clock. Quando da borda de subida, enviará o valor da entrada para a janela do
        terminal.
    </string>
    <string name="elem_Terminal_pin_D">Os dados a serem escritos no terminal</string>
    <string name="elem_Terminal_pin_en">Um nível alto nessa entrada habilitará o recebimento do clock.</string>
    <string name="elem_MIDI">MIDI</string>
    <string name="elem_MIDI_tt">Usar o sistema MIDI para tocar notas.</string>
    <string name="elem_MIDI_pin_N">Nota</string>
    <string name="elem_MIDI_pin_V">Volume</string>
    <string name="elem_MIDI_pin_OnOff">Se definido, isso se traduzirá no pressionar de uma tecla (key down event),
        caso contrário, isso se traduzirá no liberar de uma tecla (key up event).
    </string>
    <string name="elem_MIDI_pin_en">Habilitar o componente</string>
    <string name="elem_MIDI_pin_PC">Se em nível alto, o valor em N será usado para alterar o programa (instrumento).
    </string>
    <string name="elem_MIDI_pin_C">Clock</string>
    <!-- Wires -->
    <string name="elem_Ground">Terra</string>
    <string name="elem_Ground_tt">Conexão para terra. A saída será sempre igual a zero.</string>
  <string name="elem_Ground_pin_out">Saída sempre retornará 0.</string>
  <string name="elem_VDD">Fonte</string>
  <string name="elem_VDD_tt">Conexão à fonte. A saída será sempre igual a um.</string>
  <string name="elem_VDD_pin_out">Saída sempre retornará 1.</string>
  <string name="elem_Const">Valor constante</string>
  <string name="elem_Const_tt">Componente que retornará um dado valor constante. O valor poderá ser atribuído por caixa de diálogo.</string>
  <string name="elem_Const_pin_out">Retornará o valor constante dado.</string>
  <string name="elem_Tunnel">Túnel</string>
    <string name="elem_Tunnel_tt">Conectará componentes sem fios. Todos os elementos desse tipo, cujos nomes serão os
        mesmos,
        estarão conectados em conjunto. Funcionarão apenas localmente, não sendo possível usá-los em circuitos
        diferentes.
        Túneis sem identificação serão ignorados.
    </string>
  <string name="elem_Tunnel_pin_in">A conexão a um túnel.</string>
  <string name="elem_Splitter">Distribuidor</string>
  <string name="elem_Splitter_tt">Distribuir ou criar um conjunto de fios ou um barramento de dados com mais de um bit.
        Com um barramento será possível, por exemplo, gerar conexões de 16-bits sem ter quer rotear 16 fios individuais.
        Todas as 16 conexões serão reunidas em um único cabo.
        O distribuidor terá uma direção, isso significa que os sinais serão transmitidos em apenas um sentido.</string>
  <string name="elem_Splitter_pin_in">Os bits de entrada {0}.</string>
  <string name="elem_Splitter_pin_in_one">O bit de entrada {0}.</string>
  <string name="elem_Splitter_pin_out">Os bits de saída {0}.</string>
  <string name="elem_Splitter_pin_out_one">O bit de saída {0}.</string>
  <string name="elem_BusSplitter">Distribuidor bidirecional</string>
  <string name="elem_BusSplitter_tt">Poderá ser usado para barramento de dados e simplificará especialmente a construção de 
        módulos de memória em um pacote DIL, assim com a implementação desse tipo de barramento.</string>
  <string name="elem_BusSplitter_pin_OE">Quando definido, o valor no terminal de dados comum D será a saída para os bits
        D[i], se não, os bits D[i] terão como saída o valor D comum.</string>
  <string name="elem_BusSplitter_pin_D">A conexão de dados comum.</string>
  <string name="elem_BusSplitter_pin_D_N">O primeiro bit de dado {0} do barramento do distribuidor.</string>
  <string name="elem_PullUp">Resistor Pull-Up</string>
  <string name="elem_PullUp_tt">Se o circuito estiver em estado de alta impedância, o resistor levará o valor para nível alto.
        Em qualquer outro caso, esse componente não terá efeito.</string>
  <string name="elem_PullUp_pin_out">Um nível alto "fraco".</string>
  <string name="elem_PullDown">Resistor Pull-Down</string>
  <string name="elem_PullDown_tt">Se o circuito estiver em estado de alta impedância, o resistor levará o valor para nível baixo.
        Em qualquer outro caso, esse componente não terá efeito.</string>
  <string name="elem_PullDown_pin_out">Um nível baixo "fraco".</string>
  <string name="elem_Driver">Driver</string>
  <string name="elem_Driver_tt">Um driver poderá ser usado para conectar um sinal a outro fio.
        O driver é controlado pela entrada definida.
        Se o sinal de entrada estiver em nível baixo, a saída estará em estado de alta impedância.
        Se o sinal de saída estiver em nível alto, a saída será definida pelo valor à entrada.</string>
  <string name="elem_Driver_pin_in">O valor de entrada do driver.</string>
  <string name="elem_Driver_pin_sel">Pino para controlar o driver.
        Se sua entrada for 1, a saída terá o valor dado à entrada.
        Se sua entrada for 0, a saída estará em estado de alta impedância.</string>
  <string name="elem_Driver_pin_out">Se a entrada for 1, a saída terá o valor da entrada.
        Se seu valor for 0, a saída estará em estado de alta impedância.</string>
  <string name="elem_DriverInvSel">Driver invertido</string>
  <string name="elem_DriverInvSel_tt">Um driver poderá ser usado para conectar um sinal a outro fio
        O driver é controlado pela entrada definida.
        Se sua entrada estiver em nível alto, a saída estará em estado de alta impedância.
        Se o sinal de saída estiver em nível baixo, a saída será definida pelo valor à entrada.</string>
  <string name="elem_DriverInvSel_pin_in">Valor de entrada do driver.</string>
  <string name="elem_DriverInvSel_pin_sel">Pino para controlar o driver.
        Se sua entrada for 0, a saída terá o valor dado à entrada.
        Se sua entrada for 1, a saída estará em estado de alta impedância.</string>
  <string name="elem_DriverInvSel_pin_out">Se a entrada for 0, a saída terá o valor da entrada.
        Se seu valor for 1, a saída estará em estado de alta impedância.</string>
  <!-- Plexers  -->
  <string name="elem_Multiplexer">Multiplexador</string>
  <string name="elem_Multiplexer_tt">Componente que usará o valor de entrada de seleção para direcionar um dos valor escolhido dentre as entradas para a saída.</string>
  <string name="elem_Multiplexer_input">O valor da primeira entrada do multiplexador {0}.</string>
  <string name="elem_Multiplexer_output">O valor da entrada selecionada.</string>
  <string name="elem_Multiplexer_pin_sel">Essa entrada será usada para selecionar os dados à entrada que serão direcionados para a saída.</string>
  <string name="elem_Demultiplexer">Demultiplexador</string>
  <string name="elem_Demultiplexer_tt">Componente que poderá direcionar um valor de entrada para uma saída escolhida.
        As outras saídas terão o valor padrão definido.</string>
  <string name="elem_Demultiplexer_pin_sel">O pino que seleciona a saída a ser usada.</string>
  <string name="elem_Demultiplexer_pin_in">O valor dessa entrada será dado à saída selecionada.</string>
  <string name="elem_Demultiplexer_output">Primeira saída de dados {0}.</string>
  <string name="elem_Decoder">Decodificador</string>
  <string name="elem_Decoder_tt">Um dos pinos de saída estará em 1, todos as outras saídas estarão em 0.</string>
  <string name="elem_Decoder_output">Saída {0}. essa saída estará em 1 de acordo com a entrada de seleção.</string>
  <string name="elem_Decoder_pin_sel">Essa entrada selecionará a saída.
        A saída selecionda terá o valor igual a 1. Todas as outras saídas serão iguais a 0.</string>
  <string name="elem_BitSelector">Seletor de Bit</string>
  <string name="elem_BitSelector_tt">Seleciona um único bit do barramento de dados.</string>
  <string name="elem_BitSelector_pin_in">O barramento de entrada</string>
  <string name="elem_BitSelector_pin_sel">Essa entrada selecionará o bit</string>
  <string name="elem_BitSelector_pin_out">O bit selecionado.</string>
  <string name="elem_PriorityEncoder">Codificador de prioridade</string>
  <string name="elem_PriorityEncoder_short">Prioridade</string>
  <string name="elem_PriorityEncoder_tt">Se um das entradas estiver definida, a saída será o seu número.
        Se várias entradas estiverem definidas ao mesmo tempo, a saída será igual ao número mais alto.</string>
  <string name="elem_PriorityEncoder_pin_num">Número da entrada definida.</string>
  <string name="elem_PriorityEncoder_pin_any">Se essa saída estiver definida, pelo menos uma das entradas também estará.</string>
  <string name="elem_PriorityEncoder_input">O valor da primeira entrada do codificador de prioridade {0}.</string>
  <!-- flip flops-->
  <string name="elem_RS_FF_AS">Flip-flop SR</string>
  <string name="elem_RS_FF_AS_short">SR</string>
  <string name="elem_RS_FF_AS_tt">Componente que armazenará um único bit.
        Oferece funções para armazenar e limpar determinado bit.
        Se ambas as entradas forem para 1, ambas as saídas também irão para 1.
        Se ambas as entradas forem para 0, ao mesmo tempo, o estado final será aleatório.</string>
  <string name="elem_RS_FF_AS_pin_S">A entrada para armazenar.</string>
  <string name="elem_RS_FF_AS_pin_R">A entrada para limpar.</string>
  <string name="elem_RS_FF_AS_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_RS_FF_AS_pin_~Q">Retornará o inverso do valor armazenado.</string>
  <string name="elem_RS_FF">Flip-flop SR submetido ao clock</string>
  <string name="elem_RS_FF_short">SR</string>
  <string name="elem_RS_FF_tt">Componente que armazenará um único bit.
        Oferece funções para armazenar e limpar determinado bit.
        Se ambas as entradas (S, R) estiverem em nível alto quando da subida do clock, o estado final será aleatório.</string>
  <string name="elem_RS_FF_pin_S">A entrada para armazenar.</string>
  <string name="elem_RS_FF_pin_C">A entrada do clock. A subida do clock inicia o processo de transição.</string>
  <string name="elem_RS_FF_pin_R">A entrada para limpar.</string>
  <string name="elem_RS_FF_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_RS_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
  <string name="elem_JK_FF">Flip-flop JK</string>
  <string name="elem_JK_FF_short">JK</string>
  <string name="elem_JK_FF_tt">Tem a possibilidade para manter (J=K=0), levar para nível alto (J=1, K=0), levar para níve baixo (J=0, K=1) ou trocar (J=K=1) o valor armazenado.
        A mudança de estado ocorrerá somente quando houver uma borda de subida na entrada do clock C.</string>
  <string name="elem_JK_FF_pin_J">A entrada para armazenar no flip-flop.</string>
  <string name="elem_JK_FF_pin_C">A entrada do clock. Uma borda de subida iniciará a transição de estado.</string>
  <string name="elem_JK_FF_pin_K">A entrada para limpar o flip-flop.</string>
  <string name="elem_JK_FF_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_JK_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
  <string name="elem_D_FF">Flip-flop D</string>
  <string name="elem_D_FF_short">D</string>
  <string name="elem_D_FF_tt">Componente que armazenará um único bit.
        O valor presente no pino D será armazenado na subida do clock no pino C.
        A largura de bits poderá ser selecionada, o que permitirá armazenar múltiplos bits.</string>
  <string name="elem_D_FF_pin_D">Entrada para o bit a ser armazenado.</string>
  <string name="elem_D_FF_pin_C">Entrada do clock para armazenar um valor.
        O valor presente no pino D será armazenado na subida do clock nesse pino.</string>
  <string name="elem_D_FF_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_D_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
  <string name="elem_T_FF">Flip-Flop T</string>
  <string name="elem_T_FF_short">T</string>
  <string name="elem_T_FF_tt">Armazenará um único bit. Alternará o valor a cada borda de subida na entrada C.</string>
  <string name="elem_T_FF_pin_T">Habilitará a função de troca.</string>
  <string name="elem_T_FF_pin_C">Entrada de clock. A cada borda de subida, alternará a saída, se a entrada T estiver em 1.</string>
  <string name="elem_T_FF_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_T_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
  <string name="elem_JK_FF_AS">Flip-flop JK, assíncrono</string>
  <string name="elem_JK_FF_AS_short">JK-AS</string>
  <string name="elem_JK_FF_AS_tt">Tem a possibilidade para manter (J=K=0), levar para nível alto (J=1, K=0), levar para níve baixo (J=0, K=1) ou trocar (J=K=1) o valor armazenado.
        A mudança de estado ocorrerá somente quando houver uma borda de subida na entrada do clock C.
        Há duas entradas adicionais para armazenar ou limpar o estado sem a presença de um sinal de clock.</string>
  <string name="elem_JK_FF_AS_pin_J">A entrada para armazenar do flip-flop.</string>
  <string name="elem_JK_FF_AS_pin_C">A entrada do clock. Uma borda de subida iniciará a transição de estado.</string>
  <string name="elem_JK_FF_AS_pin_K">A entrada para limpar o flip-flop.</string>
  <string name="elem_JK_FF_AS_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_JK_FF_AS_pin_~Q">Retornará o inverso do valor armazenado.</string>
  <string name="elem_JK_FF_AS_pin_Set">Habilitação assíncrona. Um valor em nível alto nessa entrada levará a saída para nível alto.</string>
  <string name="elem_JK_FF_AS_pin_Clr">Limpeza assíncrona. Um valor em nível alto nessa entraa levará a saída para nível baixo.</string>
  <string name="elem_D_FF_AS">Flip-flop D, assíncrono</string>
  <string name="elem_D_FF_AS_short">D-AS</string>
  <string name="elem_D_FF_AS_tt">Componente que armazenará um único bit.
        O valor presente no pino D será armazenado na subida do clock no pino C.
        Há duas entradas adicionais para armazenar ou limpar o estado imediatamente sem a presença de um sinal de clock.
        A largura de bits poderá ser selecionada, o que permitirá armazenar múltiplos bits.</string>
  <string name="elem_D_FF_AS_pin_D">Entrada do bit a ser armazenado.</string>
  <string name="elem_D_FF_AS_pin_C">Pino de controle para armazenar um bit.  O valor presente no pino D será armazenado na subida do sinal nesse pino.</string>
  <string name="elem_D_FF_AS_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_D_FF_AS_pin_~Q">Retornará o inverso do valor armazenado</string>
  <string name="elem_D_FF_AS_pin_Set">Habilitação assíncrona. Um valor em nível alto nessa entrada levará a saída para nível alto.</string>
  <string name="elem_D_FF_AS_pin_Clr">Limpeza assíncrona. Um valor em nível alto nessa entrada levará a saída para nível baixo.</string>
  <string name="elem_Monoflop">Monoflop</string>
  <string name="elem_Monoflop_short">Mono</string>
  <string name="elem_Monoflop_tt">O monoflop será determinado na subida da entrada de clock.
        Após um atrado de tempo configurável, o monoflop será limpo automaticamente.
        O monoflop poderá ser gatilhável. Isso somente será utilizado se existir apenas um componente de clock presente no circuito.
        Esse componente de clock será usado como base de tempo para medir os atrasos.</string>
  <string name="elem_Monoflop_pin_R">Entrada para limpar. Um valor em nível alto irá limpar o monoflop.</string>
  <string name="elem_Monoflop_pin_C">A entrada de clock. Uma borda de subida irá engatilhar o monoflop.</string>
  <string name="elem_Monoflop_pin_Q">Saída</string>
  <string name="elem_Monoflop_pin_~Q">Saída invertida</string>
  <!-- Memory -->
  <string name="elem_Register">Registrador</string>
  <string name="elem_Register_short">Reg</string>
  <string name="elem_Register_tt">Componente para armazenar valores. A largura em bits da palavra de dados poderá ser selecionada.
        Diferente do flip-flop D, o registrador possui uma entrada que o habilitará dependendo do clock.</string>
  <string name="elem_Register_pin_D">Entrada da palavra de dados a ser armazenada.</string>
  <string name="elem_Register_pin_C">Entrada de clock. Na borda de subida armazenará o valor presente no pino D.</string>
  <string name="elem_Register_pin_en">Pino para habilitação. O armazenamento do valor funcionará somente se esse pino estiver em nível alto.</string>
  <string name="elem_Register_pin_Q">Retornará o valor armazenado.</string>
  <string name="elem_ROM">ROM</string>
  <string name="elem_ROM_tt">Componente de memória não-volátil.
        Os dados armazenados poderão ser editados por meio da caixa de diálogo de atributos.</string>
  <string name="elem_ROM_pin_A">Este pino definirá o endereço da palavra de dados a ser enviada para a saída.</string>
  <string name="elem_ROM_pin_D">A palavra de dados selecionada se a entrada estiver em nível alto.</string>
  <string name="elem_ROM_pin_sel">Se a entrada estiver em nível alto, a saída será ativada. Se estiver em nível baixo, a saída de dados estará em estado de alta impedância.</string>
  <string name="elem_RAMDualPort">RAM, portas separadas</string>
  <string name="elem_RAMDualPort_short">RAM</string>
  <string name="elem_RAMDualPort_tt">Módulo de RAM com portas separadas para armazenar e prover a saída para de dados armazenados.</string>
  <string name="elem_RAMDualPort_pin_A">Endereço onde ler ou gravar.</string>
  <string name="elem_RAMDualPort_pin_C">Entrada de clock</string>
  <string name="elem_RAMDualPort_pin_Din">Dados a serem armazenados.</string>
  <string name="elem_RAMDualPort_pin_D">Pino para a saída de dados</string>
  <string name="elem_RAMDualPort_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados visíveis.</string>
  <string name="elem_RAMDualPort_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
  <string name="elem_BlockRAMDualPort">RAM-Bloco, portas separadas</string>
  <string name="elem_BlockRAMDualPort_pin_A">Endereço onde ler ou gravar.</string>
  <string name="elem_BlockRAMDualPort_pin_C">Entrada de clock</string>
  <string name="elem_BlockRAMDualPort_pin_D">Pino de saída de dados</string>
  <string name="elem_BlockRAMDualPort_pin_Din">Dados a serem armazenados em RAM.</string>
  <string name="elem_BlockRAMDualPort_pin_str">Se essa entrada estiver em nível alto, quando houver borda de subida do clock,  os dados serão armazenados.</string>
  <string name="elem_BlockRAMDualPort_short">RAM</string>
  <string name="elem_BlockRAMDualPort_tt">Módulo de RAM com entradas separadas para armazenar dados, e saída para se ler os dados armazenados.
        Essa RAM somente atualizará sua saída na borda de subida da entrada de clock.
        Isso permitirá o uso dessa RAM em FPGA.</string>
  <string name="elem_EEPROMDualPort">EEPROM, portas separadas</string>
  <string name="elem_EEPROMDualPort_short">EEPROM</string>
  <string name="elem_EEPROMDualPort_tt">Módulo de EEPROM com portas separadas para armazenar e prover a saída para de dados armazenados.</string>
  <string name="elem_EEPROMDualPort_pin_A">Endereço onde ler ou gravar.</string>
  <string name="elem_EEPROMDualPort_pin_C">Entrada de clock</string>
  <string name="elem_EEPROMDualPort_pin_Din">Dados a serem armazenados</string>
  <string name="elem_EEPROMDualPort_pin_D">Pino para a saída de dados</string>
  <string name="elem_EEPROMDualPort_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados visíveis.</string>
  <string name="elem_EEPROMDualPort_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
  <string name="elem_RAMSinglePort">RAM, porta bidirecional</string>
  <string name="elem_RAMSinglePort_short">RAM</string>
  <string name="elem_RAMSinglePort_tt">Módulo de RAM com pino bidirecional para ler e gravar dados.</string>
  <string name="elem_RAMSinglePort_pin_A">Endereço onde ler ou gravar.</string>
  <string name="elem_RAMSinglePort_pin_C">Entrada de clock</string>
  <string name="elem_RAMSinglePort_pin_D">Conexão de dados bidirecional.</string>
  <string name="elem_RAMSinglePort_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados visíveis.</string>
  <string name="elem_RAMSinglePort_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
  <string name="elem_RAMSinglePortSel">RAM, seleção de chip</string>
  <string name="elem_RAMSinglePortSel_short">RAM</string>
  <string name="elem_RAMSinglePortSel_tt">Módulo de RAM com conexão bidirecional para ler e gravar dados.
        Se a entrada CS estiver em nível baixo, o componente estará desabilitado.
        Isso permitirá a construção de RAM's maiores a partir de módulos menores e um decodificador de endereços.
        O ciclo de escrita funcionará como se segue: ao colocar CS em nível alto, o componente será selecionado.
        Uma borda de subida em WE receberá o endereço, e na próxima borda de descida irá armazenar os dados.</string>
  <string name="elem_RAMSinglePortSel_pin_A">Endereço onde ler ou gravar.</string>
  <string name="elem_RAMSinglePortSel_pin_WE">Se essa entrada estiver em nível alto, os dados serão gravados na RAM.</string>
  <string name="elem_RAMSinglePortSel_pin_D">Conexão de dados bidirectional.</string>
  <string name="elem_RAMSinglePortSel_pin_CS">Se essa entrada estiver em nível alto, essa RAM estará habilitada. De outro modo, a saída estará sempre em estado de alta impedância.</string>
  <string name="elem_RAMSinglePortSel_pin_OE">Se essa entrada estiver em nível alto, o valor armazenado estará disponível na saída.</string>
  <string name="elem_EEPROM">EEPROM</string>
  <string name="elem_EEPROM_tt">Módulo de EEPROM com conexão bidirecional para ler e gravar dados.
        Se a entrada CS estiver em nível baixo, o componente estará desabilitado.
        Os dados estarão armazenados tal como em uma ROM. Estarão assim preservados durante, e após a simulação terminar,
        e quando for reiniciada.
        O ciclo de escrita funcionará como se segue: ao colocar CS em nível alto, o componente será selecionado.
        Uma borda de subida em WE receberá o endereço, e na próxima borda de descida irá armazenar os dados.</string>
  <string name="elem_EEPROM_pin_A">Endereço onde ler ou gravar.</string>
  <string name="elem_EEPROM_pin_WE">Se essa entrada estiver em nível alto, os dados serão escritos na EEPROM.</string>
  <string name="elem_EEPROM_pin_D">Conexão de dados bidirectional.</string>
  <string name="elem_EEPROM_pin_CS">Se essa entrada estiver em nível alto, essa EEPROM estará habilitada. De outro modo, a saída estará sempre em estado de alta impedância.</string>
  <string name="elem_EEPROM_pin_OE">Se essa entrada estiver em nível alto, o valor armazenado estará disponível na saída.</string>
  <string name="elem_GraphicCard">RAM gráfica</string>
  <string name="elem_GraphicCard_short">Gr-RAM</string>
  <string name="elem_GraphicCard_tt">Usada para exibir gráficos bitmap. Tem comportamento semelhante a de uma. Além disso, 
        exibirá seu conteúdo em ua janela gráfica. Cada pixel será representado por um endereço de memória. O valor armazenado definirá 
        a cor do pixel, a partir de uma paleta de cores fixa. Haverá dois buffers de tela implementados para dar suporte à mudança de páginas.
        A entrada B selecionará o buffer a ser exibido. Assim, o tamanho total da memória será dx * dy * 2 palavras.</string>
  <string name="elem_GraphicCard_pin_A">Endereço onde ler ou gravar.</string>
  <string name="elem_GraphicCard_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
  <string name="elem_GraphicCard_pin_C">Clock</string>
  <string name="elem_GraphicCard_pin_ld">Se essa entrada estiver em nível alto, os dados armazenados estarão disponíveis na saída.</string>
  <string name="elem_GraphicCard_pin_B">Selecionará o buffer de tela a ser exibido.</string>
  <string name="elem_GraphicCard_pin_D">Conexão de dados bidirectional.</string>
  <string name="elem_RAMDualAccess">RAM, duas portas</string>
  <string name="elem_RAMDualAccess_short">RAM</string>
  <string name="elem_RAMDualAccess_tt">RAM com uma porta que permitirá leitura e gravação, e uma outra porta
        onde apenas a leitura é permitida.
        A segunda porta pdoerá ser usada para dar a alguma lógica envolvendo parte gráfica acesso aos conteúdos de memória. Dessa maneira, o processador
        poderá escrever na RAM, enquanto a parte gráfica poderá ler da mesma simultaneamente.</string>
  <string name="elem_RAMDualAccess_pin_1D">Porta de saída 1</string>
  <string name="elem_RAMDualAccess_pin_2D">Porta de saída  2</string>
  <string name="elem_RAMDualAccess_pin_1A">Endereço onde a porta 1 irá ler ou gravar.</string>
  <string name="elem_RAMDualAccess_pin_2A">Endereço onde a porta 2 irá acessar para ler .</string>
  <string name="elem_RAMDualAccess_pin_C">Clock</string>
  <string name="elem_RAMDualAccess_pin_1Din">Dados a serem armazenados na RAM.</string>
  <string name="elem_RAMDualAccess_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados estarão visíveis em 1D.</string>
  <string name="elem_RAMDualAccess_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
  <string name="elem_RegisterFile">Bloco de registradores</string>
  <string name="elem_RegisterFile_short">Registrador</string>
  <string name="elem_RegisterFile_tt">Memória com uma porta que permitirá a gravação e duas portas que permitirão leituras simultâneas
        Poderá ser usada para implementar registradores em um processador.
        Dois registradores poderão ser lidos simultaneamente, enquanto um terceiro poderá ser escrito.</string>
  <string name="elem_RegisterFile_pin_Da">Porta de saída (a)</string>
  <string name="elem_RegisterFile_pin_Db">Porta de saída (b)</string>
  <string name="elem_RegisterFile_pin_Ra">Registrador visível à porta (a).</string>
  <string name="elem_RegisterFile_pin_Rb">Registrador visível à porta (b).</string>
  <string name="elem_RegisterFile_pin_Rw">Registrador no qual os dados serão escritos.</string>
  <string name="elem_RegisterFile_pin_we">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
  <string name="elem_RegisterFile_pin_C">Clock</string>
  <string name="elem_RegisterFile_pin_Din">Dados a serem armazenados no registrador Rw.</string>
  <string name="elem_Counter">Contador</string>
  <string name="elem_Counter_short">Contador</string>
  <string name="elem_Counter_tt">Componente que funcionará como contador simples. Dependendo da entrada de clock, será incrementado.
        Poderá retornar a zeor mediante udo da entrada clr.
        A largura de bits poderá ser determinada por uma caixa de diálogo de atributos.</string>
  <string name="elem_Counter_pin_C">Entrada de clock. Quando da borda de subida, incrementará o contador.</string>
  <string name="elem_Counter_pin_clr">Limpeza síncrona do contador se igual a 1.</string>
  <string name="elem_Counter_pin_out">Retornará o valor contado.</string>
  <string name="elem_Counter_pin_ovf">Transbordamento de saída (overflow). Esse pino será igual a 1 se o contador exceder seu valor máximo
        e a entrada en estiver em 1.</string>
  <string name="elem_Counter_pin_en">Se estiver em 1, o contador estará habilitado!</string>
  <string name="elem_CounterPreset">Contador com preset</string>
  <string name="elem_CounterPreset_tt">Contador com valor que poderá ser pré-estabelecido. Além disso, o valor máximo e a direção de contagem também poderão ser especificados.</string>
  <string name="elem_CounterPreset_short">Contador</string>
  <string name="elem_CounterPreset_pin_out">Retornará o valor contado.</string>
  <string name="elem_CounterPreset_pin_ovf">Saída de transbordamento (overflow output). Se estiver em 1, e a entrada en estiver em 1 e se o 
    contador alcançar seu valor máximo quando estiver sendo incrementado, ou quando atingir 0 ao ser decrementado.</string>
  <string name="elem_CounterPreset_pin_C">A entrada de clock. Quando da borda de subida, incrementará o contador.</string>
  <string name="elem_CounterPreset_pin_clr">Limpeza síncrona do contador se igual a 1.</string>
  <string name="elem_CounterPreset_pin_en">Se estiver em 1, o contador estará habilitado!</string>
  <string name="elem_CounterPreset_pin_dir">Especificará a direção de contagem. Se for 0 será para cima.</string>
  <string name="elem_CounterPreset_pin_ld">Se habilitado, o valor na entrada in será armazenado no contador no próximo sinal do clock.</string>
  <string name="elem_CounterPreset_pin_in">Palavra de dados a ser armazenada no contador quando (ld)  for habilitado.</string>
  <!--Arithmetic -->
  <string name="elem_Add">Somar</string>
  <string name="elem_Add_short">Soma</string>
  <string name="elem_Add_tt">Componente para realizar uma soma simples.
        Somará dois valores inteiros (a+b) presentes nas entradas (a) e (b).
        O resultado será incrementado em uma unidade se a entrada de carry estiver em nível alto.</string>
  <string name="elem_Add_pin_a">Primeira entrada para somar.</string>
  <string name="elem_Add_pin_b">Segunda entrada para somar.</string>
  <string name="elem_Add_pin_c_i">Entrada para carry-in, se estiver em nível alto, irá incrementar uma unidade.</string>
  <string name="elem_Add_pin_s">O resultado da soma</string>
  <string name="elem_Add_pin_c_o">Saída carry-out. Estará em nível ato se houver transbordamento (overflow).</string>
  <string name="elem_Sub">Subtrair</string>
  <string name="elem_Sub_short">Sub</string>
  <string name="elem_Sub_tt">Componente para realizar uma subtração simples.
        Subtrairá dois valores inteiros (a-b) presentes nas entradas (a) e (b).
        O resultado será decrementado em uma unidade se a entrada de carry estiver em nível alto.</string>
  <string name="elem_Sub_pin_c_i">Entrada para carry-in, se estiver em nível alto, irá decrementar de uma unidade.</string>
  <string name="elem_Sub_pin_a">Primeira entrada para subtrair.</string>
  <string name="elem_Sub_pin_b">Segunda entrada para subtrair.</string>
  <string name="elem_Sub_pin_s">O resultado da subtração.</string>
  <string name="elem_Sub_pin_c_o">Saída carry-out. Estará em nível alto se houver transbordamento (overflow).</string>
  <string name="elem_Mul">Multiplicar</string>
  <string name="elem_Mul_short">Mul</string>
  <string name="elem_Mul_tt">Componente para realizar uma multiplicação.
       Multiplicará dois valores inteiros (a*b) presentes nas entradas (a) e (b).</string>
  <string name="elem_Mul_pin_a">Primeira entrada para multiplicar.</string>
  <string name="elem_Mul_pin_b">Segunda entrada para multiplicar.</string>
  <string name="elem_Mul_pin_mul">O resultado da multiplicação.</string>
  <string name="elem_Div">Dividir</string>
  <string name="elem_Div_short">Div</string>
  <string name="elem_Div_tt">Componente para realizar uma divisão.
        Dividirá um valor inteiro por outro (a/b), ambos presentes nas entradas (a) e (b).
        Se o divisor for zero, o valor igual a 1 será usado no lugar.
        Em se tratando de divisão com sinal, o resto será sempre positivo.</string>
  <string name="elem_Div_pin_a">dividendo</string>
  <string name="elem_Div_pin_b">divisor</string>
  <string name="elem_Div_pin_q">quociente</string>
  <string name="elem_Div_pin_r">resto</string>
  <string name="elem_BarrelShifter">Registrador de deslocamento</string>
  <string name="elem_BarrelShifter_short">deslocar</string>
  <string name="elem_BarrelShifter_tt">Componente para deslocamento de bits.
        Deslocará o valor na entrada por certo número de bits presente à entrada.</string>
  <string name="elem_BarrelShifter_pin_in">Entrada com os bits a serem deslocados.</string>
  <string name="elem_BarrelShifter_pin_shift">Entrada com a largura a ser deslocada.</string>
  <string name="elem_BarrelShifter_pin_out">Saída com o valor deslocado.</string>
  <string name="elem_Comparator">Comparador</string>
  <string name="elem_Comparator_tt">Componente para comparar valores bit a bit.
        Irá comparar dois valores (a) e (b) presentes às entradas e compor as saídas correspondentes.</string>
  <string name="elem_Comparator_pin_a">Entrada (a) para comparar.</string>
  <string name="elem_Comparator_pin_b">Entrada (b) para comparar.</string>
  <string name="elem_Comparator_pin_=">Saída com o valor 1, se (a) igual a (b)</string>
  <string name="elem_Comparator_pin_&gt;">Saída com o valor igual a 1, se a entrada (a) for maior que (b)</string>
  <string name="elem_Comparator_pin_&lt;">Saída com o valor igual a 1, se a entrada (a) for menor que (b)</string>
  <string name="elem_Neg">Negação</string>
  <string name="elem_Neg_short">Neg</string>
  <string name="elem_Neg_tt">Complemento de 2</string>
  <string name="elem_Neg_pin_in">Entrada da palavra de dados a qual será aplicada o complemento de 2</string>
  <string name="elem_Neg_pin_out">Retornará o resultado da negação em complemento de 2.</string>
  <string name="elem_BitExtender">Extensor de sinal</string>
  <string name="elem_BitExtender_short">SinalEx</string>
  <string name="elem_BitExtender_tt">Incrementará a larguram em bits de um valor com sinal mantendo seu valor.
        Se a entrada for de um único bit, esse valor será disponível em todos os bits da saída.</string>
  <string name="elem_BitExtender_pin_in">Valor da entrada.
        A largura em bits da entrada que deverá ser menor que a largura em bits da saída!</string>
  <string name="elem_BitExtender_pin_out">Valor da entrada estendida.
        A largura em bits da entrada que deverá ser menor que a largura em bits da saída!</string>
  <string name="elem_BitCount">Contador de bits</string>
  <string name="elem_BitCount_short">ContaBits</string>
  <string name="elem_BitCount_tt">Retornará o número de bits iguais a 1 presentes no valor à entrada.</string>
  <string name="elem_BitCount_pin_in">Entrada para se contar os valores iguais a 1.</string>
  <string name="elem_BitCount_pin_out">Saída com a quantidade de valores iguais a 1.</string>
  <!-- Switches -->
  <string name="elem_DiodeForward">Diodo para  VDD</string>
  <string name="elem_DiodeForward_tt">Simples diodo unidirecional, usado para levar uma conexão para VDD.
        É usada para implementar uma OR de fios.
        Para isso é necessário conectar um resistor de pull down à saída do diodo.
        Na simulação o diodo se comportará como uma porta ativa com uma tabela-verdade trivalente:
        se a entrada estiver em nível alto, a saída também estará. Em todos os outros casos (entrada em nível baixo ou em alta impedância) a saída estará estado de alta impedância.
        De modo que dois diodos anti-paralelos poderão manter-se em nível alto, o que não seria possível com diodos reais.
        Esse é um diodo ideal: não haverá queda de tensão através de um diodo polarizado diretamente.</string>
  <string name="elem_DiodeForward_pin_in">Se a entrada estiver em nível alto, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
  <string name="elem_DiodeForward_pin_out">Se a entrada estiver em nível alto, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
  <string name="elem_DiodeBackward">Diode para Terra</string>
  <string name="elem_DiodeBackward_tt">Simples diodo unidirecional, usado para levar uma conexão para VDD. 
        É usada para implementar uma AND de fios.
        Para isso é necessário conectar um resistor de pull up à saída do diodo.
        Se a entrada estiver em nível baixo, a saída também estará. Em todos os outros casos (entrada em nível baixo ou em alta impedância) a saída estará estado de alta impedância.
        De modo que dois diodos anti-paralelos poderão manter-se em nível baixo, o que não seria possível com diodos reais.
        Esse é um diodo ideal: não haverá queda de tensão através de um diodo polarizado diretamente.</string>
  <string name="elem_DiodeBackward_pin_in">Se a entrada estiver em nível baixo, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
  <string name="elem_DiodeBackward_pin_out">Se a entrada estiver em nível baixo, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
  <string name="elem_Switch">Chave</string>
  <string name="elem_Switch_tt">Interruptor simples.
        Não haverá atraso. Uma mudança de sinal irá propagar imediatamente.</string>
  <string name="elem_Switch_pin">Um das conexões da chave.</string>
  <string name="elem_SwitchDT">Chave de dois polos</string>
  <string name="elem_SwitchDT_tt">Chave de dois polos.
        Não haverá atraso. Uma mudança de sinal irá propagar imediatamente.</string>
  <string name="elem_Fuse">Fusível</string>
  <string name="elem_Fuse_tt">Fusível usado para construir uma memória programável uma única vez.</string>
  <string name="elem_Fuse_pin_out1">Um das conexões do fusível.</string>
  <string name="elem_Fuse_pin_out2">Um das conexões do fusível.</string>
  <string name="elem_Relay">Relé</string>
  <string name="elem_Relay_tt">Relé é uma chave que pode ser controlada por uma bobina.
        Se uma corrente fluir pela bobina, a chave fechará ou abrirá.
        Não haverá diodo de flyback de modo que an direção da corrente não será relevante.
        A chave atuará se as entradas tiverem valores diferentes.
        O relé se comportará de forma semelhante à porta XOR.</string>
  <string name="elem_Relay_pin_in1">Uma das entradas para controle do relé.</string>
  <string name="elem_Relay_pin_in2">Uma das entradas para controle do relé.</string>
  <string name="elem_RelayDT">Relé de dois polos</string>
  <string name="elem_RelayDT_tt">Relé é uma chave que pode ser controlada por uma bobina.
        Se uma corrente fluir pela bobina, a chave fechará ou abrirá.
        Não haverá diodo de flyback de modo que an direção da corrente não será relevante.
        A chave atuará se as entradas tiverem valores diferentes.
        O relé terá comportamento similar à porta XOR.</string>
  <string name="elem_RelayDT_pin_in1">Uma das entradas para controle do relé.</string>
  <string name="elem_RelayDT_pin_in2">Uma das entradas para controle do relé.</string>
  <string name="elem_PFET">FET tipo P</string>
  <string name="elem_PFET_tt">Transistor de efeito de campo tipo P.
        A base será conectada à referência de tensão positiva e o transistor será simulado sem um diodo interno.</string>
  <string name="elem_PFET_pin_G">Porta</string>
  <string name="elem_PFET_pin_S">Fonte</string>
  <string name="elem_PFET_pin_D">Dreno</string>
  <string name="elem_NFET">FET tipol N</string>
  <string name="elem_NFET_tt">Transistor de efeito de campo tipo N.
        A base será conectada à terra e o transistor será simulado sem um diodo interno.</string>
  <string name="elem_NFET_pin_G">Porta</string>
  <string name="elem_NFET_pin_S">Fonte</string>
  <string name="elem_NFET_pin_D">Dreno</string>
  <string name="elem_FGPFET">FET tipo P com porta flutuante</string>
  <string name="elem_FGPFET_tt">Transistor de efeito de campo tipo P com porta flutuante.
        A base será conectada à terra e o transistor será simulado sem um diodo interno.
        Se houver uma carga armazenada na porta flutuante, o transistor não conduzirá, mesmo se a porta estiver em nível baixo.</string>
  <string name="elem_FGPFET_pin_G">Porta</string>
  <string name="elem_FGPFET_pin_S">Fonte</string>
  <string name="elem_FGPFET_pin_D">Dreino</string>
  <string name="elem_FGNFET">FET tipo N com porta flutuante</string>
  <string name="elem_FGNFET_tt">Transistor de efeito de campo tipo N com porta flutuante.
        A base será conectada à terra e o transistor será simulado sem um diodo interno.
        Se houver uma carga armazenada na porta flutuante, o transistor não estará conduzindo ainda que a porta esteja em nível alto.</string>
  <string name="elem_FGNFET_pin_G">Porta</string>
  <string name="elem_FGNFET_pin_S">Fonte</string>
  <string name="elem_FGNFET_pin_D">Dreno</string>
  <string name="elem_TransGate">Porta de transmissão</string>
  <string name="elem_TransGate_tt">Uma porta de transmissão real é construída com apenas dois transistores.
        Por isso é frequentemente usada para se economizar transistores quando da implementação em silício.</string>
  <string name="elem_TransGate_pin_A">entrada A</string>
  <string name="elem_TransGate_pin_B">entrada B</string>
  <string name="elem_TransGate_pin_S">entrada de controle</string>
  <string name="elem_TransGate_pin_~S">entrada de controle invertida</string>
  <!-- Misc -->
  <string name="elem_Testcase">Caso de teste</string>
  <string name="elem_Testcase_tt">Descrever um caso de teste.
        Em um teste de caso será possível descrever o comportamento de um circuito. Isso poderá ser automaticamente verificado, ou seja,
        se o comportamento realmente corresponde à descrição, ou não, e assim sendo, uma mensagem de erro será mostrada.</string>
  <string name="elem_AsyncSeq">Temporização assíncrona</string>
  <string name="elem_AsyncSeq_tt">Será permitido a temporização de um circuito sequencial assíncrono, tal como um pipeline de Muller.
        O circuito deverá ser iniciado em modo de passo único e deverá alcançar um estado estável logo ao iniciar-se.
        O circuito poderá ser então iniciado interativamente ou mediante uma porta de reinicialização.
        Não é permitido usar um componente de clock comum nesse modo.</string>
  <string name="elem_PowerSupply">Fonte</string>
  <string name="elem_PowerSupply_tt">Não possui qualquer função. Garante que a alimentação (VDD) e o terra (GND) estarão conectados.
        Poderá ser usada em circuitos 74xx para ligar os pinos de alimentação, e assim testar se corretamente conectados.</string>
  <string name="elem_PowerSupply_pin_VDD">Deverá ser conectada à fonte de alimentação (VDD)!</string>
  <string name="elem_PowerSupply_pin_GND">Deverá ser conectado ao terra (GND)!</string>
  <string name="elem_Reset">Reiniciar</string>
  <string name="elem_Reset_pin_Reset">Saída de reinicialização.</string>
  <string name="elem_Reset_tt">A saída desse componente será mantida em nível alto durante a inicialização do circuito.
        Após o circutio se estabilizar, a saída irá para o nível baixo.
        Se a saída for invertida, irá se comportar de forma oposta.</string>
  <string name="elem_Break">Pausa</string>
  <string name="elem_Break_pin_brk">Irá suspender uma simulação rapidamente se uma borda de subida for detectada.</string>
  <string name="elem_Break_tt">Se esse componente for usado em um circuito, o botão "Run To Break" entre "Start" e "Stop"
        estará habilitado. Esse botão irá o clock para o circuito até uma borda de subida na entrada do componente
        ser detectada. Esse elemento poderá ser usado para depuração ao prover o clock ao circuito em qualquer 
        ponto de parada (breakpoint).
        Poderá ser usado também para implementar uma instrução BRK em linguagem de montagem (assembly).
        Será possível simular um processador e interromper sua execução quando a instrução BRK for alcançada.
        O clock de avanço rápido somente poderá ser usado se o clock de tempo real estiver desabilitado.</string>
  <string name="elem_External">Externo</string>
  <string name="elem_External_tt">Componente que executará um processo externo para calcular uma função lógica.
        Será usado para especificar o comportamento de um componente mediante VHDL ou Verilog.
        Até o momento apenas os simuladores ghdl (VHDL) e Icarus Verilog têm suporte.
        A identificação do componente deverá coincidir com o nome da entidade ou módulo!</string>
  <string name="elem_Diode">Diodo</string>
  <string name="elem_Diode_tt">Diodo bidirecional simples. Servirá para implementar uma AND ou OR em fios.
        Corresponderá a um diodo ideal. não haverá queda de tensão caso o diodo estiver diretamente polarizado.</string>
  <string name="error">Erro</string>
  <string name="err_N_isNotInputOrOutput">Pino {0} no componente {1} não é uma entrada ou saída</string>
  <string name="err_aSingleClockNecessary">Um componente de clock comum é necessário. Todos os flip-flops devem ter esse sinal de clock.</string>
  <string name="err_analyseNoInputs">O circuito não possui entradas rotuladas</string>
  <string name="err_analyseNoOutputs">O circuito não possui saídas rotuladas</string>
  <string name="err_breakTimeOut">Nenhuma interrupção detectada após {0} ciclos no ponto de parada "{1}".
        Possivelmente o número de ciclos de timeout no componente sujeito a interrupção deverá ser aumentado.</string>
  <string name="err_builder_exprNotSupported">Expressão {0} não tem suporte</string>
  <string name="err_builder_operationNotSupported">Operação {0} sem suporte</string>
  <string name="err_builder_couldNotFillLUT">Erro ao criar a LUT (LookUp Table).</string>
  <string name="err_burnError">Mais do que uma saída ativa em um fio, causando curto-circuito.</string>
  <string name="err_pullUpAndDown">Não é permitido conectar resistor de pull-up e pull-down à mesma rede.</string>
  <string name="err_cannotAnalyse_N">Não é possível analizar o nodo {0}</string>
  <string name="err_containsVarAndNotVar">Contém [var] e [not var]</string>
  <string name="err_duplicatePinLabel">Pino ''{0}'' no componente ''{1}'' está duplicado.</string>
  <string name="err_element_N_notFound">Componente {0} não encontrado</string>
  <string name="err_exact_N0_valuesNecessaryNot_N1">Valor exato {0} necessário, e não {1}</string>
  <string name="err_ffNeedsToBeConnectedToClock">Flip-flop deve ser conectado ao sinal de clock.</string>
  <string name="err_invalidFileFormat">Formato de arquivo inválido</string>
  <string name="err_isAlreadyInitialized">A lógica já está inicializada</string>
  <string name="err_labelNotConnectedToNet_N">Um túnel {0} não está conectado!</string>
  <string name="err_moreThanOneClockFound">Há mais de um clock</string>
  <string name="err_needs_N0_bits_found_N2_bits">Necessários {0} bits, mas {1} bits encontrados</string>
  <string name="err_netOfPin_N_notFound">A rede de pino {0} não encontrada</string>
  <string name="err_noClockFound">Nenhum clock encontrado</string>
  <string name="err_noInputsAvailable">Nenhuma entrada disponível</string>
  <string name="err_noShapeFoundFor_N">Nenhum formato encontrado para o componente {0}</string>
  <string name="err_noValueSetFor_N0_atElement_N1">Nenhuma conexão na entrada ''{0}'' do componente ''{1}''. Entradas abertas não são permitidas.</string>
  <string name="err_notAllOutputsSameBits">Nem todas as saídas têm a mesma largura de bits</string>
  <string name="err_notAllOutputsSupportHighZ">Se múltiplas saídas estiverem conectadas, todas  deverão ser saídas tri-state.</string>
  <string name="err_noOutConnectedToWire">Nenhuma saída conectada ao fio ({0}). O estado do fio está indefinido.</string>
  <string name="err_oneResultIsRequired">Tabela sem valor. Pelo menos um resultado é requerido!</string>
  <string name="err_output_N_notDefined">Saída {0} não definida</string>
  <string name="err_pinMap_NoNameForPin_N">Nenhum rótulo para o pino {0}</string>
  <string name="err_pinMap_Pin_N_AssignedTwicePin">Pino {0} com dupla atribuição!</string>
  <string name="err_pinMap_noEqualsfound">Nenhum  = encontrado!</string>
  <string name="err_pinMap_pin_N0_isNotAnInput">Pino {0} não é de entrada!</string>
  <string name="err_pinMap_pin_N0_isNotAnOutput">Pino {0} não é de saída!</string>
  <string name="err_pinMap_toMannyInputsDefined">Entradas demais em uso!</string>
  <string name="err_pinMap_toMannyOutputsDefined">Saídas demais em uso!</string>
  <string name="err_pinNotPresent">Pino ausente</string>
  <string name="err_pinWithoutName">Encontrado um pino sem rótulo.</string>
  <string name="err_clockWithoutName">Encontrado um clock sem rótulo. Se houver um clocl integrado, esse deverá ter um rótulo.</string>
  <string name="err_pin_N0_atElement_N1_notFound">Pino {0} nãp encontrado no componente {1}</string>
  <string name="err_pin_N_notFound">Pino {0} não encontrado</string>
  <string name="err_pin_N_unknown">Pino {0} desconhecido</string>
  <string name="err_seemsToOscillate">Oscilação aparente.
        Melhor analizar a execução do circuito no modo de execução passo-a-passo.</string>
  <string name="err_portIsInUse">A porta remota está em uso! Há outra instância em execução?</string>
  <string name="err_selectorInputCountMismatch">Número de entradas não coincide com a largura em bits do seletor</string>
  <string name="err_spitterDefSyntaxError">Erro de sintaxe na definição do distribuidor {0}</string>
  <string name="err_splitterBitsMismatch">A largura em bits do distribuidor não coincide</string>
  <string name="err_splitterNotAllBitsDefined">Nem todos os bits de entrada estão definidos!</string>
  <string name="err_splitterNotUnambiguously">Bits de entrada definidos várias vezes!</string>
  <string name="err_spitterToManyBits">Somente são permitidos 64 bits no distribuidor!</string>
  <string name="err_tableBecomesToSmall">Duas entradas requeridas!</string>
  <string name="err_toManyInputs_max_N0_is_N1">Variáveis demais (entradas+flip-flops), são permitidas {0} mas {1} foram encontradas.</string>
  <string name="err_toManyInputsIn_N0_max_N1_is_N2">Variáveis demais usadas em {0},
        são permitidas {1}, mas {2} foram encontradas.</string>
  <string name="err_varNotAllowedInCUPL_N">Variável {0} não permitida em fonte CUPL!</string>
  <string name="err_varNotDefined_N">Variável {0} não definida</string>
  <string name="err_parserUnexpectedToken_N">Token {0} inesperado</string>
  <string name="err_parserMissingClosedParenthesis">Falta fechar parênteses</string>
  <string name="err_notANumber_N0_inLine_N1">Valor {0} na linha {1} não é um número!</string>
  <string name="err_testDataExpected_N0_found_N1_numbersInLine_N2">Valor esperado {0}, mas encontrado {1} na linha {2}!</string>
  <string name="err_unexpectedToken_N0_inLine_N1">Token inesperado ({0}) na linha {1}.</string>
  <string name="err_variable_N0_notFound">Variável {0} não encontrada!</string>
  <string name="err_noTestInputSignalsDefined">Nenhum sinal de entrada definido no arranjo de testes!</string>
  <string name="err_noTestOutputSignalsDefined">Nenhum sinal de saída definido no arranjo de testes!</string>
  <string name="err_noTestData">Não há dados para testes.</string>
  <string name="err_pullUpAndDownNotAllowed">Não é permitido conectar um resistor de pull up e pull down ao mesmo fio.</string>
  <string name="err_openingDocumentation">Não foi possível abrir o navegador.</string>
  <string name="err_couldNotCreateFolder_N0">Não foi possível criar a pasta {0}!</string>
  <string name="err_switchHasNoNet">Não é permitido conectar apenas entradas a uma chave.</string>
  <string name="err_file_N0_ExistsTwiceBelow_N1">O arquivo {0} existe várias vezes abaixo {1}.</string>
  <string name="err_couldNotFindIncludedFile_N0">Não foi possível encontrar o arquivo {0}.</string>
  <string name="err_postProcessErrorIn_N0">Erro durante a execução de {0}.</string>
  <string name="err_processDoesNotTerminate_N">O processo {0} não tem retorno!</string>
  <string name="err_processExitedWithError_N1_N2">O processo retorna um valor diferente de zero {0}: {1}</string>
  <string name="err_errorRunningFitter">Erro ao iniciar o instalador externo!</string>
  <string name="err_noExpressionsAvailable">Não há equações mínimas!</string>
  <string name="err_varName_N_UsedTwice">A variável {0} está duplicada!</string>
  <string name="err_fileNeedsToBeSaved">O arquivo precisa ser salvo!</string>
  <string name="err_recursiveNestingAt_N0">O circuito {0} importa a si mesmo!</string>
  <string name="err_minimizationFailed">O resultado da minimização não está correto.!
        Os nomes das variáveis podem não ser únicos.</string>
  <string name="err_toManyIterations">Iterações demais em uma repetição.</string>
  <string name="err_diodeNeedsPullUpResistorAtOutput">Diodo requer resistores de pull up em todoas as suas saídas!</string>
  <string name="err_diodeNeedsPullDownResistorAtOutput">Diodo requer resistores de pull down em todas as suas saídas!</string>
  <string name="err_testSignal_N_notFound">Sinal de teste {0} não encontrado no circuito!</string>
  <string name="err_toManyBits_Found_N0_maxIs_N1">Somente permitidos {1} bits, mas {0} foram encontrados!</string>
  <string name="err_MultiBitFlipFlopFound">Flip-flops para mais de um bit não são permitidos!</string>
  <string name="err_invalidTransmissionGateState">As duas entradas de controle de uma porta de transmissão devem ser invertidas!</string>
  <string name="err_nameUsedTwice_N">O sinal {0} está duplicado!</string>
  <string name="err_errorParsingTestdata">Erro durante a varredura dos dados para testes.</string>
  <string name="err_backtrackOf_N_isImpossible">O componente modelo {0} não pode ser analisado.</string>
  <string name="err_errorInPowerSupply">Erro ao conectar uma fonte de alimentação a {0}.</string>
  <string name="err_pinIsNotANumber_N">O número do pino {0} não é inteiro!</string>
  <string name="err_vhdlExporting">Erro ao exportar para VHDL.</string>
  <string name="err_vhdlNoEntity_N">Nenhum código VHDL disponível para {0}!</string>
  <string name="err_verilogNoElement_N">Nenhum código Verilog disponível para {0}!</string>
  <string name="err_vhdlErrorWritingTestBench">Erro ao criar os casos de testes!</string>
  <string name="err_vhdlValuesOfType_N_notAllowed">Valores de tipo {0} não são permitidos!</string>
  <string name="err_vhdlANameIsMissing">Falta nome. Todos os pinos têm rótulos (por exemplo)?</string>
  <string name="err_toManyVars">Variáves em excesso!</string>
  <string name="err_invalidExpression">Expressão inválida!</string>
  <string name="err_function_N0_notFoundInLine_N1">Função {0} não encontrada na linha {1}!</string>
  <string name="err_wrongNumOfArgsIn_N0_InLine_N1_found_N2_expected_N3">Número de parâmetros incorreto na função {0} na linha {1} (encontrados {2}, esperados {3})!</string>
  <string name="err_invalidValue_N0_inFunction_N1">Valor inválido {0} na função {1}!</string>
  <string name="err_Node_N_isAComponent">O nome do caminho inválido {0}.</string>
  <string name="err_loadingLibrary">Erro ao carregar uma biblioteca.</string>
  <string name="err_noManifestFound">O arquivo JAR não contém manifesto!</string>
  <string name="err_noMainFoundInManifest">O manifesto não contém uma entrada para a Main-Class!</string>
  <string name="err_mainClass_N_NotFound">Não foi possível encontrar a classe {0}!</string>
  <string name="err_couldNotInitializeMainClass_N">Não foi possível criar uma instãncia para a classe {0}!</string>
  <string name="err_notMoreOutBitsThanInBits">Necessário haver mais bits de entrada que de saída!</string>
  <string name="err_constantsNotAllowed">~Não é possível definir pinos físicos para valores constantes!</string>
  <string name="err_invalidNumberFormat_N_N">O string {0} não é um número válido (pos {1})!</string>
  <string name="err_invalidPinName_N">O nome {0} não é permitido!</string>
  <string name="err_whiteSpaceNotAllowedInTT2Name">Espaços em branco não são permitidos em nome de arquivo TT2!</string>
  <string name="err_tableHasToManyResultColumns">A tabela tem colunas demais!</string>
  <string name="err_errorExportingZip">Erro ao gravar arquivo compactado (zip).</string>
  <string name="err_moreThanOneFastClock">Apenas um componente de clock com alta frequência é permitido.</string>
  <string name="err_circuitHasCycles">O circuito contém ciclos. Não é possível analisar tal circuito.
        Ciclos podem ocorrer se a saída de uma porta é realimentada com entrada da mesma.
        O uso de chaves, FETs ou relés podem causar ciclos.</string>
  <string name="err_monoflopRequiresOneClock">Se um monoflop for usado, deverá haver um único componente de clock!</string>
  <string name="err_centralDefinedRomsAreNotSupported">ROM's definidas nas configurações não têm suporte!</string>
  <string name="err_couldNotCreateElement_N">Não foi possível criar um componente do tipo {0}!</string>
  <string name="err_errorWritingDataToProcess">Não foi possível gravar valores no processo externo!</string>
  <string name="err_errorReadingDataFromProcess">Não foi possível ler valores do processo externo!</string>
  <string name="err_errorCreatingProcess">Não foi possível criar o processo externo!</string>
  <string name="err_timeoutReadingData_O">Excedido o tempo de leitura para dados do processo externo!
        {0}</string>
  <string name="err_notEnoughDataReceived_O">Dados insuficientes recebidos!
        {0}</string>
  <string name="err_invalidCharacterReceived_N_O">O texto recebido contém um caractere inválido: {0}!
        {1}</string>
  <string name="err_processTerminatedUnexpected_O">O processo terminou de forma inesperada!
        {0}</string>
  <string name="err_couldNotTerminateProcess">Não foi possível terminar o processo!</string>
  <string name="err_couldNotStartProcess_N">Não foi possível iniciar o processo: {0}</string>
  <string name="err_exitValueNotNull_N_O">O status de saída da aplicação não foi 0, mas {0}:
        {1}</string>
  <string name="err_canOnlyExportExternalVHDL">Código externo somente pode ser exportado se for em VHDL!</string>
  <string name="err_canOnlyExportExternalVerilog">Código externo somente pode ser exportado se for em Verilog!</string>
  <string name="err_ifExternalComponentIsUsedTwiceCodeMustBeIdentical_N">Se um componente externo for usado várias vezes, o código deverá ser o mesmo! Efeitos: {0}</string>
  <string name="err_writingToStdOut_O">Não foi possível escrever na saída padrão:
        {0}</string>
  <string name="err_ghdlNotInstalled">O simulador de VHDL (ghdl) parece não estar instalado. Recomendável instalar ghdl (http://ghdl.free.fr/) e tentar de novo. Se ainda houver problemas, conferir os caminhos para os executáveis do ghdl nas configuraçãoes do Digital.</string>
  <string name="err_iverilogNotInstalled">O simulador Icarus Verilog parece não estar instalado. Recomendável instalar o iverilog (http://iverilog.icarus.com/) e tentar de novo. Se ainda houver problemas, conferir os caminhos para os executáveis do iverilog nas configurações do Digital.</string>
  <string name="err_errorAnalysingCircuit_N">Erro ao analisar o circuito: {0}</string>
  <string name="err_romNeedsALabelToBeExported">Toda ROM necessita um rótulo único para ser exportada!</string>
  <string name="err_lutNeedsALabelToBeExported">Toda LUT necessita um rótulo único para ser exportada!</string>
  <string name="err_counterNeedsMoreBits">O contador necessita de dois bits no mínimo.</string>
  <string name="err_namesAreNotUnique_N">O nome "{0}" não é único!</string>
  <string name="err_clocksNotAllowedInAsyncMode">Elementos de clock não podem ser usados em modo assíncrono.</string>
  <string name="err_verilogExporting">Erro ao exportar para Verilog.</string>
  <string name="err_noRomFound">Nenhuma memória de programa encontrada! A memória de programa precisa ser indicada como tal.</string>
  <string name="err_errorLoadingRomData">Erro ao carregar a memória de programa.</string>
  <string name="err_parsingSVG">Erro durante a leitura do arquivo SVG.</string>
  <string name="err_morePinsDefinedInSVGAsNeeded">O arquivo SVG contém pinos que não existem no circuito.</string>
  <string name="err_allMemoriesNeedToHaveTheSameByteWidth">Todas as memórias em que dados deverão ser carregados requerem a mesma largura de bits.</string>
  <string name="err_ProgMemLabelsNotDifferent">Se programas serão carregados em várias RAMs, todas deverão ter nomes distintos.
        A ordem lexicográfica determinará a ordenação das RAMs.</string>
  <string name="err_midiSystemNotAvailable">Sistema MIDI-System não disponível.</string>
  <string name="err_midiChannel_N_NotAvailable">O canal MIDI {0} não está disponível.</string>
  <string name="err_midiInstrument_N_NotAvailable">O instrumento MIDI {0} nnão está disponível.</string>
  <string name="err_midiInstrumentsNotAvailable">Os instrumentos MIDI não estão disponíveis.</string>
  <string name="err_whileExecutingTests_N0">Durante a execução dos testes "{0}" houve um erro!</string>
  <string name="key_AddrBits">Bits de endereço</string>
  <!-- ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM -->
  <string name="key_AddrBits_tt">Número de bits de endereço usado.</string>
  <string name="key_Bits">Bits de dados</string>
  <!-- And, NAnd, Or, NOr, XOr, XNOr, Not, LookUpTable, Delay, Out, In, Ground, VDD, Const, PullUp, PullDown, Driver, DriverInvSel, Multiplexer, Demultiplexer, D_FF, D_FF_AS, Register, ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM, GraphicCard, Counter, Add, Sub, Mul, BarrelShifter, Comparator, Neg, BitCount, Switch, Relay, PFET, NFET, FGPFET, FGNFET, TransGate -->
  <string name="key_Bits_tt">Número de bits de dados usados.</string>
  <string name="key_Color">Cor</string>
  <!-- LED, LightBulb, Seven-Seg, Seven-Seg-Hex, LedMatrix -->
  <string name="key_Color_tt">A cor do elemento.</string>
  <string name="key_backgroundColor">Cor de fundo (background)</string>
  <string name="key_backgroundColor_tt">Cor de fundo para o circuito quando estiver integrado a outro. Não é usada em encapsulamentos DIL.</string>
  <string name="key_Cycles">Ciclos de temporização</string>
  <!-- Break -->
  <string name="key_Cycles_tt">Se a quantidade de ciclos for alcançada sem um sinal de interrupção, uma situação de erro se estabelecerá.</string>
  <string name="key_Data">Dados</string>
  <!-- LookUpTable, ROM, EEPROM -->
  <string name="key_Data_tt">Os valores armazenados nesse elemento.</string>
  <string name="key_Default">Valor padrão</string>
  <!-- Demultiplexer, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS -->
  <string name="key_Default_tt">Valor definido para o circuito quando for ligado.
        No demultiplexador, esse valor será definido para as saídas não selecionadas.</string>
  <string name="key_InDefault">Valor padrão</string>
  <!-- In -->
  <string name="key_InDefault_tt">Valor definido para o circuito quando for ligado. "Z" significa alta impedância.</string>
  <string name="key_isHighZ">Entrada tri-state</string>
  <!-- In, Splitter -->
  <string name="key_isHighZ_tt">Se definido, permite-se que a entrada esteja em alta impedância. Em um componente de entrada, 
        isso também será permitido, se ("Z") estiver definido como valor padrão.</string>
  <string name="key_avoidActiveLow">Nenhuma saída em zero.</string>
  <string name="key_avoidActiveLow_tt">Evitar saída em zero. Isso será útil especialmente quando forem definidos circuitos com relés .
        Somente poderá ser ativada se uma saída em alta impedância for permitida.</string>
  <string name="key_Description">Descrição</string>
  <!-- Out, In, Text -->
  <string name="key_Description_tt">Uma breve descrição do elemento e como usá-lo.</string>
  <string name="key_Frequency">Frequência/Hz</string>
  <!-- Clock -->
  <string name="key_Frequency_tt">Frequência em tempo real a ser usada no clock de tempo real</string>
  <string name="key_IEEEShapes">Usar formatos IEEE 91-1984</string>
  <string name="key_IEEEShapes_tt">Usar formatos IEEE 91-1984 em lugar dos retangulares</string>
  <string name="key_Inputs">Número de entradas</string>
  <!-- And, NAnd, Or, NOr, XOr, XNOr, LookUpTable -->
  <string name="key_Inputs_tt">Número de entradas usado. Cada entrada necessitará estar contectada.</string>
  <string name="key_Label">Rótulo</string>
  <!-- Out, LED, In, Clock, Button, Probe, LightBulb, LedMatrix, RotEncoder, Keyboard, Terminal, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Register, ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM, GraphicCard, Counter, Add, Sub, Mul, BarrelShifter, Comparator, Switch, Relay, PFET, NFET, FGPFET, FGNFET, Testcase, PowerSupply, Reset, Break -->
  <string name="key_Label_tt">Nome do elemento.</string>
  <string name="key_Size">Tamanho</string>
  <!-- LED, SevenSeg -->
  <string name="key_Size_tt">Tamanho do formato no circuito.</string>
  <string name="key_Language">Idioma</string>
  <string name="key_Language_tt">Idioma na interface gráfica (GUI). Será efetivo apenas após reinicialização.</string>
  <string name="key_NetName">Nome da rede</string>
  <!-- Tunnel -->
  <string name="key_NetName_tt">ATodas as redes com nomes idênticas estarão ligadas entre si.</string>
  <string name="key_InputSplitting">Entrada para o distribuidor</string>
  <!-- Splitter -->
  <string name="key_InputSplitting_tt">Se, por exemplo, quatro bits, dois bits mais outros dois serão usados como entradas,
        isso poderá ser configurado como "4,2,2". A quantidade indicará o número de bits. Por conveniência, o asterisco
        poderá ser usado: 16 bits poderão ser configurados como "[bits]*[quantidade]", ou seja, "1*16".
        Também é possível especificar os bits a serem usados diretamente e em qual ordem.
        Por exemplo, "4-7,0-3" configurará os bits 4-7 e 0-3. Essa notação permitirá qualquer arranjo de bits desejado.
        Os bits de entrada deverão ser especificados de forma completa e inequívoca.</string>
  <string name="key_OutputSplitting">Saída do distribuidor</string>
  <!-- Splitter -->
  <string name="key_OutputSplitting_tt">Se, por exemplo, quatro bits, dois bits mais outros dois serão usados como saídas,
        isso poderá ser configurado como "4,2,2". A quantidade indicará o número de bits. Por conveniência, o asterisco
        poderá ser usado: 16 bits poderão ser configurados como "[bits]*[quantidade]", ou seja, "1*16".
        Também é possível especificar os bits a serem usados diretamente e em qual ordem.
        Os bits de saída poderão ser combinados várias vezes: "0-7,1-6,4-7"</string>
  <string name="key_SelectorBits">Número de bits do seletor</string>
  <!-- Multiplexer, Demultiplexer, Decoder -->
  <string name="key_SelectorBits_tt">Número de bits usados na entrada do seletor.</string>
  <string name="key_Signed">Operação com sinal</string>
  <!-- Comparator, Div -->
  <string name="key_Signed_tt">Se selecionado, a operação será executada usando valores com sinal (em complemento de 2).</string>
  <string name="key_Closed">Fechada</string>
  <!-- Switch -->
  <string name="key_Closed_tt">Estado inicial definido para a chave.</string>
  <string name="key_Value">Valor</string>
  <!-- Const -->
  <string name="key_Value_tt">Valor de uma constante.</string>
  <string name="key_Width">Largura</string>
  <string name="key_Width_tt">Largura do símbolo a ser usada se o circuito for componente de outro.</string>
  <string name="key_Height">Altura</string>
  <string name="key_Height_tt">Altura do símbolo a ser usada se o circuito for componente de outro.</string>
  <string name="key_autoReload">Carga inicial do modelo</string>
  <!-- ROM -->
  <string name="key_autoReload_tt">Recarregar o arquivo hexadecimal toda vez que o modelo for ligado.</string>
  <string name="key_flipSelPos">Alternar posição do seletor</string>
  <!-- Driver, DriverInvSel, Multiplexer, Demultiplexer, Decoder -->
  <string name="key_flipSelPos_tt">Essa opção permitirá deslocar o pino do seletor para o lado oposto.</string>
  <string name="key_intFormat">Formato para número</string>
  <!-- Probe -->
  <string name="key_intFormat_tt">Formato a ser usado para mostrar números.</string>
  <string name="key_intFormat_ascii">ASCIIi</string>
  <string name="key_intFormat_bin">binário</string>
  <string name="key_intFormat_dec">decimal</string>
  <string name="key_intFormat_decSigned">decimal com sinal</string>
  <string name="key_intFormat_def">padrão</string>
  <string name="key_intFormat_hex">hexadecimal</string>
  <string name="key_barrelSigned">Entrada para o deslocamento com sinal</string>
  <!-- BarrelShifter -->
  <string name="key_barrelSigned_tt">Entrada para o deslocamento em complemento de 2</string>
  <string name="key_barrelShifterMode">Modo</string>
  <!-- BarrelShifter -->
  <string name="key_barrelShifterMode_tt">Modo do registrador de deslocamento</string>
  <string name="key_barrelShifterMode_logical">Lógico</string>
  <string name="key_barrelShifterMode_rotate">Rotação</string>
  <string name="key_barrelShifterMode_arithmetic">Aritmético</string>
  <string name="key_direction">Direção</string>
  <!-- BarrelShifter -->
  <string name="key_direction_tt">Definir direção.</string>
  <string name="key_direction_left">esquerda</string>
  <string name="key_direction_right">direita</string>
  <string name="key_maxStepCount">Número máximo de passos a serem mostrados</string>
  <!-- Data -->
  <string name="key_maxStepCount_tt">Número máximo de valores armazenados.
        Se o quantidade máxima for alcançada, os valores mais antigos serão descartados.</string>
  <string name="key_microStep">Mostrar passo-a-passo</string>
  <!-- Data -->
  <string name="key_microStep_tt">Mostrar todos os passos graficamente.</string>
  <string name="key_rotation">Rotação</string>
  <!-- And, NAnd, Or, NOr, XOr, XNOr, Not, LookUpTable, Delay, Out, LED, In, Clock, Button, Probe, LightBulb, LedMatrix, RotEncoder, Keyboard, Terminal, Ground, VDD, Const, Tunnel, Splitter, PullUp, PullDown, Driver, DriverInvSel, Multiplexer, Demultiplexer, Decoder, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Register, ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM, GraphicCard, Counter, Add, Sub, Mul, BarrelShifter, Comparator, Neg, BitCount, DiodeForward, DiodeBackward, Switch, Fuse, Relay, PFET, NFET, FGPFET, FGNFET, TransGate, PowerSupply, Reset, Break -->
  <string name="key_rotation_tt">Orientação do elemento no circuito.</string>
  <string name="key_runRealTime">Iniciar o clock de tempo real</string>
  <!-- Clock -->
  <string name="key_runRealTime_tt">Se habilitado o clock da execução será iniciado juntamente com a ligação do circuito</string>
  <string name="key_showDataGraph">Mostrar o gráfico de medidas juntamente com o início da simulação</string>
  <string name="key_showDataGraph_tt">Ao iniciar a simulação, o gráifco de valores medidos também será mostrado.</string>
  <string name="key_showDataGraphMicro">Mostrar o gráfico de medidas juntamente com o início da simulação passo-a-passo</string>
  <string name="key_showDataGraphMicro_tt">Ao iniciar a simulação, o gráifco de valores medidos também será mostrado no modo passo-a-passo.
        Todas as mudanças em portas estarão relacionadas no gráfico.</string>
  <string name="key_showDataTable">Mostrar o gráfico de medidas juntamente com o início da simulação</string>
  <string name="key_showDataTable_tt">Quando a simulação iniciar, uma tabela com os valores medidos será mostrada.</string>
  <string name="key_termHeight">Linhas</string>
  <!-- Terminal -->
  <string name="key_termHeight_tt">Número de linhas a serem mostradas.</string>
  <string name="key_termWidth">Caracteress por linha</string>
  <!-- Terminal -->
  <string name="key_termWidth_tt">Número de caracteres a serem mostrados em cada linha.</string>
  <string name="key_valueIsProbe">Usar como valor medido</string>
  <!-- RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Register -->
  <string name="key_valueIsProbe_tt">Se definido, o valor será usado como o de medição, e será mostrado no gráfico e também na tabela de dados.
        Além disso, um rótulo deverá ser especificado para servir como identificação do valor.</string>
  <string name="key_Testdata">Dados para teste</string>
  <!-- Testcase -->
  <string name="key_Testdata_tt">Descrição de um caso de teste.
        Detalhes de sintaxe poderão ser encontrados na caixa de diálogo para ajuda no editor de caso de teste.</string>
  <string name="key_graphicWidth">Largura em pixels</string>
  <!-- GraphicCard -->
  <string name="key_graphicWidth_tt">Largura da tela em pixels.</string>
  <string name="key_graphicHeight">Altura em pixels</string>
  <!-- GraphicCard -->
  <string name="key_graphicHeight_tt">Altura da tela em pixels.</string>
  <string name="key_isProgramMemory">Memória de programa</string>
  <!-- ROM -->
  <string name="key_isProgramMemory_tt">Tomar o conteúdo da ROM como a memória de programa. Dessa forma, poderá ser acessado por uma IDE externa.</string>
  <string name="key_isProgramCounter">Contador de programa</string>
  <string name="key_isProgramCounter_tt">Tomar o registrador como contador de programa. O valor do registrador será tomado
        a partir da IDE do montador externo para marcar a linha de código corrente durante a depuração.</string>
  <string name="key_Blown">Programado</string>
  <!-- DiodeForward, DiodeBackward, Fuse, FGPFET, FGNFET -->
  <string name="key_Blown_tt">Se o diodo estiver "programado" ou não ("blown").
        Em uma porta flutuante FET, estará com carga.
        Poderá ser definido apenas pela letra 'p'.</string>
  <string name="key_ExpressionFormat">Formato</string>
  <string name="key_ExpressionFormat_tt">Formato da tela para expressões.</string>
  <string name="key_relayNormallyClosed">Relé normalmente fechado.</string>
    <!-- Relay -->
    <string name="key_relayNormallyClosed_tt">Se o relé estiver fechado, a entrada estará em nível baixo.</string>
    <string name="key_poles">Número de polos</string>
    <!-- Relay -->
    <string name="key_poles_tt">Número de polos disponíveis.</string>
    <string name="key_commonCathode">Conexão comum</string>
    <!-- Seven-Seg -->
    <string name="key_commonCathode_tt">Se a entrada for selecionada como ânodo ou cátodo comum, também será simulada.
    </string>
    <string name="key_ledPersistence">Prevenir o piscamento (flicker)</string>
    <!-- Seven-Seg, LedMatrix -->
    <string name="key_ledPersistence_tt">Não é possível aumentar a frequência o bastante para que o efeito de piscamento
        possa desaparecer.
        Para suprimir o piscamento, um "afterglow" poderá ser acionado para manter os LEDs nessa condição.
        Se selecionado, os LEDs se manterão ligados, mesmo que um dos pinos for alterado para nível de alta impedância
        (z).
        Isso simulará uma frequência acima da crítica para a fusão.
    </string>
    <string name="key_atf1502Fitter">Filtro ATF15xx</string>
    <string name="key_atf1502Fitter_tt">Caminho para o filtro ATF15xx.
        Fornecer a pasta que contenha os arquivos fit15xx.exe fornecidos pela Microchip (antes ATMEL).
    </string>
    <string name="key_pin">Número do pino</string>
    <string name="key_pin_tt">Um campo vazio significará que o sinal não está associado ao pino.</string>
    <string name="key_rowDataBits">Linhas</string>
    <!-- LedMatrix -->
    <string name="key_rowDataBits_tt">Especificação do número de linhas mediante a largura em bits da palavra
        correspondente.
    </string>
    <string name="key_colAddrBits">Bits de endereço das colunas</string>
  <!-- LedMatrix -->
  <string name="key_colAddrBits_tt">Endereços das colunas individuais. Três bits corresponderão a oito colunas.</string>
  <string name="key_lockedMode">Modificação bloqueada</string>
  <string name="key_lockedMode_tt">O circuito está bloqueado. É possível configurar diodos e FGF-FETs.</string>
  <string name="key_pinNumber">Número do pino</string>
  <!-- Out, In, Clock -->
  <string name="key_pinNumber_tt">Número desse pino. Usado para a representação de um circuito com encapsulamento DIL e 
        quando a a atribuição ao pino for usada na programação de um CPLD.
        Se houver vários bits, todos os números de pinos poderão ser especificados por uma lista, separados por vírgulas.</string>
  <string name="key_pinCount">Número de pinos DIL</string>
  <string name="key_pinCount_tt">Número de pinos. Se igual a zero, significa que o número de pinos será determinado automaticamente.</string>
  <string name="key_defTreeSelect">A hierarquia de componentes visível desde a inicialização.</string>
  <string name="key_defTreeSelect_tt">Se definido, fará com que a hierarquia de componentes seja visível desde a inicialização.</string>
  <string name="key_inverterConfig">Entradas invertidas</string>
  <!-- And, NAnd, Or, NOr, XOr, XNOr, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Counter -->
  <string name="key_inverterConfig_tt">É possível selecionar entradas cujos valores serão invertidos.</string>
  <string name="key_fontSize">Tamanho da fonte em menus [%]</string>
  <string name="key_fontSize_tt">O tamanho das fontes usadas no menu é dada em uma porcentagem do tamanho padrão.</string>
  <string name="key_withEnable">Entrada para habilitação</string>
  <!-- T_FF -->
  <string name="key_withEnable_tt">Se definido, tornará a entrada de habilitação (T) disponível.</string>
  <string name="key_unidirectional">Unidirecional</string>
  <!-- PFET, NFET -->
  <string name="key_unidirectional_tt">Transistores unidirectionais propagarão um sinal somente da fonte para o dreno.
        Eles são muito mais rápidos para simular do que os transistores bidirecionais. Desde que não haja realimentação do dreno para a fonte, nesse modo,
        o transistor não poderá causar curto-circuito de fios quando estiver conduzindo. Assim, será possível simular
        certos circuitos CMOS.</string>
  <string name="key_activeLow">Ativo em nível baixo</string>
  <!-- Button -->
  <string name="key_activeLow_tt">Se selecionada a saída estará em nível baixo, quando o circuito estiver ativo.</string>
  <string name="key_libraryPath">Biblioteca</string>
  <string name="key_libraryPath_tt">Pasta contendo a biblioteca com sub-circuitos predefinidos.
        Contém, por exemplo, os componentes da sére 74xx. Também será possível adicionar circuitos próprios que estejam guardados nesse mesmo lugar.
        Deve-se garantir que os nomes de todos os arquivos nessa pasta e subpastas sejam únicos.</string>
  <string name="key_grid">Mostrar grade.</string>
  <string name="key_grid_tt">Mostrar uma grade na tela principal.</string>
  <string name="key_mapToKey">Mapear para o teclado</string>
  <!-- Button -->
  <string name="key_mapToKey_tt">Botão mapeado para o teclado.
        Para usar as teclas do cursor, utilizar as teclas de direção UP, DOWN, LEFT ou RIGHT.</string>
  <string name="key_jarPath">Biblioteca Java</string>
  <string name="key_jarPath_tt">Arquivo jar contendo componentes adicionais implementados em Java.</string>
  <string name="key_showWireBits">Mostrar o número de fios em um barramento.</string>
  <string name="key_showWireBits_tt">ATENÇÃO: O valor será atualizado somente quando a simulação for iniciada.</string>
  <string name="key_inputBits">Largura em bits da entrada</string>
  <!-- BitExtender -->
  <string name="key_inputBits_tt">O número de bits da saída deverá ser maior do que o número de bits da entrada.</string>
  <string name="key_outputBits">Largura em bits da saída</string>
  <!-- BitExtender -->
  <string name="key_outputBits_tt">O número de bits da saída deverá ser maior queo o número de bits da entrada.</string>
  <string name="key_textFontSize">Tamanho da fonte</string>
  <string name="key_textFontSize_tt">Definição do tamanho de fonte a ser usado nesse texto.</string>
  <string name="key_delayTime">Duração</string>
  <string name="key_delayTime_tt">Unidades de tempo do atraso de propagação das portas comuns.</string>
  <string name="key_invertOutput">Saída invertida</string>
  <string name="key_invertOutput_tt">Se definido, inverterá a saída.</string>
  <string name="key_timerDelay">Largura de pulso</string>
  <string name="key_timerDelay_tt">A largura de pulso é medida em ciclos de clock.</string>
  <string name="key_splitterSpreading">Propagação</string>
  <string name="key_splitterSpreading_tt">Configuração de como irão se propagar as entradas e saídas no circuito.</string>
  <string name="key_romContent">Conteúdo das ROM's</string>
  <string name="key_romContent_tt">Conteúdo de todas as ROM's usadas</string>
  <string name="key_applicationType">Aplicação</string>
  <string name="key_applicationType_tt">Definição de qual aplicação usar.</string>
  <string name="key_applicationType_Generic">Genérico</string>
  <string name="key_applicationType_GHDL">GHDL</string>
  <string name="key_applicationType_IVERILOG">IVerilog</string>
  <string name="key_applicationType_Socket">Socket</string>
  <string name="key_externalInputs">Entradas</string>
  <string name="key_externalInputs_tt">Entradas do processo externo.
        Lista de nomes de sinais separados por vírgulas. Após cada nome de sinal, separado por dois-pontos, um número de bits
        pode ser especificado. As entradas de 8 bits de um somador poderão ser descritas como  "a:8,b:8,c_in".</string>
  <string name="key_externalOutputs">Saídas</string>
  <string name="key_externalOutputs_tt">As saídas do processo externo.
        Lista de nomes de sinais separados por vírgulas. Após cada nome de sinal, separado por dois-pontos, um número de bits
        pode ser especificado. As saídas de 8 bits de um somador poderão ser descritas como  "a:8,b:8,c_in". "s:8,c_out".</string>
  <string name="key_Code">Código de programa</string>
  <string name="key_Code_tt">Definição do código de programa a ser executado na aplicação externa.</string>
  <string name="key_ghdlPath">GHDL</string>
  <string name="key_ghdlPath_tt">Caminho parao arquivo executável ghdl. Somente será necessário se for desejado usar ghdl para simular
        componentes definidos em vhdl.</string>
  <string name="key_iverilogPath">IVerilog</string>
  <string name="key_iverilogPath_tt">Caminho para a pasta de instalação do Icarus Verilog. Somente será necessário se for desejado usar iverilog para simular
        componentes definidos em  verilog.</string>
  <string name="key_maxValue">Valor máximo</string>
  <string name="key_maxValue_tt">Se o valor zero for fornecido, o maior valor possível será usado (todos os bits em 1).</string>
  <string name="key_dipDefault">Saída em nível alto</string>
  <string name="key_dipDefault_tt">Valor padrão de saída de um DIP switch quando a simulação iniciar.</string>
  <string name="key_macMouse">Usar clicks do mouse MacOS.</string>
  <string name="key_macMouse_tt">Usar CTRL-click em lugar de botão direito.</string>
  <string name="key_ATMISP">ATMISP</string>
  <string name="key_ATMISP_tt">Caminho para o arquivo executável ATMISP.exe. Se definido, o software ATMISP poderá ser ativado automaticamente!</string>
  <string name="key_customShape">Formato customizado</string>
  <string name="key_customShape_tt">Importar um arquivo SVG</string>
  <string name="key_preloadProgram">Memória de programa com carregamento prévio na inicialização.</string>
  <string name="key_preloadProgram_tt">Quando da simulação de um processador que use uma RAM como memória de programa,
        é difícil iniciá-lo pois o conteúdo da RAM geralmente começa com zeros ao iniciar-se a simulação.
        Essa configuração permitirá a carregar previamente dados na memória de programa.
        Para isso, a memória de programa na simulação deverá ser marcada para tal.</string>
  <string name="key_preloadProgramFile">Arquivo de programa</string>
  <string name="key_preloadProgramFile_tt">Arquivo que deverá ser carregado na memória de programa ao iniciar-se a simulação
        a simulação.</string>
  <string name="key_RectWidth">Largura</string>
  <string name="key_RectWidth_tt">Largura em unidades da grade</string>
  <string name="key_RectHeight">Altura</string>
  <string name="key_RectHeight_tt">Altura em unidades da grade</string>
  <string name="key_RectInside">Texto interno</string>
  <string name="key_RectInside_tt">Colocar texto interno ao retângulo.</string>
  <string name="key_RectBottom">Texto embaixo</string>
  <string name="key_RectBottom_tt">Colocar texto embaixo do retângulo.</string>
  <string name="key_RectRight">Texto à direita</string>
  <string name="key_RectRight_tt">Colocar texto à direita do retângulo.</string>
  <string name="key_wideShape">Formato ampliado</string>
  <string name="key_wideShape_tt">Usará um formato ampliado para visualizar a porta.</string>
  <string name="key_shapeType">Formato</string>
  <string name="key_shapeType_tt">Formato a ser usado na representação de circuito integrado a outro.
        No modo "Simples", as entradas estarão mostradas à esquerda, e as saídas, à direita de um retângulo.
        Em "Layout", as posições de entradas e saídas, bem como suas orientações no circuito, definirão as
        posições dos pinos. Assim será possível ter pinos nas partes de cima e de baixo.
        Se selecionado "DIL-Chip", esse encapsulamento será usado para apresentar o circuito. Os números dos pinos das entradas e das saídas
        determinarão as posições dos pinos nesse caso.</string>
  <string name="key_shapeType_DEFAULT">Padrão</string>
  <string name="key_shapeType_SIMPLE">Simples</string>
  <string name="key_shapeType_DIL">DIL-Chip</string>
  <string name="key_shapeType_LAYOUT">Layout</string>
  <string name="key_shapeType_CUSTOM">Definido pelo usuário</string>
  <string name="key_textOrientation">Orientação</string>
  <string name="key_textOrientation_tt">Posição de coordenada relativa ao texto.</string>
  <string name="key_textOrientation_LEFTBOTTOM">embaixo à esquerda</string>
  <string name="key_textOrientation_CENTERBOTTOM">embaixo no centro</string>
  <string name="key_textOrientation_RIGHTBOTTOM">embaixo à direita</string>
  <string name="key_textOrientation_RIGHTCENTER">no centro à direita</string>
  <string name="key_textOrientation_RIGHTTOP">em cima à direita</string>
  <string name="key_textOrientation_CENTERTOP">em cima no centro</string>
  <string name="key_textOrientation_LEFTTOP">em cima à esquerda</string>
  <string name="key_textOrientation_LEFTCENTER">no centro à esquerda</string>
  <string name="key_textOrientation_CENTERCENTER">no centro</string>
  <string name="key_midiChannel">Canal MIDI</string>
  <string name="key_midiChannel_tt">Selecionar o canal MIDI a ser usado.</string>
  <string name="key_midiInstrument">Instrumento MIDI</string>
  <string name="key_midiInstrument_tt">O instrumento MIDI a ser usado.</string>
  <string name="key_midiProgChange">Permitir alteração de programa</string>
  <string name="key_midiProgChange_tt">Adicionar uma nova entrada PC. Se essa entrada estiver em nível alto,
        o valor da entrada N será usado para alterar o programa (instrumento).</string>
  <string name="mod_insertWire">Fio inserido.</string>
  <string name="mod_insertCopied">Inserção a partir da área de transferência.</string>
  <string name="mod_setKey_N0_in_element_N1">Valor ''{0}'' no componente ''{1}'' modificado.</string>
  <string name="mod_setAttributesIn_N">Atributos do componente ''{0}'' modificado.</string>
  <string name="mod_wireDeleted">Fio removido.</string>
  <string name="mod_movedOrRotatedElement_N">Componente ''{0}'' movido ou rotacionado.</string>
  <string name="mod_movedWire">Fio movido.</string>
  <string name="mod_deletedSelection">Seleção removida.</string>
  <string name="mod_insertedElement_N">Componente ''{0}'' inserido.</string>
  <string name="mod_deletedElement_N">Componente ''{0}'' removido.</string>
  <string name="mod_insertedWire">Fio inserido.</string>
  <string name="mod_movedSelected">Seleção movida.</string>
  <string name="mod_undo_N">Desfazer: {0}</string>
  <string name="mod_redo_N">Refazer: {0}</string>
  <string name="mod_circuitAttrModified">Atributos de circuito modificados.</string>
  <string name="mod_modifiedMeasurementOrdering">Medidas ordenadas.</string>
  <string name="mod_groupEdit">Atributos modificados nos componentes selecionados.</string>
  <string name="mod_splitWire">Dividir um fio em dois outros.</string>
  <string name="lib_Logic">Lógica</string>
  <string name="lib_arithmetic">Aritmética</string>
  <string name="lib_flipFlops">Flip-Flops</string>
  <string name="lib_io">Entradas e saídas</string>
  <string name="lib_memory">Memória</string>
  <string name="lib_mux">Plexers</string>
  <string name="lib_wires">Conexões</string>
  <string name="lib_switching">Chaves</string>
  <string name="lib_misc">Diversos</string>
  <string name="lib_more">mais</string>
  <string name="lib_ram">RAM</string>
  <string name="lib_eeprom">EEPROM</string>
  <string name="menu_window">Janela</string>
  <string name="menu_about">Sobre</string>
  <string name="menu_analyse">Análises</string>
  <string name="menu_analyse_tt">Analisar o circuito corrente</string>
  <string name="menu_cut">Cortar</string>
  <string name="menu_copy">Copiar</string>
  <string name="menu_custom">Personalizar</string>
  <string name="menu_library">Biblioteca</string>
  <string name="menu_delete">Remover componentes</string>
  <string name="menu_delete_tt">Remover componente individual selecionado ou grupo de componentes.</string>
  <string name="menu_edit">Editar</string>
  <string name="menu_editAttributes">Configurações específicas do circuito</string>
  <string name="menu_editAttributes_tt">Configurações específicas do circuito afetarão o comportamento do circuito corrente.
        Por exemplo, o formato que representará o circuito quando integrado em outro.
        Essas configurações serão armazenadas juntamente com o circuito.</string>
  <string name="menu_editSettings">Configurações</string>
  <string name="menu_editSettings_tt">As configurações globais do simulador especificação, dentre outras coisas,
        do idioma, a simbologia a ser usada ou os caminhos para as ferramentas externas.</string>
  <string name="menu_element">Parar a simulação</string>
  <string name="menu_element_tt">Parar a simulação e permitir a edição do circuito.</string>
  <string name="menu_elements">Componentes</string>
  <string name="menu_export">Exportar</string>
  <string name="menu_exportPNGLarge">Exportar PNG grande</string>
  <string name="menu_exportPNGSmall">Exportar PNG pequeno</string>
  <string name="menu_exportSVG">Exportar SVG</string>
  <string name="menu_exportAnimatedGIF">Exportar GIF animado</string>
  <string name="menu_fast">Executar com interrupção</string>
  <string name="menu_fast_tt">Executará o circuito até que uma interrupção seja detectada por uso de um componente BRK.</string>
  <string name="menu_file">Arquivo</string>
  <string name="menu_help">Ajuda</string>
  <string name="menu_update">Atualizar</string>
  <string name="menu_update_tt">Atualizar os componentes do menu.</string>
  <string name="menu_maximize">Ajustar ao tamanho da janela</string>
  <string name="menu_micro">Execução passo-a-passo</string>
  <string name="menu_micro_tt">Executar o circuito passo-a-passo</string>
  <string name="menu_new">Novo</string>
  <string name="menu_new_tt">Criar um circuito novo, vazio.</string>
  <string name="menu_newSub">Novo circuito integrado</string>
  <string name="menu_newSub_tt">Abrirá uma nova janeta para ser criado um novo circuito integrado, que posteriormente poderá ser usado no circuito corrente.</string>
  <string name="menu_open">Abrir</string>
  <string name="menu_openRecent">Abrir recente</string>
  <string name="menu_openRecentNewWindow">Abrir recente em nova janela</string>
  <string name="menu_openWin">Abrir em nova janela</string>
  <string name="menu_openWin_tt">Abrir circuito em nova janela</string>
  <string name="menu_orderInputs">Ordenar entradas</string>
  <string name="menu_orderInputs_tt">Ordenar as entradas para circuito integrado</string>
  <string name="menu_orderMeasurements">Ordenar valores medidos</string>
  <string name="menu_orderMeasurements_tt">Ordenar os valores medidos em gráficos e tabelas</string>
  <string name="menu_orderOutputs">Ordenar saídas</string>
  <string name="menu_orderOutputs_tt">Ordenas as saídas para circuito integrado.</string>
  <string name="menu_paste">Colar</string>
  <string name="menu_insertAsNew">Colar em nova janela</string>
  <string name="menu_insertAsNew_tt">O conteúdo da área de transferência será colado na nova janela.</string>
  <string name="menu_rotate">Rotacionar</string>
  <string name="menu_sim">Simulação</string>
  <string name="menu_run">Iniciar a simulação</string>
  <string name="menu_run_tt">Iniciar a simulação do circuito.</string>
  <string name="menu_save">Salvar</string>
  <string name="menu_saveAs">Salvar como</string>
  <string name="menu_saveData">Salvar dados</string>
  <string name="menu_saveData_tt">Salvar dados em arquivo CSV</string>
  <string name="menu_speedTest">Teste de velocidade</string>
  <string name="menu_speedTest_tt">Calcular a máxima frequência de clock.</string>
  <string name="menu_step">Passo em porta</string>
  <string name="menu_step_tt">Calcular um avanço em porta simples</string>
  <string name="menu_synthesise">Sintetizar</string>
  <string name="menu_synthesise_tt">Gerar expressões booleanas mínimas dada a tabela-verdade.</string>
  <string name="menu_table_N_variables">{0} variáveis</string>
  <string name="menu_table_create">Criar</string>
  <string name="menu_table_createCUPL_tt">Criar um arquivo fonte CUPL contendo a definição do circuito.</string>
  <string name="menu_table_createTT2_tt">Criar o arquivo contendo descrição segundo o formato Berkeley Logic Interchange Format (BLIF).
        Dessa forma o filtro Atmel será iniciado para criar o arquivo JEDEC.</string>
  <string name="menu_table_createCircuit">Circuito</string>
  <string name="menu_table_createCircuit_tt">Criar um circuito capaz de reproduzir a tabela-verdade.</string>
  <string name="menu_table_createCircuitJK">Circuito com flip-flops JK</string>
  <string name="menu_table_createCircuitJK_tt">Criar um circuito capaz de reproduzir a tabela-verdade. Usar flip-flops JK.</string>
  <string name="menu_table_createCircuitLUT">Circuito com LUTs</string>
  <string name="menu_table_createCircuitLUT_tt">Criar um circuito que reproduzirá uma tabela-verdade. Usará LUTs (LookUp Tables) para criar as expressões.</string>
  <string name="menu_table_createNAnd">Circuito com portas NAND</string>
  <string name="menu_table_createNAndTwo">Circuito com portas NAND com duas entradas</string>
  <string name="menu_table_createNAndTwo_tt">Usar apenas portas NAND com duas entradas.</string>
  <string name="menu_table_createNAnd_tt">Criar um circuito capaz de reproduzir a tabela-verdade com apenas portas NAND.</string>
  <string name="menu_table_createNOr">Circuito com portas NOR</string>
  <string name="menu_table_createNOrTwo">Circuito com portas NOR com duas entradas</string>
  <string name="menu_table_createNOrTwo_tt">Usar somente portas NOR com duas entradas.</string>
  <string name="menu_table_createNOr_tt">Criar um circuito capaz de reproduzir a tabela-verdade com apenas portas NOR.</string>
  <string name="menu_table_create_hardware">Dispositivo</string>
  <string name="menu_table_create_jedec_tt">Criar arquivo JEDEC para o dispositivo</string>
  <string name="menu_table_exportTableLaTeX">Exportar LaTeX</string>
  <string name="menu_table_exportHex">HEX</string>
  <string name="menu_table_exportHex_tt">É possível carregar um arquivo HEX em uma ROM ou em uma LUT.</string>
  <string name="menu_table_new">Novo</string>
  <string name="menu_table_new_combinatorial">Combinacional</string>
  <string name="menu_table_new_sequential">Sequencial</string>
  <string name="menu_table_new_sequential_bidir">Sequencial bidirecional</string>
  <string name="menu_table_reorder_inputs">Reordenar/remover variáveis de entrada</string>
  <string name="menu_table_columnsAddVariable">Adicionar variável de entrada</string>
  <string name="menu_table_columnsAddVariable_tt">Adicionar uma nova variável de entrada à tabela.</string>
  <string name="menu_table_reorder_outputs">Reordenar/remover colunas de saída</string>
  <string name="menu_table_columnsAdd">Adicionar coluna de saída</string>
  <string name="menu_table_columnsAdd_tt">Adicionar uma nova coluna de resultado à tabela.</string>
  <string name="menu_table_setXTo0">Definir X como 0</string>
  <string name="menu_table_setXTo0_tt">Definir "don't cares" como 0.</string>
  <string name="menu_table_setXTo1">Definir X como 1</string>
  <string name="menu_table_setXTo1_tt">Definir "don't cares" como 1.</string>
  <string name="menu_table_JK">Criar expressões com J/K</string>
  <string name="menu_table_setAllToX">Definir todos os valores como X</string>
  <string name="menu_table_setAllToX_tt">Definir todos os valores como "don't care".</string>
  <string name="menu_table_setAllTo0">Definir todos os valores como 0</string>
  <string name="menu_table_setAllTo0_tt">Definir todos os valores como zero.</string>
  <string name="menu_table_setAllTo1">Definir todos os valores como 1</string>
  <string name="menu_table_setAllTo1_tt">Definir todos os valores como um.</string>
  <string name="menu_terminalDelete">Apagar</string>
  <string name="menu_terminalDelete_tt">Apagar o conteúdo do terminal.</string>
  <string name="menu_view">Visualizar</string>
  
  
  <string name="menu_expression">Expressão</string>
  <string name="menu_expression_tt">Criar circuito dada a expressão.</string>
  <string name="menu_runTests">Executar testes</string>
  <string name="menu_runTests_tt">Executar todos os casos de testes</string>
  <string name="menu_actualToDefault">Definir entradas padrões</string>
  <string name="menu_actualToDefault_tt">Usar os valores atuais das entradas como padrão.</string>
  <string name="menu_restoreAllFuses">Reiniciar diodos e FGFETs</string>
  <string name="menu_restoreAllFuses_tt">Reiniciar todos os diodos (fusíveis) e FGFETs como "não programados". A configuração vigente dos fusíveis será descartada!</string>
  <string name="menu_programDiode">Programar diodo</string>
  <string name="menu_help_elements">Componentes</string>
  <string name="menu_help_elements_tt">Mostrar a lista de todos os componentes disponíveis.</string>
  <string name="menu_viewHelp">Caixa de diálogo para ajuda</string>
  <string name="menu_viewHelp_tt">Mostrar a caixa de diálogo para ajuda com a descrição do circuito corrente.</string>
  <string name="menu_probe_memory">Memória</string>
  <string name="menu_probe_memory_tt">Mostrar os conteúdos dos componentes de memória.</string>
  <string name="menu_treeSelect">Hierarquia de componentes</string>
  <string name="menu_treeSelect_tt">Mostrar a hierarquia de componentes à esquerda.</string>
  <string name="menu_karnaughMap">K-Map</string>
  <string name="menu_karnaughMap_tt">Mostrar a representação K-Map da tabela!</string>
  <string name="menu_special">Funções 74xx especiais</string>
  <string name="menu_addPrefix">Adicionar prefixo para entrada e saída</string>
  <string name="menu_addPrefix_tt">Um prefixo será adicionado a todas as entradas e saídas selecionadas.
        Isso será usado para simplificar a duplicação de circuitos dentro dos 74xx.</string>
  <string name="menu_removePrefix">Remover prefixo para entrada e sáida</string>
  <string name="menu_removePrefix_tt">O primeiro caractere dos rótulos das entradas e saídas será removido.
        Isso será usado para simplificar a duplicação de circuitos dentro dos 74xx.</string>
  <string name="menu_numbering">Assistente para pino</string>
  <string name="menu_numbering_tt">Assistente para aplicar números de pinos às entradas e às saídas.</string>
  <string name="menu_removePinNumbers">Remover números de pinos</string>
  <string name="menu_removePinNumbers_tt">Removerá todos os números de pinos em um circuito</string>
  <string name="msg_pin_numbering_N">Selecionar pino {0}:</string>
  <string name="menu_undo">Desfazer</string>
  <string name="menu_undo_tt">Reverter a última modificação</string>
  <string name="menu_redo">Refazer</string>
  <string name="menu_redo_tt">Aplicar a última modificação revertida de novo.</string>
  <string name="menu_showDataAsGraph">Mostrar gráfico</string>
  <string name="menu_showDataAsGraph_tt">Mostrar os dados em forma gráfica.</string>
  <string name="menu_showDataAsTable">Mostrar tabela</string>
  <string name="menu_showDataAsTable_tt">Mostrar valores com uma tabela.</string>
  <string name="menu_addPowerSupply">Adicionar fonte de alimentação</string>
  <string name="menu_addPowerSupply_tt">Adicionar uma fonte de potência para o circuito.</string>
  <string name="menu_exportVHDL">Exportar para VHDL</string>
  <string name="menu_exportVHDL_tt">Exportar o circuito para VHDL</string>
  <string name="menu_exportVerilog">Exportar para Verilog</string>
  <string name="menu_exportVerilog_tt">Exportar o circuito para Verilog</string>
  <string name="menu_pdfDocumentation">Documentação</string>
  <string name="menu_openPdfDocumentation">Abrir {0}</string>
    <string name="msg_errorOpeningDocumentation">Erro ao abrir arquivo PDF!</string>
    <string name="menu_showDataGraph">Mostrar o gráfico de medições</string>
    <string name="menu_showDataGraph_tt">Mostrar o gráfico com os valores medidos em janela separada.</string>
    <string name="menu_showDataTable">Mostrar tabela com valores medidos</string>
    <string name="menu_showDataTable_tt">Mostrar tabela com valores medidos em janela separada.</string>
    <string name="menu_exportZIP">Exportar para arquivo ZIP</string>
    <string name="menu_exportZIP_tt">Exportar o circuito para um arquivo ZIP.
        O arquivo ZIP conterá todos os arquivos que forem necessários para a operação do circuito.
    </string>
    <string name="menu_labelPins">Rotular entradas e saídas</string>
    <string name="menu_labelPins_tt">Definir rótulo para entradas e saídas que não tiverem algum.</string>
    <string name="message"><![CDATA[<h1>Digital</h1>
      <p>Um simulator simples para circuitos digitais.</p>
      <p>Elaborado por H. Neemann em 2016-2023.</p>
      <p>Os ícones foram tomados de <a href="http://tango.freedesktop.org">Tango Desktop Project</a>.</p>
      <p>Para conhecer melhor o projeto, visitar <a href="https://github.com/hneemann/[[name]]">GitHub</a>.
      Última versão disponível em <a href="https://github.com/hneemann/[[name]]/releases/latest">download</a>.</p>
      <p>Questões poderão ser endereçadas para <a
      href="https://github.com/hneemann/[[name]]/issues/new?body=version:%20[[version]]&labels=bug">issue</a>
      ou sugestões
      para <a href="https://github.com/hneemann/[[name]]/issues/new?labels=enhancement">enhancement</a>.</p>]]></string>
    <string name="msg_N_nodes">{0} nodos</string>
    <string name="msg_analyseErr">Erro ao analisar o circuito</string>
    <string name="msg_color">Cor</string>
    <string name="msg_errorCalculatingStep">Erro ao calcular um passo</string>
    <string name="msg_errorCreatingModel">Erro ao criar o circuito</string>
    <string name="msg_errorDuringCalculation">Erro durante a simplificação</string>
    <string name="msg_errorDuringHardwareExport">Erro durante a criação da configuração de hardware.</string>
    <string name="msg_errorEditingValue">Erro ao editar um valor de atributo</string>
  <string name="msg_errorImportingModel_N0">Erro ao importar o circuito {0}!</string>
  <string name="msg_errorUpdatingLibrary">Erro ao atualizar a biblioteca de componentes!!</string>
  <string name="msg_errorReadingFile">Erro ao ler arquivo</string>
  <string name="msg_errorWritingFile">Erro ao escrever arquivo</string>
  <string name="msg_frequency_N">A frequência máxima é de {0} kHz</string>
  <string name="msg_missingShape_N">Formato {0} não encontrado</string>
  <string name="msg_pins">Atribuição de pino</string>
  <string name="msg_pinMap_pin_N_is_N">Pino {0}: {1}</string>
  <string name="msg_restartNeeded">Reinicialização é necessária para que as mudanças possam ter efeito!</string>
  <string name="msg_remoteUnknownCommand">Comando {0} desconhecido!</string>
  <string name="msg_enterAnExpression">Entrar com uma expressão:</string>
  <string name="msg_runningTestError">Erro ao executar os testes:</string>
  <string name="msg_testResult">Resultado de teste</string>
  <string name="msg_test_N_Passed">{0} com êxito</string>
  <string name="msg_test_N_Failed">{0} com falha</string>
  
  <string name="msg_creatingHelp">Erro ao criar a ajuda!</string>
  <string name="msg_clipboardContainsNoImportableData">A área de transferência não contém dados para importar!</string>
  <string name="msg_selectAnEmptyFolder">Selecionado arquivo vazio!</string>
  <string name="msg_fitterResult">Mensagem de filtro externo</string>
  <string name="msg_startExternalFitter">Execução de filtro externo</string>
  <string name="msg_actualCircuit">Circuito corrente</string>
  <string name="msg_fileNotAccessible">O nome de arquivo selecionado não pode ser importado para o projeto corrente!</string>
  <string name="msg_fileIsNotUnique">O nome de arquivo não é único!
        Todos os arquivos na pasta de trabalho e em todas as subpastas deverão ter nomes únicos. Isso também se aplicará
        à pasta com a biblioteca. Se a pasta de trabalho contiver um arquivo 7400.dig, esse não poderá ser usado or ou buscado em
        biblioteca.
        Se houver um arquivo 7400.dig na pasta de trabalho, não poderá ser usado ou buscado em biblioteca,
        porque esse nome de arquivo não poderá mais ser usado.</string>
  <string name="msg_duplicateLibraryFiles">Há vários arquivos com nomes idênticos, os quais não poderão ser usados 
        de forma exclusiva! Nessa condição estão:</string>
  <string name="msg_and_N_More">e {0} mais.</string>
  <string name="msg_fileNotImportedYet">O arquivo ainda não foi importado.</string>
  <string name="msg_fileExists">O arquivo {0} já existe! Sobrescrever?</string>
  <string name="msg_test_missingLines">(Entradas demais!)</string>
  <string name="msg_test_missingLines_tt">Todos os testes foram executados, mas nem todos os resultados mostrados.
        A avaliação dos resultados de testes, no entando, é considerada correta!</string>
  <string name="msg_isLocked">A edição do circuito está suspensa. O bloqueio poderá ser removido em 
        "{0} -&gt; {1} -&gt; {2}".
        Entretanto, copiar componentes e a configuração de diodos e FG-FETs será possível pelo uso da tecla [P] mesmo durante o bloqueio.</string>
  <string name="msg_speedTestError">Erro durante o teste de velocidade!</string>
  <string name="msg_pin_N">Pino {0}</string>
  <string name="msg_numberingWizard">Assistente para a numeração</string>
  <string name="msg_framesWritten_N">Quadros escritos: {0}</string>
  <string name="msg_errorWritingGif">Erro ao gravar o arquivo GIF!</string>
  <string name="btn_gifComplete">Pronto</string>
  <string name="btn_gifComplete_tt">O arquivo GIF está completo e fechado.</string>
  <string name="msg_gifExport">Exportar GIF</string>
  <string name="msg_errCausedBy">causado por</string>
  <string name="msg_inputsToInvert">entradas a inverter</string>
  <string name="msg_none">nenhum</string>
  <string name="msg_errGettingPinNames">Não foi possível determinar os nomes dos pinos.</string>
  <string name="msg_errInFile_N">Ocorrido no arquivo {0}.</string>
  <string name="msg_affectedComponentsAre_N">Afetados estão: {0}.</string>
  <string name="msg_signal_N">Sinal {0}</string>
  <string name="msg_thereAreMissingPinNumbers">Não há números PIN atribuídos aos pinos {0}!
        Pinos livres receberão atribuição automática. O circuito não poderá, portanto, ser usado em um hardware real na maioria dos casos!</string>
  <string name="msg_modelHasErrors">Somente será possível exportar um circuito sem erros!</string>
  <string name="msg_noKVMapAvailable">Nenhum  K- Map disponível!</string>
  <string name="msg_dataNotUpdatedAnymore">Dados não serão mais atualizados!</string>
  <string name="msg_modifyThisAttribute">Modificar esse valor</string>
  <string name="msg_invalidEditorValue">Um dos campos contém valor inválido!</string>
  <string name="msg_create CHNFile">Criação de arquivo CHN.</string>
  <string name="msg_tableHasManyRowsConfirm">O tamanho da tabela exigirá um tempo bem maior para sua exportação.
        Iniciar a exportação assim mesmo?</string>
  <string name="msg_circuitIsRequired">Para criar a descrição de hardware, um circuito deverá ser criado e analisado.
        Uma tabela-verdade sozinha não poderá ser usada para gerar uma descrição de hardware.</string>
  <string name="win_romDialog">ROM's incluídas</string>
  <string name="msg_noData">não há dados</string>
  <string name="msg_errorClosingExternalProcess">Não foi possível fechar o processo externo!</string>
  <string name="msg_checkResult">Verificar resultado:</string>
  <string name="btn_checkCode">Verificar</string>
  <string name="btn_checkCode_tt">Iniciar a aplicação para verificar se um código fornecido está correto.
        Se esse não for o caso, a mensagem de erro para aplicação externa será apresentada.
        Se possível, as definições de entradas e saídas também serão adaptadas a paritr desse código.</string>
  <string name="msg_applicationFileNotFound">Arquivo executável "{0}" não encontrado!</string>
  <string name="msg_enterText">Entrar texto!</string>
  <string name="btn_startATMISP">Iniciar ATMISP</string>
  <string name="btn_startATMISP_tt">Iniciar o programa externo ATMISP. Esse deverá estar previamente instalado.</string>
  <string name="msg_errorStartingATMISP">Erro ao iniciar ATMISP!
        O caminho para o arquivo executável ATMISP.exe especificado nas configurações está correto?</string>
  <string name="msg_ATMISPIsStillRunning">ATMISP já está em execução!
        Após o fechamento desse diálogo, o ATMISP será encerrado!
        Certificar-se que o processo esteja completo antes de fechar esse diálogo!</string>
  <string name="menu_runAllTests">Executar todos os testes</string>
  <string name="menu_runAllTests_tt">Executar todos os testes na pasta corrente.</string>
  <string name="msg_testPassed_N">{0} linhas de testes aprovadas</string>
  <string name="msg_testFile">Arquivo testado</string>
  <string name="msg_truthTable">Tabela-verdade</string>
  <string name="msg_errorImportingSvg">Erro ao importar o arquivo SVG.</string>
  <string name="msg_errorCreatingSvgTemplate">Erro ao criar o modelo SVG.</string>
  <string name="ok">OK</string>
  <string name="rot_0">0°</string>
  <string name="rot_180">180°</string>
  <string name="rot_270">270°</string>
  <string name="rot_90">90°</string>
  <string name="stat_clocks">Interrupção após {0} meio ciclos no ponto de parada "{1}".</string>
  <string name="tt_deleteItem">Remover o item selecionado</string>
  <string name="tt_moveItemDown">Mover o item para baixo</string>
  <string name="tt_moveItemUp">Mover o item para cima</string>
  <string name="win_allSolutions">Todas as soluções possíveis</string>
  <string name="win_confirmExit">Confirmar a saída!</string>
  <string name="win_measures">Medidas</string>
  <string name="win_measures_fullstep">Medidas na maior velocidade</string>
  <string name="win_measures_microstep">Medidas no modo passo-a-passo</string>
  <string name="win_saveChanges">Salvar alterações?</string>
  <string name="win_stateChanged">Estado alterado!</string>
  <string name="win_table">Tabela</string>
  <string name="win_table_exportDialog">Exportar</string>
  <string name="win_itempicker_title">Selecionar</string>
  <string name="win_testdata_N">Dados de teste {0}</string>
  <string name="win_data">Dados</string>
  <string name="win_valueInputTitle_N">Entrada {0}</string>
  <string name="win_karnaughMap">Mapa de Karnaugh</string>
  <string name="btn_help">Ajuda</string>
  <string name="win_romDialogHelpTitle">Conteúdo de ROM Central</string>
  <string name="msg_romDialogHelp"><![CDATA[<html>
        <h3>Motivação</h3>
        Quando um circuito contendo uma é incorporado múltiplas vezes, os conteúdos da ROM
        serão normalmente utilizados em cada instância desse circuito. Sob certas circunstâncias,
        no entanto, poderá ser desejável que tal circuito possa ser incorporado várias vezes,
        mas com diferentes conteúdos em ROM para cada instância.<br/>
        Esse problema ocorre, por exemplo, se uma ROM 74xx for usada várias vezes, mas com diferentes
        conteúdos de memória.<br/>
        <h3>Função</h3>
        Nesse local, portanto, os conteúdos poderão ser definidos para todas as ROM's no circuito.
        Quando o modelo de simulação for gerado, cada ROM será inicializada com os conteúdos armazenados
        diretamente na respectiva ROM. Em seguida será verificado se há um conteúdo alternativo 
        definido aqui. Se esse for o caso, o conteúdo definido aqui será carregado na respectiva ROM.
        <h3>Uso</h3>
        Deve-se notar que cada ROM irá requerer um nome único usado como identificação.
        Para isso, usar o asterico ('*') no rótulo da ROM. O asterisco será então substituído pelo caminho completo
        constituído pelos nomes dos circuitos integrados.
        Se um circuito contiver apenas uma única ROM, isso será suficiente para se usar o asterisco como rótulo.
        Todos os circuitos integrados deverão term nomes únicos para cada ROM.
        </html>]]></string>
    <string name="msg_newRelease_N"><![CDATA[<html>
        <h1>Nova versão {0} disponível</h1>
        <p>Há uma nova versão do simulador disponível.</p>
        <p>Em <a href="https://github.com/hneemann/[[name]]/releases/latest">Release Notes</a>
        poderão ser encontradas as alterações e melhorias.</p>
        <p>Em <a href="https://github.com/hneemann/[[name]]/releases/latest">download</a> se poderá encontrar a nova versão.</p>
        </html>]]></string>
    <string name="msg_expressionHelpTitle">Expressões</string>
    <string name="msg_expressionHelp"><![CDATA[
      <p>Para definir uma expressão poderão ser usadas todas as notações mais comuns:</p>
      <p>
      And: "&", "&&", "*", "∧"<br/>
      Or: "|", "||", "+", "∨", "#"<br/>
      XOr: "^", "⊻"<br/>
      Not: "!", "~", "¬"
      </p>
      <p>Como usual AND tem precedência sobre OR e XOR.</p>
      <p>Múltiplas expressões poderão ser separadas por "," ou ";".
      Se desejado dar nome às expressões se poderá usar o comando "let"
      "let U=A+B, let V=A*B"</p>]]>
    </string>
    <string name="msg_testVectorHelpTitle">Arranjos de teste</string>
    <string name="msg_testVectorHelp">&lt;html&gt;
        &lt;head&gt;&lt;style&gt;pre { background-color: #E0E0E0;}&lt;/style&gt;&lt;/head&gt;
        &lt;body&gt;
        &lt;h3&gt;Geral&lt;/h3&gt;
        &lt;p&gt;A primeira linha deverá conter os nomes das entradas e das saídas.
        As linhas seguintes deverão conter os valores esperados.
        Um 'X' representará um "don't care", e um 'Z' representará um valor em alta impedância.
        Se um 'C' for usado, inicialmente, todos os outros valores serão definidos, e após um ciclo de clock
        seus valores serão comparados. Dessa forma será mais fácil testar lógica sequencial.
        Um linha que for iniciada por um sinal ('#') será um comentário.&lt;/p&gt;

        &lt;p&gt;Dessa forma um teste para um contador de 2-bits poderia se parecer com isso:&lt;/p&gt;

        &lt;pre&gt;
        C  Q1 Q0
        0  0  0
        C  0  1
        C  1  0
        C  1  1
        C  0  0
        &lt;/pre&gt;
       
        &lt;p&gt;Os testes serão executados por Executar-&gt;Testes de execução.&lt;/p&gt;
        &lt;p&gt;
        Para tornar mais fácil a criação de muitos arranjos de testes, há o comando 'repeat([n])':
        Se um linha começar por 'repeat([n])', [n] linhas de testes serão geradas.
        A variável 'n' poderá ser usada para gerar os dados de testes. Por exemplo, 'repeat(16)'
        16 linhas serão criadas, onde n variar de 0 até 15. Se houver entradas com múltiplos bits,
        e esses forem definidos juntos por um valor binário, isso poderá ser feito usando o comando
        'bits([bits], [valor])'. Isso poderá ser usado para criar [bits] com esse [valor].&lt;/p&gt;

        &lt;p&gt;A seguir há um exemplo para testar um somador de 4-bits:&lt;/p&gt;

        &lt;pre&gt;
                   C_i-1  A_3 A_2 A_1 A_0  B_3 B_2 B_1 B_0  C_i S_3 S_2 S_1 S_0
        repeat(256)  0    bits(4,n&gt;&gt;4)     bits(4,n)        bits(5,(n&gt;&gt;4)+(n&amp;15))
        repeat(256)  1    bits(4,n&gt;&gt;4)     bits(4,n)        bits(5,(n&gt;&gt;4)+(n&amp;15)+1)
        &lt;/pre&gt;

        &lt;p&gt;
        Os sinais de entrada serão o carry-in (C_i-1) e os oito bits de entrada A_3-A_0 e B_3-B_0.
        Os 4 bits de entrada serão gerados pela instrução 'bits'. O resultado (C_i, S_3-S_0) também será gerado
        pela mesma instrução.
        Isso irá ocorrer um vez com C_i-1 = 0 e na próxima linha com C_i-1 = 1.
        Dessa forma, 512 linhas de testes serão geradas para cobrir todas as configurações possíveis das entradas.&lt;/p&gt;
        &lt;p&gt;Se múltiplas linhas forem repetidas, ou se repetições aninhadas forem requeridas, o comando de
        repetição poderá ser usado. O exemplo acima poderia ser implementado como mostrado a seguir:
        &lt;/p&gt;

        &lt;pre&gt;
                   C_i-1  A_3 A_2 A_1 A_0  B_3 B_2 B_1 B_0  C_i S_3 S_2 S_1 S_0
        loop(a,16)
          loop(b,16)
                     0    bits(4,a)        bits(4,b)        bits(5,a+b)
                     1    bits(4,a)        bits(4,b)        bits(5,a+b+1)
          end loop
        end loop
        &lt;/pre&gt;

        &lt;p&gt;
        Sob certas circunstâncias poderá necessitar ser capaz de reagir ao estado inicial do circuito.
        Portanto, os sinais fornecidos pelo circuito poderão ser usados como caso de teste.
        Por exemplo, se um contador que for iniciado em um estado indefinido for testado,
        poderá ser levado a um estado definido na variação do clock:
        &lt;/p&gt;

        &lt;pre&gt;C Q_3 Q_2 Q_1 Q_0

        # clock counter to 1111
        while(!(Q_3 &amp; Q_2 &amp; Q_1 &amp; Q_0))
        C x x x x
        end while

        # start the test execution
        repeat(16) C bits(4,n)
        &lt;/pre&gt;
        
        &lt;p&gt;
        Poderá ser útil para gerar valores aleatórios para casos de testes.
        Isso poderá ser criado pela função 'random([n])'. O valor gerado será maior ou igual a
        zero e menor que [n]. Considerando um multiplicador de 16-bits como exemplo,
        um teste completo não poderá ser executado pois deveria ter 2^32 combinações das entradas.
        Um teste de regressão para multiplicar 100000 valores aleatórios poderia se parecer como isso:
        &lt;/p&gt;

        &lt;pre&gt;
        A B Y
        loop(i,100000)
        let a = random(1&amp;lt;&amp;lt;16);
        let b = random(1&amp;lt;&amp;lt;16);
        (a) (b) (a*b)
        end loop
        &lt;/pre&gt;

        &lt;p&gt;
        Uma entrada que permita um valor em alta impedância também poderá ser usada como valor de saída para
        teste.
        Nesse caso, o nome do sinal poderá ser usado com o sufixo '_out' para ser lido de volta e ter o valor comparado.
        Para isso, a entrada correspondente deverá ser definida como de alta impedância ('Z').&lt;/p&gt;

        &lt;pre&gt;
        OE CLK D D_out
        0  0   0 0
        0  C   1 1
        1  0   z 1
        0  C   0 0
        1  0   z 0
        &lt;/pre&gt;

        &lt;p&gt;
        O circuito para esse teste deverá ter apenas uma entrada 'D', a qual poderá estar em estado de alta
        impedância.
        Portanto, o sinal 'D_out' também será avaliado para se verificar o valor desse caso.&lt;/p&gt;

        &lt;p&gt;
        Em casos especiais, pode ser desejável usar sinais providos pelo circuito,
        derivar um novo sinal, e então testá-lo. Um exemplo poderá ser o de um barramento
        de sinal com vários bits, onde apenas um único bit deverá ser testado, enquanto os
        outros não terão qualquer influência sobre o teste. Nesse caso, um novo sinal poderá
        ser gerado, no próprio teste, apenas para conter esse bit, de modo que outros testes
        possam ser definidos para o mesmo.        
        &lt;/p&gt;
        
        &lt;p&gt;Isso poderá ser feito pelo comando 'declare':&lt;/p&gt;

        &lt;pre&gt;A B Bit

        declare Bit = (Bus&gt;&gt;3)&amp;1;

        0 0  0
        0 1  0
        1 0  1
        1 1  0
        &lt;/pre&gt;

        &lt;p&gt;
        Nesse exemplo, o terceiro bit será isolado do sinal do barramento ('Bus') e
        tornado disponível como o sinal 'Bit' para teste. O circuito em si não terá 'Bit' como saída.
        &lt;/p&gt;

        &lt;h3&gt;Funções&lt;/h3&gt;
        &lt;p&gt;As funções disponíveis são:
        &lt;dl&gt;
        &lt;dt&gt;signExt([bits],[value])&lt;/dt&gt;
        &lt;dd&gt;Extender o valor [value] preservando o sinal em [bits] bits.&lt;/dd&gt;
        &lt;dt&gt;random([max])&lt;/dt&gt;
        &lt;dd&gt;Retornar um valor inteiro aleatório. O valor máximo será especificado por [max].&lt;/dd&gt;
        &lt;dt&gt;ite([cond],[then],[else])&lt;/dt&gt;
        &lt;dd&gt;Se a condição [cond] for verdadeira, o valor [then] será retornado; caso contrário, será o valor [else].&lt;/dd&gt;
        &lt;/dl&gt;
        &lt;/p&gt;

        
&lt;h3&gt;Processadores&lt;/h3&gt;

        &lt;p&gt;
        Se processadores forem testados, normalmente a inicialização de processador será requerida.
        É possível executar essa inicialização no próprio caso de teste.
        Dessa forma, vários testes poderão ser acomodados em um circuito e cada teste poderá ter sua prória inicialização.
        Há três instruções para executar essa inicialização:
        &lt;/p&gt;
        
        &lt;ul&gt;
        &lt;li&gt;
        O comando 'program' poderá ser usado para sobrescrever a memória de programa do processador.
        A instrução &lt;pre&gt;program(0x8000,0x2d11,0x8000,0x2f21)&lt;/pre&gt; colocará quatro palavras no início da
        memória de programa. Todas as outras palavras serão iguais a zero.
        &lt;/li&gt;
        &lt;li&gt;
        A instrução 'memory' podrá ser usada para guardar valor em componente do tipo RAM:
        &lt;pre&gt;memory mem(3)=7;&lt;/pre&gt;
        Esse exemplo guardará o valor 7 na memória identificada por 'mem' no endereço 3.
        &lt;/li&gt;
        &lt;li&gt; 
        Um registrador identificado poderá ser sobrescrito com o comando 'init'.
        &lt;pre&gt;init R0=22;&lt;/pre&gt;
        Essa instrução sobrescreverá o registrador identificado por 'R0' com o valor 22.
        &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;
        Deve-se notar que todas as inicializações somente serão aplicadas uma única vez
        antes da execução do teste, independente da linha no caso de teste onde esses comandos
        possam estar. Contudo, não devem ser usados antes da linha de cabeçalho
        que relaciona os nomes dos sinais.
        &lt;/p&gt;
        
        &lt;/body&gt;&lt;/html&gt;</string>
  <string name="fsm_title">Máquina de Estados Finitos (FSM)</string>
  <string name="fsm_noMove">Nenhuma transição</string>
  <string name="fsm_moveTrans">Transições</string>
  <string name="fsm_moveStates">Transições+Estados</string>
  <string name="fsm_set_N">definido {0}</string>
  <string name="menu_fsm">Máquina de Estados Finitos (FSM)</string>
  <string name="menu_fsm_tt">Abrir uma caixa de diálogo para editar a Máquina de Estados Finitos (FSM).</string>
  <string name="menu_fsm_create">Criar</string>
  <string name="menu_fsm_create_table">Tabela de transições de estado</string>
  <string name="menu_fsm_create_counter">Criar contador</string>
  <string name="menu_fsm_create_counter_N">{0} estados</string>
  <string name="menu_fsm_Help_tt">Ajuda para operar o editor FSM.</string>
  <string name="err_notDeterministic_N">A FSM não é determinística: {0}</string>
  <string name="err_fsmNumberUsedTwice_N">Estado número {0} usada duas vezes.</string>
  <string name="err_fsmNoInitialState">Não há estado inicial (estado inicial zero).</string>
  <string name="err_fsmState_N_notFound">Estado ''{0}'' não encontrado!</string>
  <string name="err_fsmInvalidOutputAssignment_N">Atribuição errada para a saída (''{0}'')!</string>
  <string name="err_fsmErrorInCondition_N">Erro na condição ''{0}''!</string>
  <string name="key_stateNum">Número do Estado</string>
  <string name="key_stateNum_tt">O número que representa esse estado.</string>
  <string name="key_isInitialState">Estado inicial</string>
  <string name="key_isInitialState_tt">Se definido, esse será o estado inicial.</string>
  <string name="key_stateValues">Saídas</string>
  <string name="key_stateValues_tt">Definirá os valores de saídas.
        Com atribuições simples como "A=1, B=0" as saídas poderão ser definidas.
        Com instruções como "A=101", saídas com múltiplos bits poderão ser definidas.
        Saídas que não forem definidas aqui  terão valor igual a zero nos estados.
        Para transições, saídas não especificas permanecerão inalteradas.</string>
  <string name="key_transCond">Condição</string>
  <string name="key_transCond_tt">Uma expressão booleana.</string>
  <string name="key_transRad">Raio</string>
  <string name="key_transRad_tt">Raio do círculo.</string>
  <string name="msg_fsmCantCreateTable">Não é possível criar a tabela de transições de estado.</string>
  <string name="msg_fsmNewState">Novo estado</string>
  <string name="msg_fsm_errorLoadingFile">Erro ao carregar um arquivo!</string>
  <string name="msg_fsm_errorStoringFile">Erro ao armazenar em um arquivo!</string>
  <string name="msg_fsmHelpTitle">Ajuda do editor de FSM</string>
  <string name="msg_fsmHelp"><![CDATA[<html><head></head>
<body>
  <h3>Operação do mouse</h3>
  <dl>
    <dt>Criar um estado:</dt>
    <dd>Clicar o botão direito do mouse em área livre.</dd>
    <dt>Criar uma transição:</dt>
    <dd>Pressionar o botão direito do mouse no estado de origem e arrastar até o estado de destino.</dd>
    <dt>Remover um estado ou uma transição:</dt>
    <dd>Mover o mouse sobre o objeto e pressionar o botão [Del].</dd>
    <dt>Mover um estado ou uma transição:</dt>
    <dd>Pressionar o botão esquerdo do mouse e arrastar.</dd>
    <dt>Editar um estado ou uma transição:</dt>
    <dd>Clicar o botão direito do mouse sobre o estado ou a transição.</dd>
  </dl>
  <h3>Função de ajuda para layout</h3>
  <dl>
    <dt>nenhum movimento:</dt>
    <dd>A função de ajuda para layout desabilitada.</dd>
    <dt>Transições:</dt>
    <dd>A função de ajuda para layout moverá as setas da transição para evitar sobreposições.</dd>
    <dt>Transições+Estados</dt>
    <dd>A função de ajuda para layout moverá ambos, estados e transitções, para ajudar a criar um layout bem equilibrado.</dd>
  </dl>
  <h3>Interpretação das transições</h3>
  Para simplificar a geração de um autômato determinístico, transições incondicionais serão tratadas de forma especial:
  uma transição incondicional somente será executada se nenhuma outra satisfizer a condição de transição.
  Portanto, não poderá haver uma transição incondicional e transições condicionais que comecem no mesmo estado.
  Uma transição incondicional determinará para qual estado a máquina de estado se deslocará, se nenhuma outra transição
  condição puder ser atendida.
  Se não houver nenhuma transição incondicional a partir de um estado, a máquina permanecerá nesse estado se nenhuma outra
  condição de transição puder ser atendida.
</body></html>]]></string>
  <string name="err_clockIsNotUsed">O componente de clock não está sendo usado!</string>
  <string name="msg_optimizationInProgress">Equações estão sendo calculadas! Favor aguardar um instante!</string>
  <string name="err_hdlNotKnown_N">HDL desconhecido: {0}</string>
  <string name="msg_errorStartCommand_N">Erro ao iniciar o comando {0}</string>
  <string name="key_enabled">Habilitado</string>
  <string name="key_enabled_tt">Habilitar ou desabilitar o componente.</string>
  <string name="key_toolChainConfig">Configuração de ferramentas</string>
  <string name="key_toolChainConfig_tt">Usado para configurar uma integração a um conjunto de ferramentas.
        Permitirá o lançamento de ferramentas externas, por exemplo, para se programar FPGA ou similar.</string>
  <string name="menu_stats">Estatísticas do circuito</string>
  <string name="menu_stats_tt">Mostrar uma lista de componentes usados.</string>
  <string name="stat_number">Número</string>
  <string name="stat_part">Componente</string>
  <string name="msg_couldNotCreateStats">Não foi possível levantar as estatísticas.</string>
  <string name="msg_errorReadingToolchainConfig_N">Erro ao ler a configuração do conjunto de ferramentas {0}</string>
  <string name="msg_commandStarted_N">Comando "{0}" iniciado! O processamento poderá demorar!-</string>
  <string name="msg_commandEnded_N">O comando "{0}" foi executado!</string>
  <string name="err_thereIsAUnnamedIO">-Há uma entrada ou saída sem nome!</string>
  <string name="err_NameOfIOIsInvalidOrNotUnique_N">-O sinal de nome "{0}" é inválido ou está repetido!}</string>
  <string name="err_substitutingError">-Erro ao substituir componentes para a análise.</string>
  <string name="err_evaluatingGenericsCode_N_N">Erro na avaliação do código genérico do circuito. Código
        {1}
        no componente: {0}</string>
  <string name="msg_errParsingGenerics">Erro durante a varredura do código genérico.</string>
  <string name="key_generic">Parametrização genérica</string>
  <string name="key_generic_tt">Comandos para generalizar um circuito.</string>
  <string name="key_isGeneric">Circuito é genérico</string>
  <string name="key_isGeneric_tt">Permite criar um circuito genérico.</string>
  <string name="key_showTutorial">Mostrar o tutorial na abertura</string>
  <string name="key_showTutorial_tt">Habilitar o tutorial.</string>
  <string name="menu_runToBreakMicro">Executar até interrupção em modo de porta simples</string>
  <string name="menu_runToBreakMicro_tt">Executar todos os passos até uma borda de subida ser detectada em um componente sujeito a interrupção.
        Se não houver componente sujeito a interrupção, o restante dos passos serão executados.</string>
  <string name="stat_inputs">Entradas</string>
  <string name="stat_bits">Bits</string>
  <string name="stat_addrBits">Bits de endereço</string>
  <string name="tutorial">Tutorial</string>
  <string name="tutorial1">A seguir, em um breve tutorial, a criação de um circuito simples será apresentada:

        Primeiro, inserir uma entrada no circuito. Essa entrada poderá ser encontrada no menu Componentes ▸IO.</string>
  <string name="tutorial2">Depois, acrescentar uma segunda entrada ao circuito. Também se poderá clicar na entrada na barra de ferramentas.
    
        É melhor colocar a segunda entrada ligeiramente abaixo da primeira.
        O circuito poderá ser movido mediante manter pressionado o botão direito do mouse.
        Ao clicar nos componentes, esses poderão ser movidos.</string>
  <string name="tutorial3">Em seguida, uma porta "OU-Exclusivo" deverá ser inserida.
         Essa porta poderá ser encontrada no menu Componentes▸Lógico.
         Posicionar esse componente um pouco mais distante, à direita das entradas.</string>
  <string name="tutorial4">O último componente a ser inserido será a saída.
        Posicionar esse componente um pouco mais distante, à direita da porta "OU-Exclusivo".</string>
  <string name="tutorial5">Para completar o circuito, fios para conexões deverão ser traçados.
    
         Clicar no pont vermelho da primeira entrada e conectá-lo à entrada da porta "OU-Exclusivo",
         e em seguida, clicar no ponto azul dessa porta.
         NÃO arrastar o botão com o botão do mouse pressionado.</string>
  <string name="tutorial6">Conectar o ponto vermelho na segunda entrada ao segundo ponto azul da porta "OU-Exclusivo"
        e o ponto vermelho dessa porta ao botão azul da saída.
        
        Durante o traçado, será possível ancorar o fio em qualquer ponto da área de trabalho bastando clicar nela.
        Se o botão direito do mouse for clicado, isso cancelará o traçado do fio (control-click no MacOS).</string>
  <string name="tutorial7">O primeiro circuito estará então funcional.
        Para iniciar a simulação, clicar no botão Play na barra de ferramentas.
        Se o mouse passar sobre a barra de ferramentas, dicas serão mostradas.</string>
  <string name="tutorial8">A simulação estará ativa. Para alterar as entradas, clicar nas mesmas.</string>
  <string name="tutorial9">Para parar a simulação, clicar no botão Stop na barra de ferramentas.</string>
    <string name="tutorial10">Para completar, as entradas e as saídas deverão ser rotuladas.

        Ao pressionar o botão da direita sobre uma entrada, uma caixa de diálogo se abrirá. No MacOs, usar
        control-click.
        A entrada poderá, então, receber um nome.
    </string>
    <string name="tutorial11">Rotular todas as entradas e as saídas.</string>
    <string name="tutorialUniqueIdents">Entradas e saídas sempre deverão ter nomes únicos.</string>
    <string name="tutorialNotNeeded">Pular o tutorial</string>
    <string name="msg_fsmTransition">Transição</string>
    <string name="msg_fsmState">Estado</string>
    <string name="elem_Seven-Seg_pin_ca">Ânodo comum. Para acender os LEDs, essa entrada deverá estar em nível alto.
    </string>
    <string name="key_commonConnectionType">Comum</string>
    <string name="key_commonConnectionType_tt">Tipo da conexão comum.</string>
    <string name="key_commonConnectionType_cathode">Cátodo</string>
    <string name="key_commonConnectionType_anode">Ânodo</string>
    <string name="key_wireToolTips">Dicas sobre conexões</string>
    <string name="key_wireToolTips_tt">Se habilitada, linhas serão destacadas quando o mouse passar sobre elas.</string>
    <string name="menu_table_showAllSolutions">Mostrar a caixa de diálogo com resultados</string>
    <string name="menu_table_showAllSolutions_tt">Mostrar a caixa de diálogo com resultados se tiver sido fechada
        manualmente.
    </string>
    <string name="msg_codeNotConsistent">Impossível criar definições de entrada e de saída automaticamente.
        Favor verificar as configurações|
    </string>
    <string name="elem_ButtonLED">Botão com LED</string>
    <string name="elem_ButtonLED_tt">Um botão simples que voltará ao seu estado original quando não estiver mais
        acionado.
        O botão possui um LED que poderá ser comutado via um sinal de entrada.
    </string>
    <string name="elem_ButtonLED_pin_out">O sinal de saída do botão.</string>
    <string name="elem_ButtonLED_pin_in">Entrada para controlar o LED.</string>
    <string name="elem_VGA">Monitor VGA</string>
    <string name="elem_VGA_tt">Analisar sinais de entrada de vídeo e exibir o correspondente gráfico.
        Como a simulação não ocorre em tempo real, além dos sinais de vídeo também será requerido o sinal de clock para
        os pixels.
    </string>
    <string name="elem_VGA_pin_R">O componente para cor vermelha.</string>
    <string name="elem_VGA_pin_G">O componente para cor verde</string>
    <string name="elem_VGA_pin_B">O componente para a cor azul</string>
    <string name="elem_VGA_pin_H">O sinal de sincronismo horizontal</string>
    <string name="elem_VGA_pin_V">O sinal de sincronismo vertical</string>
    <string name="elem_VGA_pin_C">O clock para os pixels</string>
    <string name="elem_PinControl">Controle do pino</string>
    <string name="elem_PinControl_tt">Lógica de controle para um pino bidirecional.
        Esse componente será necessário apenas no contexto para a geração de código VHDL ou Verilog,
        a fim de se criar uma porta bidirecional em HDL.
        Se não desejar usar uma porta de entrada e saída bidirecional em FPGA, não o use!
        O componente não poderá ser usado em circuito incorporado. Apenas será permitido no circuito de nível mais alto!
    </string>
    <string name="elem_PinControl_pin_wr">O dado a ser emitido.</string>
    <string name="elem_PinControl_pin_oe">Ativar a saída.</string>
    <string name="elem_PinControl_pin_rd">Os dados a serem lidos.</string>
    <string name="elem_PinControl_pin_pin">O conector para o pino corrente. Apenas um sinal de saída deverá estar
        conectado aqui.
    </string>
    <string name="err_customShapeHasNoPin_N">O formato personalizado não define um pino {0}</string>
    <string name="err_hdlMultipleOutputsConnectedToNet_N_N_N">Várias saídas estão conectadas entre si.
        Esse tipo de interconexão não tem suporte em HDL ({0}, {1}, {2}).
    </string>
    <string name="err_unnamedNet">Rede sem identificação</string>
    <string name="err_vgaModeNotDetected_N">Modo de vídeo não identificado ({0})</string>
    <string name="key_intFormat_oct">octal</string>
    <string name="key_mirror">Espelhamento</string>
    <string name="key_mirror_tt">Espelhar o componente em um circuito.</string>
    <string name="key_addValueToGraph">Mostrar medida graficamente</string>
    <string name="key_addValueToGraph_tt">Mostrar o valor de uma medida graficamente.</string>
    <string name="key_tunnelRenameDialog">Mostrar caixa de diálogo para se renomear túneis.</string>
    <string name="key_tunnelRenameDialog_tt">Se selecionado, uma caixa de diálogo será exibida para se renomear
        automaticamente todos os túneis de mesmo nome
        logo após um túnel tiver sido renomeado.
    </string>
    <string name="key_switchActsAsInput">Chave com comportamento semelhante a uma entrada</string>
    <string name="key_switchActsAsInput_tt">Se o modelo for analisado, a chave se comportará como uma entrada, onde
        "aberto" corresponderá a '0' e "fechado" a '1'
    </string>
    <string name="menu_exportSVGSettings">Configurações para se exportar no formato SVG</string>
    <string name="key_SVG_LaTeX">Texto em notação LaTeX</string>
    <string name="key_SVG_LaTeX_tt">Texto a ser inserido em notação LaTeX. Inkscape será necessário para processamento
        futuro.
    </string>
    <string name="key_SVG_pinsInMathMode">Rótulos para os pinos em modo matemático</string>
    <string name="key_SVG_pinsInMathMode_tt">Para os rótulos de pinos, usar o modo matemático mesmo se não contiver
        índices.
    </string>
    <string name="key_SVG_hideTest">Ocultar os casos de testes.</string>
    <string name="key_SVG_hideTest__">Os casos de testes não serão exportados.</string>
    <string name="key_SVG_noShapeFilling">Figuras não preenchidas</string>
    <string name="key_SVG_noShapeFilling_tt">Polígonos não preenchidos.</string>
    <string name="key_SVG_smallIO">Entradas e saídas pequenas</string>
    <string name="key_SVG_smallIO_tt">Entradas e saídas serão representadas por círculos pequenos.</string>
    <string name="key_SVG_noPinMarker">Sair da configuração de pinos.</string>
    <string name="key_SVG_noPinMarker_tt">Os marcadores de pinos nas cores azul e vermelha serão omitidos.</string>
    <string name="key_SVG_highContrast">Alto contraste</string>
    <string name="key_SVG_highContrast_tt">As conexões e o texto dos pinos serão exibidos em preto.</string>
    <string name="key_SVG_monochrome">Monocromático</string>
    <string name="key_SVG_monochrome_tt">Apenas tons de cinza serão usados.</string>
    <string name="key_SVG_thinnerLines">Linhas estreitas</string>
    <string name="key_SVG_thinnerLines_tt">Se selecionado, as linhas serão traçadas ligeiramente mais estreitas.
    </string>
    <string name="key_equalsInsteadOfPlus">Usar a tecla '='</string>
    <string name="key_equalsInsteadOfPlus_tt">Usar a tecla '=' ao invés da tela '+'.
        Isso será sempre útil se o caractere '+' não for uma tecla primária, em seu lugar o caractere '=' será usado,
        como acontece em teclados com os formatos em inglês ou francês.
    </string>
    <string name="key_snapToGrid">Aderência à grade</string>
    <string name="key_snapToGrid_tt">Se selecionado, o componente se alinhará à grade.</string>
    <string name="menu_table_createFunctionFixture">Exportar caso de teste</string>
    <string name="menu_table_createFunctionFixture_tt">Criar a descrição de um caso de teste para uso posterior.
    </string>
    <string name="menu_table_createFunctionFixture_isSequential">O caso de teste será funcional apenas se o circuito for
        puramente combinatório.
    </string>
    <string name="menu_table_invert">Inverter todos os bits</string>
    <string name="menu_table_invert_tt">Um "1" se tornará um "0" e vice versa. Outros valores não serão trocados.
    </string>
    <string name="menu_tutorial">Iniciar tutorial</string>
    <string name="menu_tutorial_tt">Abrir um tutorial para iniciante</string>
    <string name="msg_renameNet">Renomear rede</string>
    <string name="msg_renameNet_N_OLD_NEW">Há {0} mais túneis com o mesmo nome ''{1}''.
        É desejado renomear todos {0} para ''{2}''?
    </string>
    <string name="msg_dataWillBeLost_n">Deseja realmente descartar as alterações em "{0}"?</string>
    <string name="btn_copyToClipboard">Área de transferência</string>
    <string name="btn_copyToClipboard_tt">Copiar o texto para a área de transferência.</string>
    <string name="msg_graphHelpTitle">Medidas em modo gráfico</string>
    <string name="msg_graphHelp">&lt;html&gt;&lt;body&gt;
        &lt;h3&gt;O que poderá ser visto graficamente?&lt;/h3&gt;
        Diferente de um analisador lógico real, o eixo-X de uma medição gráfica não mostrará o tempo.
        Em lugar disso, um contador será exibido para indicar as mudanças de estado no circuito.
        Quando houver uma mudança no circuito, o contador será incrementado e o novo estado será exibido.&lt;br/&gt;
        Isso pode ser tomado como um analisador lógico clássico, que não guardará dados para otimização
        se nada houver alterações no circuito.
        Contudo, isso também significa que não será possível inferir, a partir do gráfico, se um intervalo maior ou
        menor
        ocorreu entre duas mudanças no circuito.&lt;br/&gt;
        Esse comportamento será resultante da natureza da simulação. A simulação do circuito desconhece o
        conceito de tempo. Uma alteração será aplicada ao circuito, e a mudança de estado correspondente será calculada,
        até que o circuito volte a se estabilizar de novo. Então, nova alteração será aplicada, e seu efeito será
        calculado,
        e assim por diante. Essas alterações serão contadas e seu valor será exibido no eixo-X do gráfico.&lt;br/&gt;
        Dentre outras coisas, isso também significa que um circuito não poderá ser submetido a overclock, uma vez que
        os efeitos da borda de descida do clock não serão calculados até que o circuito tenha se estabilizado
        após uma borda de subida.
        &lt;/body&gt;&lt;/html&gt;
    </string>
    <string name="elem_StepperMotorUnipolar">Motor de passos, unipolar</string>
    <string name="elem_StepperMotorUnipolar_tt">Motor de passos unipolar com duas chaves de fim de curso.
        Há suporte para controle por passo completo, meio-passo e .
    </string>
    <string name="elem_StepperMotorUnipolar_pin_S0">Chave de fim de curso 0, será 1 quando o ângulo do motor for 0°.
    </string>
    <string name="elem_StepperMotorUnipolar_pin_S1">Chave de fim de curso 1, será 1 quando o ângulo do motor for 180°.
    </string>
    <string name="elem_StepperMotorUnipolar_pin_P0">Fase 0</string>
    <string name="elem_StepperMotorUnipolar_pin_P1">Fase 1</string>
    <string name="elem_StepperMotorUnipolar_pin_P2">Fase 2</string>
    <string name="elem_StepperMotorUnipolar_pin_P3">Fase 3</string>
    <string name="elem_StepperMotorUnipolar_pin_com">Conexão da bobina com derivação central</string>
    <string name="elem_StepperMotorBipolar">Motor de passos, bipolar</string>
    <string name="elem_StepperMotorBipolar_tt">Motor de passos bipolar com duas chaves de fim de curso.
        Há suporte para controle por passo completo, meio passo e .
    </string>
    <string name="elem_StepperMotorBipolar_pin_S0">Chave de fim de curso 0, será 1 quando o ângulo do motor for 0°.
    </string>
    <string name="elem_StepperMotorBipolar_pin_S1">Chave de fim de curso 1, será 1 quando o ângulo do motor for 180°.
    </string>
    <string name="elem_StepperMotorBipolar_pin_A+">Bobina A, positivo</string>
    <string name="elem_Stop">Parar</string>
    <string name="elem_Stop_tt">Uma borda de subida na entrada irá parar a simulação.
        Terá o mesmo efeito que pressionar o botão Parar na barra de ferramentas.
    </string>
    <string name="elem_Stop_pin_stop">Um borda de subida irá parar a simulação.</string>
    <string name="err_ROM_noFileGivenToLoad">Não há nome de arquivo disponível para recarga automática!</string>
    <string name="attr_panel_Options">Opções</string>
    <string name="key_ghdlOptions">Opções GHDL</string>
    <string name="key_ghdlOptions_tt">Opções que serão usadas para todos os passos de processamento pelo GHDL.</string>
    <string name="key_layoutShapeDelta">Separador de pinos</string>
    <string name="key_layoutShapeDelta_tt">Usado pelo tipo de formato do layout. Indicará a distância do pino
        anterior.
    </string>
    <string name="key_colorScheme">Esquema de cores</string>
    <string name="key_colorScheme_DEFAULT">Normal</string>
    <string name="key_colorScheme_COLOR_BLIND">vermelho/verde para deficiência de cor</string>
    <string name="key_colorScheme_CUSTOM">Definido pelo usuário</string>
    <string name="menu_colorSchemePreset">Valor inicial</string>
    <string name="key_customColorScheme">Cores definidas pelo usuário</string>
    <string name="colorName_BACKGROUND">Plano de fundo</string>
    <string name="colorName_MAIN">Plano frontal</string>
    <string name="colorName_WIRE">Fio</string>
    <string name="colorName_WIRE_HIGH">Fio em nível alto</string>
    <string name="colorName_WIRE_LOW">Fio em nível baixo</string>
    <string name="colorName_WIRE_VALUE">Valor medido no fio</string>
    <string name="colorName_WIRE_OUT">Saída</string>
    <string name="colorName_WIRE_Z">Fio em alta impedância (Z)</string>
    <string name="colorName_ERROR">Erro</string>
    <string name="colorName_PASSED">Ok</string>
    <string name="colorName_PINS">Pinos</string>
    <string name="colorName_GRID">Malha</string>
    <string name="colorName_TESTCASE">Caso de teste</string>
    <string name="colorName_DISABLED">Desabilitado</string>
    <string name="colorName_ASYNC">Assíncrono</string>
    <string name="colorName_HIGHLIGHT">Destacado</string>
    <string name="lib_displays">Displays</string>
    <string name="lib_mechanic">Mecânica</string>
    <string name="lib_peripherals">Periféricos-</string>
    <string name="cli_cli">Interface para a linha de comandos</string>
    <string name="cli_nonOptionalArgumentMissing_N">Falta o argumento não opcional {0}</string>
    <string name="cli_notABool_N">O valor {0} não é lógico.</string>
    <string name="cli_notANumber_N">O valor {0} não é número.</string>
    <string name="cli_noArgument_N_available">Indefinido o argumento {0}.-</string>
    <string name="cli_notEnoughArgumentsGiven">Não há argumentos suficientes.</string>
    <string name="cli_toMuchArguments">Há argumentos demais.</string>
    <string name="cli_invalidType_N">Tipo inválido.</string>
    <string name="cli_command_N_hasNoSubCommand_N">O comando {0} não tem subcomando {1}.</string>
    <string name="cli_options">Opções:</string>
    <string name="cli_help_test">O primeiro nome de arquivo especificará o circuito a ser testado.
        Se um segundo nome de arquivo for especificado, os casos de testes serão executados a partir desse arquivo.
        Se não houver um segundo nome de arquivo especificado, os testes serão executados a partir do primeiro arquivo.
    </string>
    <string name="cli_help_test_circ">Nome do arquivo a ser testado.</string>
    <string name="cli_help_test_tests">Nome do arquivo com os casos para testes.</string>
    <string name="cli_help_test_allowMissingInputs">Permite-se que entradas faltantes no circuito sejam definidas no
        caso de teste. Isso poderá ser útil se houver
        várias soluções que possam depender de diferentes entradas.
    </string>
    <string name="cli_thereAreTestFailures">Testes falharam.</string>
    <string name="cli_errorExecutingTests">Um erro ocorreu durante a execução dos testes.</string>
    <string name="cli_help_svg">Poderá ser usado para criar um arquivo SVG a partir de um circuito.</string>
    <string name="cli_help_svg_dig">O nome do arquivo do circuito.</string>
    <string name="cli_help_svg_svg">O nome do arquivo SVG a ser gravado.</string>
    <string name="cli_help_svg_ieee">Usar símbolos IEEE.</string>
    <string name="cli_errorCreatingSVG">Erro na criação do arquivo SVG!</string>
    <string name="cli_help_stats">Criar arquivo CSV contendo estatísticas do circuito.
        Todos os components usados serão listados no arquivo CSV.
    </string>
    <string name="cli_help_stats_dig">Nome do arquivo contendo circuito.</string>
    <string name="cli_help_stats_csv">Nome do arquivo CSV a ser criado.
        Se essa opção for omitida, a tabela será escrita na saída padrão.
    </string>
    <string name="cli_errorCreatingStats">Erro ao criar o arquivo com estatísticas!</string>
    <string name="menu_table_exportTablePlainText">Exportar para texto puro</string>
    <string name="elem_StepperMotorBipolar_pin_A-">Bobina A, negativo</string>
    <string name="elem_StepperMotorBipolar_pin_B+">Bobina B, positivo</string>
    <string name="elem_StepperMotorBipolar_pin_B-">Bobina B, negativo</string>
    <string name="key_colorScheme_DARK">Escuro</string>
    <string name="elem_ScopeTrigger">Gráficos com dados amostrados</string>
    <string name="elem_ScopeTrigger_short">Osciloscópio</string>
    <string name="elem_ScopeTrigger_tt">Mostrará o gráfico de valores amostrados, os quais serão armazenados apenas se houver alteração no sinal de entrada.
        O armazenamento se dará quando o circuito estiver estabilizado.
        O gatilho não iniciará a medida como em um osciloscópio real, mas cada evento gatilhado armazenará 
        um valor de medida apenas, para cada um dos sinais amostrados.
        Como entrada direta haverá apenas um gatilho. As entradas e saídas do circuito, flip-flops e registradores e
        o componente amostrador poderão ser usados como sinais. Isso poderá ser ativado nos respectivos componentes.</string>
    <string name="elem_ScopeTrigger_pin_T">Uma alteração nessa entrada provocará o armazenamento de valores amostrados.</string>
    <string name="elem_NotConnected">Desconectado</string>
    <string name="elem_NotConnected_tt">Esse componente poderá ser usado para colocar uma conexão em alta impedância (Z).
        Se um entrada de uma porta lógica estiver em alta impedância, o valor lido será indefinido.
        Observa-se que, na realidade, em muitos casos, o consumo excessivo de corrente e até mesmo danos 
        poderão ocorrer se uma entrada digital não estiver definida como alta ou baixa, 
        mas permanecer desconectada.</string>
    <string name="elem_NotConnected_pin_out">Esta saída estará sempre em alta impedância.</string>
    <string name="err_notConnectedNotAllowed">O símbolo de Desconectado não é permitido aqui!</string>
    <string name="elem_ROMDualPort_short">ROM</string>
    <string name="elem_ROMDualPort_tt">Componente de memória não volátil.
        Os dados armazenados poderão ser editados na caixa de diálogo para atributos.</string>
    <string name="elem_ROMDualPort_pin_A1">Esse pino definirá o endereço da palavra de dados à saída D1.</string>
    <string name="elem_ROMDualPort_pin_D1">Palavra de dados selecionada se a entrada s1 estiver em nível alto.</string>
    <string name="elem_ROMDualPort_pin_s1">Se a entrada estiver em nível alto, a saída D1 estará ativada. Se estiver em nível baixo, a saída estará em alta impedância (Z).</string>
    <string name="elem_ROMDualPort_pin_A2">Esse pino definirá o endereço da palavrra de dados à saída D2.</string>
    <string name="elem_ROMDualPort_pin_D2">Palavra de dados selecionada se a entrada s2 estiver em nível alto.</string>
    <string name="elem_ROMDualPort_pin_s2">Se a entrada estiver em nível alto, a saída D2 estará ativada. Se estiver em nível baixo, a saída estará em alta impedância (Z).</string>
    <string name="elem_PRNG">Gerador de número aleatório</string>
    <string name="elem_PRNG_tt">Poderá ser usado para gerar números aleatórios.
        Quando a simulação for iniciada, o gerador será reiniciado de modo que uma nova sequência de números
        pseudo-aleatórios seja gerada a cada vez.
        O gerador poderár ser iniciado durante simulação com um valor definido para semente para que se 
        possa gerar uma sequência definida de valores pseudo-aleatórios.</string>
    <string name="elem_PRNG_short">PRNG</string>
    <string name="elem_PRNG_pin_S">Novo valor para a semente do gerador.</string>
    <string name="elem_PRNG_pin_se">Se definido, o gerador de número aleatório será reiniciado com uma nova semente na subida do clock.</string>
    <string name="elem_PRNG_pin_ne">Se definido, um novo número aleatório estará disponível na próxima borda de subida do clock.</string>
    <string name="elem_PRNG_pin_C">Entrada do clock.</string>
    <string name="elem_PRNG_pin_R">Saída do número pseudo-aleatório.</string>
    <string name="elem_GenericInitCode">Inicialização genérica</string>
    <string name="elem_GenericInitCode_tt">Código a ser executado ao iniciar-se um circuito genérico diretamente.
        Se um circuito genérico tiver que ser iniciado diretamente, tal componente deverá estar presente.</string>
    <string name="elem_GenericCode">Código</string>
    <string name="elem_GenericCode_tt">Código a ser executado quando um circuito genérico for incorporado.
        Poderá ser usado, por exemplo, para adicionar componentes ou conexões a um circuito.</string>
    <string name="err_hdlTestCaseHasGenericCode">Casos de testes com parametrização genérica sem suporte na exportação em HDL!</string>
    <string name="err_multipleRomsFound">Múltiplas memórias de programa encontradas! Somente uma memória de programa é permitida.</string>
    <string name="err_noMemoryFound">Nenhuma memória "{0}" encontrada no modelo!</string>
    <string name="err_multipleMemoriesFound">Múltiplas memórias "{0}" encontradas no modelo!</string>
    <string name="err_noGenericInitCode">Nenhum código de inicialização para componentes genéricos.
        Um componente correspondente deverá ser acrescido ao circuito a fim de poder ser iniciado.</string>
    <string name="err_multipleGenericInitCodes">Múltiplos códigos de inicialização para elementos genéricos.</string>
    <string name="err_inGenericInitCode">Erro na análise do código de inicialização genérico.</string>
    <string name="err_virtualSignal_N_DeclaredTwiceInLine_N">Sinal virtual {0} duplicado na linha {1}!</string>
    <string name="key_remainderPositive">Resto de divisão sempre positivo</string>
    <string name="key_remainderPositive_tt">Se definido, o resto de uma divisão com sinal será sempre positivo.</string>
    <string name="key_trigger">Gatilho</string>
    <string name="key_trigger_tt">Condição de gatilho para o registro de dados.</string>
    <string name="key_trigger_rising">borda de subida</string>
    <string name="key_trigger_falling">borda de descida</string>
    <string name="key_trigger_both">ambas as bordas</string>
    <string name="mod_modifiedByRunningModel">Alterações feitas ao se executar a simulação.</string>
    <string name="menu_scale">Definir escala</string>
    <string name="msg_supportsHDL">Exportável para VHDL/Verilog.</string>
    <string name="msg_errorSettingModelToTestCase">Erro ao definir a linha do caso de teste.</string>
    <string name="msg_keyAsGenericAttribute">Nome a ser usado nos circuitos genéricos: {0}</string>
    <string name="attr_createConcreteCircuitLabel">Realizar circuito</string>
    <string name="attr_createConcreteCircuit">Realizar</string>
    <string name="attr_createConcreteCircuit_tt">Realizar cirucito a partir de descrição genérica usando os 
        parâmetros especificados nesse elemento.</string>
    <string name="attr_createConcreteCircuitErr">Erro durante a realização de circuito!</string>
    <string name="msg_fsm_optimizer">Otimizador de Máquina de Estados Finitos (FSM)</string>
    <string name="menu_fsm_optimize_state_numbers">Otimizador de Números de Estados</string>
    <string name="menu_fsm_optimize_state_numbers_tt">Otimizará os números de estados de modo que uma implementação realize o menor esforço possível.
        O tempo de execução aumentará muito rapidamente com a complexidade da máquina. (O(n!))</string>
    <string name="menu_fsm_optimize_state_numbers_err">Erro durante a otimização!</string>
    <string name="msg_fsm_optimizer_initial">Complexidade inicial:</string>
    <string name="msg_fsm_optimizer_best">O melhor até agora:</string>
    <string name="msg_search">procurar</string>
    <string name="elem_RAMAsync_tt">Uma vez definido, será armazenado. Corresponde a uma RAM simples, onde
        as linhas de endereços e de dados estão diretamente conectadas aos decodificadores das células de memória.</string>
    <string name="elem_RAMAsync_pin_A">O endereço onde se fará a leitura ou a escrita.</string>
    <string name="elem_RAMAsync_pin_D">Os dados a serem armazenados</string>
    <string name="elem_RAMAsync_pin_we">Habilitar a escrita. Se essa entrada for igual a 1, o valor aplicado em D será
        armazenado no endereço aplicado em A, quando A ou D forem modificados.</string>
    <string name="elem_RAMAsync_pin_Q">Saída dos dados armazenados.</string>
    <string name="err_writeInCodeComponentsOnly">Variáveis globais somente poderão ser escritas em componentes com código.</string>
    <string name="err_csvNoHeaderFound">Nenhum cabeçalho encontrado!</string>
    <string name="err_csvNoOutputValuesFound">Nenhum valor de saída encontrado!</string>
    <string name="err_csvNotEnoughValues">Não há valores suficientes em uma linha!</string>
    <string name="err_csvToManyValues">Valores em excesso para uma linha!</string>
    <string name="key_intFormat_fixed">Ponto fixo</string>
    <string name="key_intFormat_fixedSigned">Ponto fixo com sinal</string>
    <string name="key_intFormat_floating">Ponto flutuante</string>
    <string name="key_fixedPoint">dígitos de ponto fixo</string>
    <string name="key_fixedPoint_tt">Número de dígitos binários na parte fracionária</string>
    <string name="key_iverilogOptions">Iverilog - Opções</string>
    <string name="key_iverilogOptions_tt">Opções que serão usadas para todos os passos de processamento pelo Iverilog.</string>
    <string name="menu_table_exportCSV">CSV</string>
    <string name="menu_table_exportCSV_tt">Arquivo CSV contendo a tabela-verdade completa.</string>
    <string name="menu_table_exportCSVCondensed">CSV, primos implicantes</string>
    <string name="menu_table_exportCSVCondensed_tt">Arquivo CSV contendo apenas os primos implicantes.</string>
    <string name="menu_createBehavioralFixture">Criar caso de teste para estabelecer comportamento</string>
    <string name="menu_createBehavioralFixture_tt">Definir comportamento do circuito.
        Isso definirá um caso de teste que estabelecerá o comportamento atual.</string>
    <string name="msg_fixesCreated_N">Componentes: {0}</string>
    <string name="btn_createTestLine">Criar componente</string>
    <string name="btn_createTestLine_tt">Definir um novo componente no caso de teste.</string>
    <string name="btn_BehavioralFixtureComplete">Completo</string>
    <string name="btn_BehavioralFixtureComplete_tt">Criar componente para o caso de teste</string>
    <string name="msg_errorCreatingTestCase">Erro na criação do caso de teste.</string>
    <string name="msg_errorPastingData">Erro ao incluir dados!</string>
    <string name="elem_Telnet">Telnet</string>
    <string name="elem_Telnet_tt">Permitir uma conexão Telnet ao circuito
        É possível receber e enviar caracteres via Telnet.</string>
    <string name="elem_Telnet_pin_out">Saída de dados</string>
    <string name="elem_Telnet_pin_av">Emitir um dado, se existir.</string>
    <string name="elem_Telnet_pin_in">Dado a ser enviado.</string>
    <string name="elem_Telnet_pin_C">Entrada de clock</string>
    <string name="elem_Telnet_pin_wr">Se definido, o byte de dado à entrada será enviado.</string>
    <string name="elem_Telnet_pin_rd">Se definido, um byte recebido será emitido.</string>
    <string name="elem_VGA_short">VGA</string>
    <string name="elem_RAMAsync">RAM, assíncrona</string>
    <string name="elem_ExternalFile">Arquivo externo</string>
    <string name="elem_ExternalFile_tt">Componente que executará um processo externo para calcular uma função lógica.
        Será usado para especificar o comportamento de um componente mediante VHDL ou Verilog.
        A simulação real do comportamento deverá ser feita por meio de um simulador externo.
        A identificação do componente deverá coincidir com o nome da entidade ou módulo!</string>
    <string name="err_errorLoadingHDLFile_N">Erro ao carregar o arquivo HDL {0}</string>
    <string name="err_emptyLabelIsNotAllowed">Uma identificação vazia não é permitida!</string>
    <string name="err_errorWritingFile_N">Erro ao gravar arquivo {0}</string>
    <string name="err_circuitContainsNoComponents">O circuito não contém componentes!</string>
    <string name="err_couldNotCreateServer">Impossível iniciar o servidor!</string>
    <string name="key_small">Forma pequena</string>
    <string name="key_small_tt">Se selecionada, uma forma pequena será usada.</string>
    <string name="key_lastDataFile">Arquivo</string>
    <string name="key_lastDataFile_tt">Arquivo a ser carregado em ROM.</string>
    <string name="key_CodeFile">Código de programa</string>
    <string name="key_CodeFile_tt">O arquivo contendo o código de programa a ser executado pela aplicação externa.</string>
    <string name="key_probeMode">Modo de exibição</string>
    <string name="key_probeMode_tt">Definir se o valor ou um contador deverá ser exibido.</string>
    <string name="key_probeMode_VALUE">Mostrar valor</string>
    <string name="key_probeMode_UP">Contar na subida de borda</string>
    <string name="key_probeMode_DOWN">Contar na descida de borda</string>
    <string name="key_probeMode_BOTH">Contar em ambas as bordas</string>
    <string name="key_telnetEscape">Modo Telnet</string>
    <string name="key_telnetEscape_tt">Se definido, os comandos de controle Telnet serão avaliados.
        Além disso, o servidor enviará os comandos SGA e ECHO. Se essa opção for desabilitada,
        irá tornar-se um simples servidor TCP.</string>
    <string name="key_port">Porta</string>
    <string name="key_port_tt">Porta a ser aberta pelo servidor.</string>
    <string name="key_skipHDL">Dispensar a exportação em Verilog/VHDL</string>
    <string name="key_skipHDL_tt">Dispensar a geração interna exportada pelo circuito em Verilog/VHDL
        As referências ao circuito serão mantidas, tornando possível sobrepor sua implementação.</string>
    <string name="lib_decoration">Decoração</string>
    <string name="lib_generic">Genérico</string>
    <string name="lib_hdl">VHDL/Verilog</string>
    <string name="cli_help_test_verbose">Se definido, a tabela de valores será exibida em caso de erro.</string>
    <string name="menu_copy_tt">Copiar para a área de transferência</string>
    <string name="msg_truthTableCSV">CSV, "Comma Separated Values"</string>
    <string name="key_defaultsDC">Valores não definidos serão "Don't Care"</string>
    <string name="key_defaultsDC_tt">Todos os valores não definidos (estados e saídas) deverão ser tomados como "Don't Care".</string>
    <string name="elem_ROMDualPort">ROM com porta dupla</string>
    <string name="key_persistTime">Persistência da visualização</string>
    <string name="key_persistTime_tt">Especificar a duração de brilho. Quanto maior o valor, maior a duração do brilho.</string>
    <string name="key_oscillationDetectionCounter">Detecção de oscilação</string>
    <string name="key_oscillationDetectionCounter_tt">Número de ciclos de propagação para se detectar uma oscilação
        se o circuito não estiver estabilizado até então.</string>
    <string name="key_openRemotePort">Permitir conexão remota</string>
    <string name="key_openRemotePort_tt">Se definido, uma porta TCP/IP será aberta e através da qual o controle
        do simulador será possível.</string>
    <string name="key_remotePort">Número da porta</string>
    <string name="key_remotePort_tt">Porta na qual o servidor remoto estará aberto.</string>
    <string name="msg_bigEndian">Big-Endian</string>
    <string name="key_bigEndian">Usar Big-Endian ao importar.</string>
    <string name="key_bigEndian_tt">Usar byte em representação Big-Endian ao importar.</string>
    <string name="menu_table_createCircuitMore">Variantes de circuito</string>
    <string name="menu_table_maxInputs_N">Usar portas lógicas com no máximo {0} entradas}-</string>
    <string name="menu_presentationMode">Modo de apresentação</string>
    <string name="menu_presentationMode_tt">Uma visão simplificada que, por exemplo, omitirá os casos de testes, o que poderá ser útil em caso de apresentações.</string>
    <string name="menu_find">Procurar</string>
    <string name="menu_find_tt">Procurar por rótulos, identificações de grupos de nomes e de pinos</string>
    <string name="menu_calcMaxPathLen">Tamanho máximo da rota</string>
    <string name="menu_calcMaxPathLen_tt">Tamanho máximo da rota será o mais longo entre uma das entradas e a saída mais distante.</string>
    <string name="msg_maxPathLen">A rota mais longa consiste de {0} portas.}-</string>
    <string name="msg_couldNotCalculateMaxPathLen">O tamanho da rota não pode ser calculado.</string>
    <string name="key_source">Fonte de dados</string>
    <string name="key_source_noData">Não carregar qualquer dado</string>
    <string name="key_source_file">arquivo</string>
    <string name="key_source_dataField">dados armazenados</string>
    <string name="err_could_not_load_rom">Impossível carregar dados da ROM!</string>
</resources>
