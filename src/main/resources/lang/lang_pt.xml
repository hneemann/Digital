<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="addr">Endereço</string>
    <string name="tableOfContent">Índice</string>
    <string name="general">Geral</string>
    <string name="revision">Revisão</string>
    <string name="date">Data</string>
    <string name="maxValue">Valor máximo</string>
    <string name="settings">A seguir descrevem-se as configurações disponíveis no simulador.</string>
    <string name="attr_dialogTitle">Atributos</string>
    <string name="attr_openCircuit">Abrir circuito</string>
    <string name="attr_openCircuitLabel">Incluir circuito:</string>
    <string name="attr_openCircuit_tt">Abrir circuito em um nova janela.</string>
    <string name="attr_help">Ajuda</string>
    <string name="attr_help_tt">Mostrar uma breve descrição desse elemento.</string>
    <string name="attr_dialogHex">Hexadecimal</string>
    <string name="attr_dialogDecimal">Decimal</string>
    <string name="attr_dialogAscii">ASCII</string>
    <string name="attr_dialogHighz">Alta impedância</string>
    <string name="attr_dialogOctal">Octal</string>
    <string name="attr_dialogBinary">Binário</string>
    <string name="attr_primary">Básico</string>
    <string name="attr_secondary">Avançado</string>
    <string name="btn_discard">Descartar alterações</string>
    <string name="btn_edit">Editar</string>
    <string name="btn_editFurther">Continuar edição</string>
    <string name="btn_load">Carregar</string>
    <string name="btn_reload">Recarregar</string>
    <string name="btn_reload_tt">Recarregar último arquivo em hexadecimal</string>
    <string name="btn_save">Salvar</string>
    <string name="btn_create">Criar</string>
    <string name="btn_create_tt">Criar circuito em janela separada</string>
    <string name="btn_editDetached">Editar em separado</string>
    <string name="btn_editDetached_tt">Abrir diálogo como não modal</string>
    <string name="btn_openInBrowser">Navegador</string>
    <string name="btn_openInBrowser_tt">Abrir texto de ajuda no navegador. Permite-se a impressão do texto.</string>
    <string name="btn_clearData">Limpar</string>
    <string name="btn_clearData_tt">Atribuir zeros a todos os valores!</string>
    <string name="btn_addTransitions">Transições</string>
    <string name="btn_addTransitions_tt">Todas as possíveis transições serão adicionadas como casos de testes. É usada para criar casos de testes para o próprio simulador.</string>
    <string name="btn_newName">Novo nome</string>
    <string name="btn_saveAnyway">Salvar incondicionalmente</string>
    <string name="btn_overwrite">Substituir</string>
    <string name="btn_apply">Aplicar</string>
    <string name="btn_editRom_tt">Editar o conteúdo da ROM/EEPROM selecionada</string>
    <string name="btn_clearRom_tt">Remover os dados armazenados na ROM selecionada. O conteúdo anterior armazenado na ROM será usado.</string>
    <string name="btn_saveTemplate">Modelo</string>
    <string name="btn_saveTemplate_tt">Criar modelo SVG que possa ser editado pelo Inkscape.</string>
    <string name="btn_loadSvg">Importar</string>
    <string name="btn_loadSvg_tt">Importar arquivo SVG. Para criar arquivo SVG adequado, é mais fácil criar o modelo SVG primeiro, e depois editá-lo.</string>
    <string name="msg_warning">Aviso</string>
    <string name="cancel">Cancelar</string>
    <string name="digital">Digital</string>
    <string name="expression">Expressão</string>
    <string name="elem_Help_inputs">Entradas</string>
    <string name="elem_Help_outputs">Saídas</string>
    <string name="elem_Help_attributes">Atributos</string>

    
    <!-- logic -->

    <string name="elem_Basic_In">Valor de entrada para a operação lógica em {0}.</string>
    <string name="elem_Basic_Out">Retornar o resultado da operação lógica.</string>

    <string name="elem_And">AND</string>
    <string name="elem_And_tt">Porta AND. Retornará 1 somente se todas as entradas também estiverem em 1.
        É possível usar barramentos com vários bits tanto para entradas quanto para saídas. Nesse caso, serão executados bit-a-bit.
        Isso significa que os bits de menor ordem de todas as entradas estarão conectados à AND e sua saída também será a de menor ordem.
        O mesmo ocorrerá para o bit 1, bit 2 e assim por diante.
    </string>
    <string name="elem_NAnd">NAND</string>
    <string name="elem_NAnd_tt">Combinação de AND e NOT.
        Retornará 0 somente se todas as entradas estiverem em 1. Se alguma das entradas estiver em 0 a saída irá para 1.
        Também é possível usar barramentos com vários bits para as entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.
    </string>
    <string name="elem_Or">OR</string>
    <string name="elem_Or_tt">Porta OR. Retornará 1 se alguma das entradas estiver em 1.
        Se todas as entradas estiverem em 0 a saída também irá para 0.
        Também é possível usar barramentos com vários bits tanto para entradas quanto para saídas. Nesse caso, serão executados bit-a-bit.
        Isso significa que os bits de menor ordem de todas as entradas estarão conectados à OR e sua saída também será a de menor ordem.
        O mesmo ocorrerá para o bit 1, bit 2 e assim por diante.
    </string>
    <string name="elem_NOr">NOR</string>
    <string name="elem_NOr_tt">Combinação de OR e NOT.
        Retornará 0 se alguma das entradas estiver em 1. Se todas as entradas estiverem em 0 a saída irá para 1.
        Também é possível usar barramentos vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.
    </string>
    <string name="elem_XOr">XOR</string>
    <string name="elem_XOr_tt">Se todas as entradas forem usadas, a saída será 0 para cada par de bits iguais.
        Caso contrário a saída será 1.
        Se mais do que duas entradas forem usadas, se comportará como portas XOR em cascata ( A XOR B XOR C = (A XOR B) XOR C ).
        Também é possível usar barramentos com vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.
    </string>
    <string name="elem_XNOr">XNOR</string>
    <string name="elem_XNOr_tt">Combinação de XOR e NOT. As entradas serão combinadas pela operação XOR.
        O resultado dessa operação será então invertido.
        Também é possível usar barramentos com vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.
    </string>
    <string name="elem_Not">NOT</string>
    <string name="elem_Not_tt">Inverterá o valor à entrada. Um valor igual a 1 se tornará 0 e um 0 se tornará 1.
        Também é possível usar barramentos com vários bits como entradas. Nesse caso, a operação se aplicará a cada
        bit das entradas.
     </string>
    <string name="elem_Not_pin_in">A entrada da porta NOT.</string>
    <string name="elem_Not_pin_out">O valor invertido da entrada.</string>
    <string name="elem_LookUpTable">LookUpTable</string>
    <string name="elem_LookUpTable_short">LUT</string>
    <string name="elem_LookUpTable_tt">Obterá o valor da saída a partir de uma tabela armazenada.
        Dessa forma poderá emular qualquer porta combinatória.
    </string>
    <string name="elem_LookUpTable_pin_in">Entrada {0}. Essa entrada em combinação com todas as outras definirá o
        endereço do valor armazenado que será retornado.</string>
    <string name="elem_LookUpTable_pin_out">Retornará o valor armazenado no endereço definido pelas entradas.</string>
    <string name="elem_Delay">Atraso</string>
    <string name="elem_Delay_tt">Atrasará o sinal no tempo de propagação.
        Atrasará um sinal por um número de atrasos de porta regulável.
        Todos os outros componentes no simulador têm um atraso de porta no tempo de propagação.
        Esse componente pode ser usado para implementar qualquer atraso de propagação necessário.
    </string>
    <string name="elem_Delay_pin_in">Entrada do sinal a ser atrasado.</string>
    <string name="elem_Delay_pin_out">O sinal de entrada atrasado pelo tempo correspondente a um atraso de porta.</string>


    <!-- IO -->

    <string name="elem_Out">Saída</string>
    <string name="elem_Out_tt">Pode ser usada para mostrar um sinal de saída do circuito.
        Esse elemento também é usado para conectar um circuito a outro integrado.
        Nesse caso a conexão é bidirecional.
        Também é usado para atribuir um número PIN, se código para CPLD ou FPGA for gerado.
    </string>
    <string name="elem_Out_pin_in">Este valor é usado para a conexão de saída.</string>
    <string name="elem_LED">LED</string>
    <string name="elem_LED_tt">Um LED pode ser usado para visualizar um valor de saída. Aceita um único bit.
        Acenderá se a entrada estiver em 1.</string>
    <string name="elem_LED_pin_in">Entrada do LED que acenderá se estiver em 1.</string>

    <string name="elem_RGBLED">LED RGB</string>
    <string name="elem_RGBLED_tt">Um LED RGB pode ter sua cor controlada através de três entradas.
        Em cada uma das três entradas, um canal de cor estará ligado.</string>
    <string name="elem_RGBLED_pin_R">O canal da cor vermelha.</string>
    <string name="elem_RGBLED_pin_G">O canal da cor verde.</string>
    <string name="elem_RGBLED_pin_B">O canal da cor azul.</string>

    <string name="elem_PolarityAwareLED">LED com duas conexões.</string>
    <string name="elem_PolarityAwareLED_tt">LED com conexões para o cátodo e o ânodo. O LED acenderá,
        se o ânodo estiver ligado ao positivo e o cátodo estiver ligado ao negativo.</string>
    <string name="elem_PolarityAwareLED_pin_A">A conexão do ânodo do LED.</string>
    <string name="elem_PolarityAwareLED_pin_C">A conexão do cátodo do LED.</string>

    <string name="elem_In">Entrada</string>
    <string name="elem_In_tt">Poderá ser usado para manipuar interativamente um sinal de entrada em um circuito com o
        mouse. Esse elemento também poderá ser usado para ligar um circuito a outro integrado.
        Nesse caso a conexão é bidirecional.
        Também é usado para atribuir um número PIN, se código para CPLD ou FPGA for gerado.
    </string>
    <string name="elem_In_pin_out">Fornece o valor ao qual está ligada a essa entrada.</string>

    <string name="elem_DipSwitch">DIP Switch</string>
    <string name="elem_DipSwitch_tt">Chave DIP que pode ter a saída alta ou baixa.</string>
    <string name="elem_DipSwitch_pin_out">O valor da chave de saída.</string>

    <string name="elem_Clock">Entrada do Clock</string>
    <string name="elem_Clock_tt">Um sinal de clock. É possível controlá-lo por um clock de tempo real.
        Dependendo da complexidade do circuito, a frequência de clock alcançada pode ser menor que a do valor selecionado.
        Se a frequência for maior que 50Hz, a representação gráfica do circuito não será mais atualizada a
        cada ciclo de clock de modo que as cores dos fios também não mais serão atualizadas.
        Se um clock de tempo real não estiver ativado, o elemento poderá ser controlado por clicks do mouse.
        Também é usado para atribuir um número PIN, se código para CPLD ou FPGA for gerado.
    </string>
  <string name="elem_Clock_pin_C">Alternará entre 0 e 1, de acordo com a frequência selecionado do clock.</string>
    <string name="elem_Button">Botão</string>
    <string name="elem_Button_tt">Botão simples que voltará ao seu estado original quando liberado.</string>
    <string name="elem_Button_pin_out">O sinal de saída do botão.</string>
    <string name="elem_Text">Texto</string>
    <string name="elem_Text_tt">Mostrar um texto no circuito.
        Não afeta a simulação.
        O texto poderá ser alterado pela caixa do diálogo do atributo.
    </string>
    
    <string name="elem_Rectangle">Retângulo</string>
    <string name="elem_Rectangle_tt">Mostrarã um retângulo no circuito.
        Isso não afetará a simulação. Se um sinal negativo (-) for usado no cabeçalho, esse será omitido.
    </string>
    
    <string name="elem_Probe">Ponta de prova</string>
    <string name="elem_Probe_tt">Valor medido que poderá ser exibido na saída gráfica de dados ou na tabela de medições.
        Esse componente poderá ser usado para observar facilmente valores de circuitos integrados.
        Não afeta a simulação.
    </string>
    <string name="elem_Probe_pin_in">O valor da medição.</string>


    <!-- IO - more -->

    <string name="elem_LightBulb">Lâmpada</string>
    <string name="elem_LightBulb_tt">Lâmpada com duas conexões. Se houver fluxo de corrente, a lâmpada acenderá!
        A direção da corrente não importa. A lâmpada acenderá quando as entradas tiverem valores diferentes.
        A lâmpada tem funcionamento similar ao da porta XOR.
    </string>
    <string name="elem_LightBulb_pin_A">Conexão</string>
    <string name="elem_LightBulb_pin_B">Conexão</string>
    <string name="elem_Seven-Seg">Display de 7-Segmentos</string>
    <string name="elem_Seven-Seg_tt">Display de 7-Segmentos, cada segmento possui sua própria entrada de controle.</string>
    <string name="elem_Seven-Seg_pin_a">Essa entrada controlará a linha horizontal superior.</string>
    <string name="elem_Seven-Seg_pin_b">Essa entrada controlará a linha vertical superior direita.</string>
    <string name="elem_Seven-Seg_pin_c">Essa entrada controlará a linha vertical inferior direita.</string>
    <string name="elem_Seven-Seg_pin_d">Essa entrada controlará a linha horizontal inferior.</string>
    <string name="elem_Seven-Seg_pin_e">Essa entrada controlará a linha vertical inferior esquerda.</string>
    <string name="elem_Seven-Seg_pin_f">Essa entrada controlará a linha vertical superior esquerda.</string>
    <string name="elem_Seven-Seg_pin_g">Essa entrada controlará a linha horizontal ao meio.</string>
    <string name="elem_Seven-Seg_pin_dp">Essa entrada controlará o ponto decimal.</string>
    <string name="elem_Seven-Seg_pin_cc">Cátodo comum. Para ligar os LEDs, essa entrada deverá estar em nível baixo.</string>
    <string name="elem_Seven-Seg-Hex">Display de 7-Segmentos Hexadecimal</string>
    <string name="elem_Seven-Seg-Hex_tt">Display de 7-Segmentos com entrada hexadecimal de 4 bits</string>
    <string name="elem_Seven-Seg-Hex_pin_d">O valor dessa entrada será exibido no display.</string>
    <string name="elem_Seven-Seg-Hex_pin_dp">Essa entrada controlará o ponto decimal.</string>

    <string name="elem_SixteenSeg">Display de 16 Segmentos</string>
    <string name="elem_SixteenSeg_tt">A entrada do LED input tem 16 bits que controlarão os segmentos. A segunda entrada controlará o ponto decimal.</string>
    <string name="elem_SixteenSeg_pin_led">Barramento de 16-bits para controlar os LEDs.</string>
    <string name="elem_SixteenSeg_pin_dp">Essa entrada controlará o ponto decimal.</string>

    <string name="elem_LedMatrix">Matriz de LEDs</string>
    <string name="elem_LedMatrix_tt">A matrixz de LEDs. Os LEDs serão exibidos em uma janela em separado.
        Os LEDs de uma coluna do display serão controlados por uma palavra de controle. Em outra entrada, a coluna corrente será 
        selecionada. Dessa forma um display multiplexado será obtido.
        Os LEDs são capazes de se manter acesos indefinidamente durante a simulação para evitar que o display fique piscando.
    </string>
    <string name="elem_LedMatrix_pin_r-data">A fileira de LEDs de uma coluna.
        Cada bit nessa palavra de dados representa o estado da coluna corrente.</string>
    <string name="elem_LedMatrix_pin_c-addr">O número da coluna corrente cujo estado estará visível segundo a outra entrada.</string>
    <string name="elem_Data">Gráfico de dados</string>
    <string name="elem_Data_tt">Mostrará um gráfico dentro do painel de circuito.
        Será possível exibir ciclos completos de clock ou mudanças de portas individuais.
        Não afeta a simulação.
    </string>
    <string name="elem_RotEncoder">Codificador rotativo</string>
    <string name="elem_RotEncoder_tt">Disco giratório com codificador rotativo. Usado para detectar movimentos de rotação.</string>
    <string name="elem_RotEncoder_pin_A">sinal A do codificador</string>
    <string name="elem_RotEncoder_pin_B">sinal A do codificador</string>

    <string name="elem_Keyboard">Teclado</string>
    <string name="elem_Keyboard_tt">Um teclado poderá ser usado para realizar entrada de texto.
        Esse componente receberá a entrada, a qual poderá ser lida posteriormente.
        Uma janela em separado será aberta para a entrada do texto.
    </string>
    <string name="elem_Keyboard_pin_C">Clock. Quando da borda de subida, o caractere mais antigo será removido do buffer.</string>
    <string name="elem_Keyboard_pin_en">Se em nível alto, a saída D estará ativa e um caractere estará à saída.
        Isso também habilitará a entrada de clock.</string>
    <string name="elem_Keyboard_pin_D">O último caractere digitado, ou zero se nenhum caractere estiver disponível.</string>
    <string name="elem_Keyboard_pin_av">Essa saída indicará que caracteres estarão disponíveis.
        Isso poderá ser usado para chavear uma interrupção.</string>

    <string name="elem_Terminal">Terminal</string>
    <string name="elem_Terminal_tt">Será possível escrever caracteres ASCII nesse terminal.
        O terminal abrirá sua própria janela para exibir a saída.</string>
    <string name="elem_Terminal_pin_C">Clock. Quando da borda de subida, enviará o valor da entrada para a janela do terminal.</string>
    <string name="elem_Terminal_pin_D">Os dados a serem escritos no terminal</string>
    <string name="elem_Terminal_pin_en">Um nível alto nessa entrada habilitará o recebimento do clock.</string>


    <!-- Wires -->

    <string name="elem_Ground">Terra</string>
    <string name="elem_Ground_tt">Conexão para terra. A saída será sempre igual a zero.</string>
    <string name="elem_Ground_pin_out">Saída sempre retornará 0.</string>
    <string name="elem_VDD">Fonte</string>
    <string name="elem_VDD_tt">Conexão à fonte. A saída será sempre igual a um.</string>
    <string name="elem_VDD_pin_out">Saída sempre retornará 1.</string>
    <string name="elem_Const">Valor constante</string>
    <string name="elem_Const_tt">Componente que retornará um dado valor constante. O valor poderá ser atribuído por caixa de diálogo.</string>
    <string name="elem_Const_pin_out">Retornará o valor constante dado.</string>
    <string name="elem_Tunnel">Túnel</string>
    <string name="elem_Tunnel_tt">Conectará componentes sem fios. Todos os elementos desse tipo, cujos nomes serão os mesmos,
        estarão conectados em conjunto. Funcionarão apenas localmente, não sendo possível usá-los em circuitos diferentes.</string>
    <string name="elem_Tunnel_pin_in">A conexão a um túnel.</string>
    <string name="elem_Splitter">Distribuidor</string>
    <string name="elem_Splitter_tt">Distribuirá ou criará um cabo ou barramento de dados para mais de um bit.
        Com um barramento será possível, por exemplo gerar conexões de 16-bits sem necessitar o roteamento de 16 fios individuais.
        Todas as 16 conexões poderão ser tratadas como um único cabo.
    </string>
    <string name="elem_Splitter_pin_in">Os bits de entrada {0}.</string>
    <string name="elem_Splitter_pin_in_one">O bit de entrada {0}.</string>
    <string name="elem_Splitter_pin_out">Os bits de saída {0}.</string>
    <string name="elem_Splitter_pin_out_one">O bit de saída {0}.</string>

    <string name="elem_BusSplitter">Distribuidor bidirecional</string>
    <string name="elem_BusSplitter_tt">Poderá ser usado para barramento de dados e simplificará especialmente a construção de 
        módulos de memória em um pacote DIL, assim com a implementação desse tipo de barramento.</string>
    <string name="elem_BusSplitter_pin_OE">Quando definido, o valor no terminal de dados comum D será a saída para os bits
        D[i], se não, os bits D[i] terão como saída o valor D comum.</string>
    <string name="elem_BusSplitter_pin_D">A conexão de dados comum.</string>
    <string name="elem_BusSplitter_pin_D_N">O primeiro bit de dado {0} do barramento do distribuidor.</string>

    <string name="elem_PullUp">Resistor Pull-Up</string>
    <string name="elem_PullUp_tt">Se o circuito estiver em estado de alta impedância, o resistor levará o valor para nível alto.
        Em qualquer outro caso, esse componente não terá efeito.
    </string>
    <string name="elem_PullUp_pin_out">Um nível alto "fraco".</string>
    <string name="elem_PullDown">Resistor Pull-Down</string>
    <string name="elem_PullDown_tt">Se o circuito estiver em estado de alta impedância, o resistor levará o valor para nível baixo.
        Em qualquer outro caso, esse componente não terá efeito.
    </string>
    <string name="elem_PullDown_pin_out">Um nível baixo "fraco".</string>
    <string name="elem_Driver">Driver</string>
    <string name="elem_Driver_tt">Um driver poderá ser usado para conectar um sinal a outro fio.
        O driver é controlado pela entrada definida.
        Se o sinal de entrada estiver em nível baixo, a saída estará em estado de alta impedância.
        Se o sinal de saída estiver em nível alto, a saída será definida pelo valor à entrada.
    </string>
    <string name="elem_Driver_pin_in">O valor de entrada do driver.</string>
    <string name="elem_Driver_pin_sel">Pino para controlar o driver.
        Se sua entrada for 1, a saída terá o valor dado à entrada.
        Se sua entrada for 0, a saída estará em estado de alta impedância.
    </string>
    <string name="elem_Driver_pin_out">Se a entrada for 1, a saída terá o valor da entrada.
        Se seu valor for 0, a saída estará em estado de alta impedância.
    </string>
    <string name="elem_DriverInvSel">Driver invertido</string>
    <string name="elem_DriverInvSel_tt">Um driver poderá ser usado para conectar um sinal a outro fio
        O driver é controlado pela entrada definida.
        Se sua entrada estiver em nível alto, a saída estará em estado de alta impedância.
        Se o sinal de saída estiver em nível baixo, a saída será definida pelo valor à entrada.
    </string>
    <string name="elem_DriverInvSel_pin_in">Valor de entrada do driver.</string>
    <string name="elem_DriverInvSel_pin_sel">Pino para controlar o driver.
        Se sua entrada for 0, a saída terá o valor dado à entrada.
        Se sua entrada for 1, a saída estará em estado de alta impedância.
    </string>
    <string name="elem_DriverInvSel_pin_out">Se a entrada for 0, a saída terá o valor da entrada.
        Se seu valor for 1, a saída estará em estado de alta impedância.
    </string>


    <!-- Plexers  -->

    <string name="elem_Multiplexer">Multiplexador</string>
    <string name="elem_Multiplexer_tt">Componente que usará o valor de entrada de seleção para direcionar um dos valor escolhido dentre as entradas para a saída.</string>
    <string name="elem_Multiplexer_input">O valor da primeira entrada do multiplexador {0}.</string>
    <string name="elem_Multiplexer_output">O valor da entrada selecionada.</string>
    <string name="elem_Multiplexer_pin_sel">Essa entrada será usada para selecionar os dados à entrada que serão direcionados para a saída.</string>
    <string name="elem_Demultiplexer">Demultiplexador</string>
    <string name="elem_Demultiplexer_tt">Componente que poderá direcionar um valor de entrada para uma saída escolhida.
        As outras saídas terão o valor padrão definido.</string>
    <string name="elem_Demultiplexer_pin_sel">O pino que seleciona a saída a ser usada.</string>
    <string name="elem_Demultiplexer_pin_in">O valor dessa entrada será dado à saída selecionada.</string>
    <string name="elem_Demultiplexer_output">Primeira saída de dados {0}.</string>
    <string name="elem_Decoder">Decodificador</string>
    <string name="elem_Decoder_tt">Um dos pinos de saída estará em 1, todos as outras saídas estarão em 0.</string>
    <string name="elem_Decoder_output">Saída {0}. essa saída estará em 1 de acordo com a entrada de seleção.</string>
    <string name="elem_Decoder_pin_sel">Essa entrada selecionará a saída.
        A saída selecionda terá o valor igual a 1. Todas as outras saídas serão iguais a 0.</string>
    <string name="elem_BitSelector">Seletor de Bit</string>
    <string name="elem_BitSelector_tt">Seleciona um único bit do barramento de dados.</string>
    <string name="elem_BitSelector_pin_in">O barramento de entrada</string>
    <string name="elem_BitSelector_pin_sel">Essa entrada selecionará o bit</string>
    <string name="elem_BitSelector_pin_out">O bit selecionado.</string>

    <string name="elem_PriorityEncoder">Codificador de prioridade</string>
    <string name="elem_PriorityEncoder_short">Prioridade</string>
    <string name="elem_PriorityEncoder_tt">Se um das entradas estiver definida, a saída será o seu número.
        Se várias entradas estiverem definidas ao mesmo tempo, a saída será igual ao número mais alto.</string>
    <string name="elem_PriorityEncoder_pin_num">Número da entrada definida.</string>
    <string name="elem_PriorityEncoder_pin_any">Se essa saída estiver definida, pelo menos uma das entradas também estará.</string>
    <string name="elem_PriorityEncoder_input">O valor da primeira entrada do codificador de prioridade {0}.</string>

    <!-- flip flops-->

    <string name="elem_RS_FF_AS">Flip-flop SR</string>
    <string name="elem_RS_FF_AS_short">SR</string>
    <string name="elem_RS_FF_AS_tt">Componente que armazenará um único bit.
        Oferece funções para armazenar e limpar determinado bit.
        Se ambas as entradas forem para 1, ambas as saídas também irão para 1.
        Se ambas as entradas forem para 0, ao mesmo tempo, o estado final será aleatório.
    </string>
    <string name="elem_RS_FF_AS_pin_S">A entrada para armazenar.</string>
    <string name="elem_RS_FF_AS_pin_R">A entrada para limpar.</string>
    <string name="elem_RS_FF_AS_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_RS_FF_AS_pin_~Q">Retornará o inverso do valor armazenado.</string>

    <string name="elem_RS_FF">Flip-flop SR submetido ao clock</string>
    <string name="elem_RS_FF_short">SR</string>
    <string name="elem_RS_FF_tt">Componente que armazenará um único bit.
        Oferece funções para armazenar e limpar determinado bit.
        Se ambas as entradas (S, R) estiverem em nível alto quando da subida do clock, o estado final será aleatório.
    </string>
    <string name="elem_RS_FF_pin_S">A entrada para armazenar.</string>
    <string name="elem_RS_FF_pin_C">A entrada do clock. A subida do clock inicia o processo de transição.</string>
    <string name="elem_RS_FF_pin_R">A entrada para limpar.</string>
    <string name="elem_RS_FF_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_RS_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
    <string name="elem_JK_FF">Flip-flop JK</string>
    <string name="elem_JK_FF_short">JK</string>
    <string name="elem_JK_FF_tt">Tem a possibilidade para manter (J=K=0), levar para nível alto (J=1, K=0), levar para níve baixo (J=0, K=1) ou trocar (J=K=1) o valor armazenado.
        A mudança de estado ocorrerá somente quando houver uma borda de subida na entrada do clock C.</string>
    <string name="elem_JK_FF_pin_J">A entrada para armazenar no flip-flop.</string>
    <string name="elem_JK_FF_pin_C">A entrada do clock. Uma borda de subida iniciará a transição de estado.</string>
    <string name="elem_JK_FF_pin_K">A entrada para limpar o flip-flop.</string>
    <string name="elem_JK_FF_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_JK_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
    <string name="elem_D_FF">Flip-flop D</string>
    <string name="elem_D_FF_short">D</string>
    <string name="elem_D_FF_tt">Componente que armazenará um único bit.
        O valor presente no pino D será armazenado na subida do clock no pino C.
        A largura de bits poderá ser selecionada, o que permitirá armazenar múltiplos bits.
    </string>
    <string name="elem_D_FF_pin_D">Entrada para o bit a ser armazenado.</string>
    <string name="elem_D_FF_pin_C">Entrada do clock para armazenar um valor.
        O valor presente no pino D será armazenado na subida do clock nesse pino.</string>
    <string name="elem_D_FF_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_D_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
    <string name="elem_T_FF">Flip-Flop T</string>
    <string name="elem_T_FF_short">T</string>
    <string name="elem_T_FF_tt">Armazenará um único bit. Alternará o valor a cada borda de subida na entrada C.</string>
    <string name="elem_T_FF_pin_T">Habilitará a função de troca.</string>
    <string name="elem_T_FF_pin_C">Entrada de clock. A cada borda de subida, alternará a saída, se a entrada T estiver em 1.</string>
    <string name="elem_T_FF_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_T_FF_pin_~Q">Retornará o inverso do valor armazenado.</string>
    <string name="elem_JK_FF_AS">Flip-flop JK, assíncrono</string>
    <string name="elem_JK_FF_AS_short">JK-AS</string>
    <string name="elem_JK_FF_AS_tt">Tem a possibilidade para manter (J=K=0), levar para nível alto (J=1, K=0), levar para níve baixo (J=0, K=1) ou trocar (J=K=1) o valor armazenado.
        A mudança de estado ocorrerá somente quando houver uma borda de subida na entrada do clock C.
        Há duas entradas adicionais para armazenar ou limpar o estado sem a presença de um sinal de clock.
    </string>
    <string name="elem_JK_FF_AS_pin_J">A entrada para armazenar do flip-flop.</string>
    <string name="elem_JK_FF_AS_pin_C">A entrada do clock. Uma borda de subida iniciará a transição de estado.</string>
    <string name="elem_JK_FF_AS_pin_K">A entrada para limpar o flip-flop.</string>
    <string name="elem_JK_FF_AS_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_JK_FF_AS_pin_~Q">Retornará o inverso do valor armazenado.</string>
    <string name="elem_JK_FF_AS_pin_Set">Habilitação assíncrona. Um valor em nível alto nessa entrada levará a saída para nível alto.</string>
    <string name="elem_JK_FF_AS_pin_Clr">Limpeza assíncrona. Um valor em nível alto nessa entraa levará a saída para nível baixo.</string>
    <string name="elem_D_FF_AS">Flip-flop D, assíncrono</string>
    <string name="elem_D_FF_AS_short">D-AS</string>
    <string name="elem_D_FF_AS_tt">Componente que armazenará um único bit.
        O valor presente no pino D será armazenado na subida do clock no pino C.
        Há duas entradas adicionais para armazenar ou limpar o estado imediatamente sem a presença de um sinal de clock.
        A largura de bits poderá ser selecionada, o que permitirá armazenar múltiplos bits.
    </string>
    <string name="elem_D_FF_AS_pin_D">Entrada do bit a ser armazenado.</string>
    <string name="elem_D_FF_AS_pin_C">Pino de controle para armazenar um bit.  O valor presente no pino D será armazenado na subida do sinal nesse pino.</string>
    <string name="elem_D_FF_AS_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_D_FF_AS_pin_~Q">Retornará o inverso do valor armazenado</string>
    <string name="elem_D_FF_AS_pin_Set">Habilitação assíncrona. Um valor em nível alto nessa entrada levará a saída para nível alto.</string>
    <string name="elem_D_FF_AS_pin_Clr">Limpeza assíncrona. Um valor em nível alto nessa entrada levará a saída para nível baixo.</string>

    <string name="elem_Monoflop">Monoflop</string>
    <string name="elem_Monoflop_short">Mono</string>
    <string name="elem_Monoflop_tt">O monoflop será determinado na subida da entrada de clock.
        Após um atrado de tempo configurável, o monoflop será limpo automaticamente.
        O monoflop poderá ser gatilhável. Isso somente será utilizado se existir apenas um componente de clock presente no circuito.
        Esse componente de clock será usado como base de tempo para medir os atrasos.
    </string>
    <string name="elem_Monoflop_pin_R">Entrada para limpar. Um valor em nível alto irá limpar o monoflop.</string>
    <string name="elem_Monoflop_pin_C">A entrada de clock. Uma borda de subida irá engatilhar o monoflop.</string>
    <string name="elem_Monoflop_pin_Q">Saída</string>
    <string name="elem_Monoflop_pin_~Q">Saída invertida</string>

    <!-- Memory -->

    <string name="elem_Register">Registrador</string>
    <string name="elem_Register_short">Reg</string>
    <string name="elem_Register_tt">Componente para armazenar valores. A largura em bits da palavra de dados poderá ser selecionada.
        Diferente do flip-flop D, o registrador possui uma entrada que o habilitará dependendo do clock.</string>
    <string name="elem_Register_pin_D">Entrada da palavra de dados a ser armazenada.</string>
    <string name="elem_Register_pin_C">Entrada de clock. Na borda de subida armazenará o valor presente no pino D.</string>
    <string name="elem_Register_pin_en">Pino para habilitação. O armazenamento do valor funcionará somente se esse pino estiver em nível alto.</string>
    <string name="elem_Register_pin_Q">Retornará o valor armazenado.</string>
    <string name="elem_ROM">ROM</string>
    <string name="elem_ROM_tt">Componente de memória não-volátil.
        Os dados armazenados poderão ser editados por meio da caixa de diálogo de atributos.
    </string>
    <string name="elem_ROM_pin_A">Este pino definirá o endereço da palavra de dados a ser enviada para a saída.</string>
    <string name="elem_ROM_pin_D">A palavra de dados selecionada se a entrada estiver em nível alto.</string>
    <string name="elem_ROM_pin_sel">Se a entrada estiver em nível alto, a saída será ativada. Se estiver em nível baixo, a saída de dados estará em estado de alta impedância.</string>

    <string name="elem_RAMDualPort">RAM, portas separadas</string>
    <string name="elem_RAMDualPort_short">RAM</string>
    <string name="elem_RAMDualPort_tt">Módulo de RAM com portas separadas para armazenar e prover a saída para de dados armazenados.</string>
    <string name="elem_RAMDualPort_pin_A">Endereço onde ler ou gravar.</string>
    <string name="elem_RAMDualPort_pin_C">Entrada de clock</string>
    <string name="elem_RAMDualPort_pin_Din">Dados a serem armazenados.</string>
    <string name="elem_RAMDualPort_pin_D">Pino para a saída de dados</string>
    <string name="elem_RAMDualPort_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados visíveis.</string>
    <string name="elem_RAMDualPort_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>

     <string name="elem_BlockRAMDualPort">RAM-Bloco, portas separadas</string>
    <string name="elem_BlockRAMDualPort_pin_A">Endereço onde ler ou gravar.</string>
    <string name="elem_BlockRAMDualPort_pin_C">Entrada de clock</string>
    <string name="elem_BlockRAMDualPort_pin_D">Pino de saída de dados</string>
    <string name="elem_BlockRAMDualPort_pin_Din">Dados a serem armazenados em RAM.</string>
    <string name="elem_BlockRAMDualPort_pin_str">Se essa entrada estiver em nível alto, quando houver borda de subida do clock,  os dados serão armazenados.</string>
    <string name="elem_BlockRAMDualPort_short">RAM</string>
    <string name="elem_BlockRAMDualPort_tt">Módulo de RAM com entradas separadas para armazenar dados, e saída para se ler os dados armazenados.
        Essa RAM somente atualizará sua saída na borda de subida da entrada de clock.
        Isso permitirá o uso dessa RAM em FPGA.
    </string>
    
    <string name="elem_EEPROMDualPort">EEPROM, portas separadas</string>
    <string name="elem_EEPROMDualPort_short">EEPROM</string>
    <string name="elem_EEPROMDualPort_tt">Módulo de EEPROM com portas separadas para armazenar e prover a saída para de dados armazenados.</string>
    <string name="elem_EEPROMDualPort_pin_A">Endereço onde ler ou gravar.</string>
    <string name="elem_EEPROMDualPort_pin_C">Entrada de clock</string>
    <string name="elem_EEPROMDualPort_pin_Din">Dados a serem armazenados</string>
    <string name="elem_EEPROMDualPort_pin_D">Pino para a saída de dados</string>
    <string name="elem_EEPROMDualPort_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados visíveis.</string>
    <string name="elem_EEPROMDualPort_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>

    <string name="elem_RAMSinglePort">RAM, porta bidirecional</string>
    <string name="elem_RAMSinglePort_short">RAM</string>
    <string name="elem_RAMSinglePort_tt">Módulo de RAM com pino bidirecional para ler e gravar dados.</string>
    <string name="elem_RAMSinglePort_pin_A">Endereço onde ler ou gravar.</string>
    <string name="elem_RAMSinglePort_pin_C">Entrada de clock</string>
    <string name="elem_RAMSinglePort_pin_D">Conexão de dados bidirecional.</string>
    <string name="elem_RAMSinglePort_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados visíveis.</string>
    <string name="elem_RAMSinglePort_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
    <string name="elem_RAMSinglePortSel">RAM, seleção de chip</string>
    <string name="elem_RAMSinglePortSel_short">RAM</string>
    <string name="elem_RAMSinglePortSel_tt">Módulo de RAM com conexão bidirecional para ler e gravar dados.
        Se a entrada CS estiver em nível baixo, o componente estará desabilitado.
        Isso permitirá a construção de RAM's maiores a partir de módulos menores e um decodificador de endereços.</string>
    <string name="elem_RAMSinglePortSel_pin_A">Endereço onde ler ou gravar.</string>
    <string name="elem_RAMSinglePortSel_pin_WE">Se essa entrada estiver em nível alto, os dados serão gravados na RAM.</string>
    <string name="elem_RAMSinglePortSel_pin_D">Conexão de dados bidirectional.</string>
    <string name="elem_RAMSinglePortSel_pin_CS">Se essa entrada estiver em nível alto, essa RAM estará habilitada. De outro modo, a saída estará sempre em estado de alta impedância.</string>
    <string name="elem_RAMSinglePortSel_pin_OE">Se essa entrada estiver em nível alto, o valor armazenado estará disponível na saída.</string>
    <string name="elem_EEPROM">EEPROM</string>
    <string name="elem_EEPROM_tt">Módulo de EEPROM com conexão bidirecional para ler e gravar dados.
        Se a entrada CS estiver em nível baixo, o componente estará desabilitado.
        Os dados estarão armazenados tal como em uma ROM. Estarão assim preservados durante, e após, a simulação terminar e quando for reiniciada.</string>
    <string name="elem_EEPROM_pin_A">Endereço onde ler ou gravar.</string>
    <string name="elem_EEPROM_pin_WE">Se essa entrada estiver em nível alto, os dados serão escritos na EEPROM.</string>
    <string name="elem_EEPROM_pin_D">Conexão de dados bidirectional.</string>
    <string name="elem_EEPROM_pin_CS">Se essa entrada estiver em nível alto, essa EEPROM estará habilitada. De outro modo, a saída estará sempre em estado de alta impedância.</string>
    <string name="elem_EEPROM_pin_OE">Se essa entrada estiver em nível alto, o valor armazenado estará disponível na saída.</string>
    <string name="elem_GraphicCard">RAM gráfica</string>
    <string name="elem_GraphicCard_short">Gr-RAM</string>
    <string name="elem_GraphicCard_tt">Usada para exibir gráficos bitmap. Tem comportamento semelhante a de uma. Além disso, 
        exibirá seu conteúdo em ua janela gráfica. Cada pixel será representado por um endereço de memória. O valor armazenado definirá 
        a cor do pixel, a partir de uma paleta de cores fixa. Haverá dois buffers de tela implementados para dar suporte à mudança de páginas.
        A entrada B selecionará o buffer a ser exibido. Assim, o tamanho total da memória será dx * dy * 2 palavras.
    </string>
    <string name="elem_GraphicCard_pin_A">Endereço onde ler ou gravar.</string>
    <string name="elem_GraphicCard_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
    <string name="elem_GraphicCard_pin_C">Clock</string>
    <string name="elem_GraphicCard_pin_ld">Se essa entrada estiver em nível alto, os dados armazenados estarão disponíveis na saída.</string>
    <string name="elem_GraphicCard_pin_B">Selecionará o buffer de tela a ser exibido.</string>
    <string name="elem_GraphicCard_pin_D">Conexão de dados bidirectional.</string>

    <string name="elem_RAMDualAccess">RAM, duas portas</string>
    <string name="elem_RAMDualAccess_short">RAM</string>
    <string name="elem_RAMDualAccess_tt">RAM com uma porta que permitirá leitura e gravação, e uma outra porta
        onde apenas a leitura é permitida.
        A segunda porta pdoerá ser usada para dar a alguma lógica envolvendo parte gráfica acesso aos conteúdos de memória. Dessa maneira, o processador
        poderá escrever na RAM, enquanto a parte gráfica poderá ler da mesma simultaneamente.</string>
    <string name="elem_RAMDualAccess_pin_1D">Porta de saída 1</string>
    <string name="elem_RAMDualAccess_pin_2D">Porta de saída  2</string>
    <string name="elem_RAMDualAccess_pin_1A">Endereço onde a porta 1 irá ler ou gravar.</string>
    <string name="elem_RAMDualAccess_pin_2A">Endereço onde a porta 2 irá acessar para ler .</string>
    <string name="elem_RAMDualAccess_pin_C">Clock</string>
    <string name="elem_RAMDualAccess_pin_1Din">Dados a serem armazenados na RAM.</string>
    <string name="elem_RAMDualAccess_pin_ld">Se essa entrada estiver em nível alto, a saída estará ativada e os dados estarão visíveis em 1D.</string>
    <string name="elem_RAMDualAccess_pin_str">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>

    <string name="elem_RegisterFile">Bloco de registradores</string>
    <string name="elem_RegisterFile_short">Registrador</string>
    <string name="elem_RegisterFile_tt">Memória com uma porta que permitirá a gravação e duas portas que permitirão leituras simultâneas
        Poderá ser usada para implementar registradores em um processador.
        Dois registradores poderão ser lidos simultaneamente, enquanto um terceiro poderá ser escrito.</string>
    <string name="elem_RegisterFile_pin_Da">Porta de saída (a)</string>
    <string name="elem_RegisterFile_pin_Db">Porta de saída (b)</string>
    <string name="elem_RegisterFile_pin_Ra">Registrador visível à porta (a).</string>
    <string name="elem_RegisterFile_pin_Rb">Registrador visível à porta (b).</string>
    <string name="elem_RegisterFile_pin_Rw">Registrador no qual os dados serão escritos.</string>
    <string name="elem_RegisterFile_pin_we">Se essa entrada estiver em nível alto, quando da borda de subida do clock, os dados serão armazenados.</string>
    <string name="elem_RegisterFile_pin_C">Clock</string>
    <string name="elem_RegisterFile_pin_Din">Dados a serem armazenados no registrador Rw.</string>

    <string name="elem_Counter">Contador</string>
    <string name="elem_Counter_short">Contador</string>
    <string name="elem_Counter_tt">Componente que funcionará como contador simples. Dependendo da entrada de clock, será incrementado.
        Poderá retornar a zeor mediante udo da entrada clr.
        A largura de bits poderá ser determinada por uma caixa de diálogo de atributos.</string>
    <string name="elem_Counter_pin_C">Entrada de clock. Quando da borda de subida, incrementará o contador.</string>
    <string name="elem_Counter_pin_clr">Limpeza síncrona do contador se igual a 1.</string>
    <string name="elem_Counter_pin_out">Retornará o valor contado.</string>
    <string name="elem_Counter_pin_ovf">Transbordamento de saída (overflow). Esse pino será igual a 1 se o contador exceder seu valor máximo
        e a entrada en estiver em 1.</string>
    <string name="elem_Counter_pin_en">Se estiver em 1, o contador estará habilitado!</string>

    <string name="elem_CounterPreset">Contador com preset</string>
    <string name="elem_CounterPreset_tt">Contador com valor que poderá ser pré-estabelecido. Além disso, o valor máximo e a direção de contagem também poderão ser especificados.</string>
    <string name="elem_CounterPreset_short">Contador</string>
    <string name="elem_CounterPreset_pin_out">Retornará o valor contado.</string>
    <string name="elem_CounterPreset_pin_ovf">Saída de transbordamento (overflow output). Se estiver em 1, e a entrada en estiver em 1 e se o 
    contador alcançar seu valor máximo quando estiver sendo incrementado, ou quando atingir 0 ao ser decrementado.</string>
    <string name="elem_CounterPreset_pin_C">A entrada de clock. Quando da borda de subida, incrementará o contador.</string>
    <string name="elem_CounterPreset_pin_clr">Limpeza síncrona do contador se igual a 1.</string>
    <string name="elem_CounterPreset_pin_en">Se estiver em 1, o contador estará habilitado!</string>
    <string name="elem_CounterPreset_pin_dir">Especificará a direção de contagem. Se for 0 será para cima.</string>
    <string name="elem_CounterPreset_pin_ld">Se habilitado, o valor na entrada in será armazenado no contador no próximo sinal do clock.</string>
    <string name="elem_CounterPreset_pin_in">Palavra de dados a ser armazenada no contador quando (ld)  for habilitado.</string>


    <!--Arithmetic -->

    <string name="elem_Add">Somar</string>
    <string name="elem_Add_short">Soma</string>
    <string name="elem_Add_tt">Componente para realizar uma soma simples.
        Somará dois valores inteiros (a+b) presentes nas entradas (a) e (b).
        O resultado será incrementado em uma unidade se a entrada de carry estiver em nível alto.</string>
    <string name="elem_Add_pin_a">Primeira entrada para somar.</string>
    <string name="elem_Add_pin_b">Segunda entrada para somar.</string>
    <string name="elem_Add_pin_c_i">Entrada para carry-in, se estiver em nível alto, irá incrementar uma unidade.</string>
    <string name="elem_Add_pin_s">O resultado da soma</string>
    <string name="elem_Add_pin_c_o">Saída carry-out. Estará em nível ato se houver transbordamento (overflow).</string>
    <string name="elem_Sub">Subtrair</string>
    <string name="elem_Sub_short">Sub</string>
    <string name="elem_Sub_tt">Componente para realizar uma subtração simples.
        Subtrairá dois valores inteiros (a-b) presentes nas entradas (a) e (b).
        O resultado será decrementado em uma unidade se a entrada de carry estiver em nível alto.</string>
    <string name="elem_Sub_pin_c_i">Entrada para carry-in, se estiver em nível alto, irá decrementar de uma unidade.</string>
    <string name="elem_Sub_pin_a">Primeira entrada para subtrair.</string>
    <string name="elem_Sub_pin_b">Segunda entrada para subtrair.</string>
    <string name="elem_Sub_pin_s">O resultado da subtração.</string>
    <string name="elem_Sub_pin_c_o">Saída carry-out. Estará em nível alto se houver transbordamento (overflow).</string>
    <string name="elem_Mul">Multiplicar</string>
    <string name="elem_Mul_short">Mul</string>
    <string name="elem_Mul_tt">Componente para realizar uma multiplicação.
       Multiplicará dois valores inteiros (a*b) presentes nas entradas (a) e (b).
    </string>
    <string name="elem_Mul_pin_a">Primeira entrada para multiplicar.</string>
    <string name="elem_Mul_pin_b">Segunda entrada para multiplicar.</string>
    <string name="elem_Mul_pin_mul">O resultado da multiplicação.</string>
    <string name="elem_Div">Dividir</string>
    <string name="elem_Div_short">Div</string>
    <string name="elem_Div_tt">Componente para realizar uma divisão.
        Dividirá um valor inteiro por outro (a/b), ambos presentes nas entradas (a) e (b).
        Se o divisor for zero, o valor igual a 1 será usado no lugar.
        Em se tratando de divisão com sinal, o resto será sempre positivo.
    </string>
    <string name="elem_Div_pin_a">dividendo</string>
    <string name="elem_Div_pin_b">divisor</string>
    <string name="elem_Div_pin_q">quociente</string>
    <string name="elem_Div_pin_r">resto</string>
    <string name="elem_BarrelShifter">Registrador de deslocamento</string>
    <string name="elem_BarrelShifter_short">deslocar</string>
    <string name="elem_BarrelShifter_tt">Componente para deslocamento de bits.
        Deslocará o valor na entrada por certo número de bits presente à entrada.</string>
    <string name="elem_BarrelShifter_pin_in">Entrada com os bits a serem deslocados.</string>
    <string name="elem_BarrelShifter_pin_shift">Entrada com a largura a ser deslocada.</string>
    <string name="elem_BarrelShifter_pin_out">Saída com o valor deslocado.</string>
    <string name="elem_Comparator">Comparador</string>
    <string name="elem_Comparator_tt">Componente para comparar valores bit a bit.
        Irá comparar dois valores (a) e (b) presentes às entradas e compor as saídas correspondentes.</string>
    <string name="elem_Comparator_pin_a">Entrada (a) para comparar.</string>
    <string name="elem_Comparator_pin_b">Entrada (b) para comparar.</string>
    <string name="elem_Comparator_pin_=">Saída com o valor 1, se (a) igual a (b)</string>
    <string name="elem_Comparator_pin_&gt;">Saída com o valor igual a 1, se a entrada (a) for maior que (b)</string>
    <string name="elem_Comparator_pin_&lt;">Saída com o valor igual a 1, se a entrada (a) for menor que (b)</string>
    <string name="elem_Neg">Negação</string>
    <string name="elem_Neg_short">Neg</string>
    <string name="elem_Neg_tt">Complemento de 2</string>
    <string name="elem_Neg_pin_in">Entrada da palavra de dados a qual será aplicada o complemento de 2</string>
    <string name="elem_Neg_pin_out">Retornará o resultado da negação em complemento de 2.</string>
    <string name="elem_BitExtender">Extensor de sinal</string>
    <string name="elem_BitExtender_short">SinalEx</string>
    <string name="elem_BitExtender_tt">Incrementará a larguram em bits de um valor com sinal mantendo seu valor.
        Se a entrada for de um único bit, esse valor será disponível em todos os bits da saída.
    </string>
    <string name="elem_BitExtender_pin_in">Valor da entrada.
        A largura em bits da entrada que deverá ser menor que a largura em bits da saída!</string>
    <string name="elem_BitExtender_pin_out">Valor da entrada estendida.
        A largura em bits da entrada que deverá ser menor que a largura em bits da saída!</string>
    <string name="elem_BitCount">Contador de bits</string>
    <string name="elem_BitCount_short">ContaBits</string>
    <string name="elem_BitCount_tt">Retornará o número de bits iguais a 1 presentes no valor à entrada.</string>
    <string name="elem_BitCount_pin_in">Entrada para se contar os valores iguais a 1.</string>
    <string name="elem_BitCount_pin_out">Saída com a quantidade de valores iguais a 1.</string>


    <!-- Switches -->

    <string name="elem_DiodeForward">Diodo para  VDD</string>
    <string name="elem_DiodeForward_tt">Simples diodo unidirecional, usado para levar uma conexão para VDD.
        É usada para implementar uma OR de fios.
        Para isso é necessário conectar um resistor de pull down à saída do diodo.
        Na simulação o diodo se comportará como uma porta ativa com uma tabela-verdade trivalente:
        se a entrada estiver em nível alto, a saída também estará. Em todos os outros casos (entrada em nível baixo ou em alta impedância) a saída estará estado de alta impedância.
        De modo que dois diodos anti-paralelos poderão manter-se em nível alto, o que não seria possível com diodos reais.
        Esse é um diodo ideal: não haverá queda de tensão através de um diodo polarizado diretamente.</string>
    <string name="elem_DiodeForward_pin_in">Se a entrada estiver em nível alto, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
    <string name="elem_DiodeForward_pin_out">Se a entrada estiver em nível alto, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
    <string name="elem_DiodeBackward">Diode para Terra</string>
    <string name="elem_DiodeBackward_tt">Simples diodo unidirecional, usado para levar uma conexão para VDD. 
        É usada para implementar uma AND de fios.
        Para isso é necessário conectar um resistor de pull up à saída do diodo.
        Se a entrada estiver em nível baixo, a saída também estará. Em todos os outros casos (entrada em nível baixo ou em alta impedância) a saída estará estado de alta impedância.
        De modo que dois diodos anti-paralelos poderão manter-se em nível baixo, o que não seria possível com diodos reais.
        Esse é um diodo ideal: não haverá queda de tensão através de um diodo polarizado diretamente.</string>
    <string name="elem_DiodeBackward_pin_in">Se a entrada estiver em nível baixo, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
    <string name="elem_DiodeBackward_pin_out">Se a entrada estiver em nível baixo, a saída também estará. Em todos os outros casos, a saída estará estado de alta impedância.</string>
    <string name="elem_Switch">Chave</string>
    <string name="elem_Switch_tt">Interruptor simples.
        Não haverá atraso. Uma mudança de sinal irá propagar imediatamente.</string>
    <string name="elem_Switch_pin">Um das conexões da chave.</string>

    <string name="elem_SwitchDT">Chave de dois polos</string>
    <string name="elem_SwitchDT_tt">Chave de dois polos.
        Não haverá atraso. Uma mudança de sinal irá propagar imediatamente.</string>

    <string name="elem_Fuse">Fusível</string>
    <string name="elem_Fuse_tt">Fusível usado para construir uma memória programável uma única vez.</string>
    <string name="elem_Fuse_pin_out1">Um das conexões do fusível.</string>
    <string name="elem_Fuse_pin_out2">Um das conexões do fusível.</string>
    <string name="elem_Relay">Relé</string>
    <string name="elem_Relay_tt">Relé é uma chave que pode ser controlada por uma bobina.
        Se uma corrente fluir pela bobina, a chave fechará ou abrirá.
        Não haverá diodo de flyback de modo que an direção da corrente não será relevante.
        A chave atuará se as entradas tiverem valores diferentes.
        O relé se comportará de forma semelhante à porta XOR.</string>
    <string name="elem_Relay_pin_in1">Uma das entradas para controle do relé.</string>
    <string name="elem_Relay_pin_in2">Uma das entradas para controle do relé.</string>
    <string name="elem_RelayDT">Relé de dois polos</string>
    <string name="elem_RelayDT_tt">Relé é uma chave que pode ser controlada por uma bobina.
        Se uma corrente fluir pela bobina, a chave fechará ou abrirá.
        Não haverá diodo de flyback de modo que an direção da corrente não será relevante.
        A chave atuará se as entradas tiverem valores diferentes.
        O relé terá comportamento similar à porta XOR.</string>
    <string name="elem_RelayDT_pin_in1">Uma das entradas para controle do relé.</string>
    <string name="elem_RelayDT_pin_in2">Uma das entradas para controle do relé.</string>
    <string name="elem_PFET">FET tipo P</string>
    <string name="elem_PFET_tt">Transistor de efeito de campo tipo P.
        A base será conectada à referência de tensão positiva e o transistor será simulado sem um diodo interno.</string>
    <string name="elem_PFET_pin_G">Porta</string>
    <string name="elem_PFET_pin_S">Fonte</string>
    <string name="elem_PFET_pin_D">Dreno</string>
    <string name="elem_NFET">FET tipol N</string>
    <string name="elem_NFET_tt">Transistor de efeito de campo tipo N.
        A base será conectada à terra e o transistor será simulado sem um diodo interno.</string>
    <string name="elem_NFET_pin_G">Porta</string>
    <string name="elem_NFET_pin_S">Fonte</string>
    <string name="elem_NFET_pin_D">Dreno</string>
    <string name="elem_FGPFET">FET tipo P com porta flutuante</string>
    <string name="elem_FGPFET_tt">Transistor de efeito de campo tipo P com porta flutuante.
        A base será conectada à terra e o transistor será simulado sem um diodo interno.
        Se houver uma carga armazenada na porta flutuante, o transistor não conduzirá, mesmo se a porta estiver em nível baixo.
    </string>
    <string name="elem_FGPFET_pin_G">Porta</string>
    <string name="elem_FGPFET_pin_S">Fonte</string>
    <string name="elem_FGPFET_pin_D">Dreino</string>
    <string name="elem_FGNFET">FET tipo N com porta flutuante</string>
    <string name="elem_FGNFET_tt">Transistor de efeito de campo tipo N com porta flutuante.
        A base será conectada à terra e o transistor será simulado sem um diodo interno.
        Se houver uma carga armazenada na porta flutuante, o transistor não estará conduzindo ainda que a porta esteja em nível alto.</string>
    <string name="elem_FGNFET_pin_G">Porta</string>
    <string name="elem_FGNFET_pin_S">Fonte</string>
    <string name="elem_FGNFET_pin_D">Dreno</string>
    <string name="elem_TransGate">Porta de transmissão</string>
    <string name="elem_TransGate_tt">Uma porta de transmissão real é construída com apenas dois transistores.
        Por isso é frequentemente usada para se economizar transistores quando da implementação em silício.</string>
    <string name="elem_TransGate_pin_A">entrada A</string>
    <string name="elem_TransGate_pin_B">entrada B</string>
    <string name="elem_TransGate_pin_S">entrada de controle</string>
    <string name="elem_TransGate_pin_~S">entrada de controle invertida</string>


    <!-- Misc -->

    <string name="elem_Testcase">Caso de teste</string>
    <string name="elem_Testcase_tt">Descrever um caso de teste.
        Em um teste de caso será possível descrever o comportamento de um circuito. Isso poderá ser automaticamente verificado, ou seja,
        se o comportamento realmente corresponde à descrição, ou não, e assim sendo uma mensagem de erro será mostrada.
    </string>
    <string name="elem_AsyncSeq">Temporização assíncrona</string>
    <string name="elem_AsyncSeq_tt">Será permitido a temporização de um circuito sequencial assíncrono, tal como um pipeline de Muller.
        O circuito deverá ser iniciado em modo de passo único e deverá alcançar um estado estável logo ao iniciar-se.
        O circuito poderá ser então iniciado interativamente ou mediante uma porta de reinicialização.
        Não é permitido usar um componente de clock comum nesse modo.</string>
    <string name="elem_PowerSupply">Fonte</string>
    <string name="elem_PowerSupply_tt">Não possui qualquer função. Garante que a alimentação (VDD) e o terra (GND) estarão conectados.
        Poderá ser usada em circuitos 74xx para ligar os pinos de alimentação, e assim testar se corretamente conectados.</string>
    <string name="elem_PowerSupply_pin_VDD">Deverá ser conectada à fonte de alimentação (VDD)!</string>
    <string name="elem_PowerSupply_pin_GND">Deverá ser conectado ao terra (GND)!</string>
    <string name="elem_Reset">Reiniciar</string>
    <string name="elem_Reset_pin_Reset">Saída de reinicialização.</string>
    <string name="elem_Reset_tt">A saída desse componente será mantida em nível alto durante a inicialização do circuito.
        Após o circutio se estabilizar, a saída irá para o nível baixo.
        Se a saída for invertida, irá se comportar de forma oposta.</string>
    <string name="elem_Break">Pausa</string>
    <string name="elem_Break_pin_brk">Irá suspender uma simulação rapidamente se estiver em 1.</string>
    <string name="elem_Break_tt">Se a entrada desse componente estiver em nível alto, irá parar o clock de avanço rápido.
        Poderá ser usado para implementar uma instrução BRK em linguagem de montagem (assembly).
        Será possível simular um processador e interromper sua execução quando a instrução BRK for alcançada.
        O clock de avanço rápido somente poderá ser usado se o clock de tempo real estiver desabilitado.</string>

    <string name="elem_External">Externo</string>
    <string name="elem_External_tt">Componente que executará um processo externo para calcular uma função lógica.
        Será usado para especificar o comportamento de um componente mediante VHDL ou Verilog.
        A simulação real do comportamento deverá ser provida por meio de um simulador externo.
        Até o momento apenas os simuladores ghdl (VHDL) e Icarus Verilog têm suporte.
    </string>

    <string name="elem_Diode">Diodo</string>
    <string name="elem_Diode_tt">Diodo bidirecional simples. Servirá para implementar uma AND ou OR em fios.
        Corresponderá a um diodo ideal. não haverá queda de tensão caso o diodo estiver diretamente polarizado.</string>


    <string name="error">Erro</string>
    <string name="err_N_isNotInputOrOutput">Pino {0} no componente {1} não é uma entrada ou saída</string>
    <string name="err_aSingleClockNecessary">Um componente de clock comum é necessário. Todos os flip-flops devem ter esse sinal de clock.</string>
    <string name="err_analyseNoInputs">O circuito não possui entradas rotuladas</string>
    <string name="err_analyseNoOutputs">O circuito não possui saídas rotuladas</string>
    <string name="err_breakTimeOut">Interrupção temporizada após {0} ciclos</string>
    <string name="err_builder_exprNotSupported">Expressão {0} não tem suporte</string>
    <string name="err_builder_operationNotSupported">Operação {0} sem suporte</string>
     
     <string name="err_builder_couldNotFillLUT">Erro ao criar a LUT (LookUp Table).</string>
     
    <string name="err_burnError">Mais do que uma saída ativa em um fio, causando curto-circuito.</string>
    <string name="err_pullUpAndDown">Não é permitido conectar resistor de pull-up e pull-down à mesma rede.</string>
    <string name="err_cannotAnalyse_N">Não é possível analizar o nodo {0}</string>
    <string name="err_containsVarAndNotVar">Contém [var] e [not var]</string>
    <string name="err_duplicatePinLabel">Pino {0} no componente {1} está duplicado</string>
    <string name="err_element_N_notFound">Componente {0} não encontrado</string>
    <string name="err_exact_N0_valuesNecessaryNot_N1">Valor exato {0} necessário, e não {1}</string>
    <string name="err_ffNeedsToBeConnectedToClock">Flip-flop deve ser conectado ao sinal de clock.</string>
    <string name="err_invalidFileFormat">Formato de arquivo inválido</string>
    <string name="err_isAlreadyInitialized">A lógica já está inicializada</string>
    <string name="err_labelNotConnectedToNet_N">Um túnel {0} não está conectado!</string>
    <string name="err_moreThanOneClockFound">Há mais de um clock</string>
    <string name="err_needs_N0_bits_found_N2_bits">Necessários {0} bits, mas {1} bits encontrados</string>
    <string name="err_netOfPin_N_notFound">A rede de pino {0} não encontrada</string>
    <string name="err_noClockFound">Nenhum clock encontrado</string>
    <string name="err_noInputsAvailable">Nenhuma entrada disponível</string>
    <string name="err_noShapeFoundFor_N">Nenhum formato encontrado para o componente {0}</string>
    <string name="err_noValueSetFor_N0_atElement_N1">Nenhuma conexão na entrada ''{0}'' do componente ''{1}''. Entradas abertas não são permitidas.</string>
    <string name="err_notAllOutputsSameBits">Nem todas as saídas têm a mesma largura de bits</string>
    <string name="err_notAllOutputsSupportHighZ">Se múltiplas saídas estiverem conectadas, todas  deverão ser saídas tri-state.</string>
    <string name="err_noOutConnectedToWire">Nenhuma saída conectada ao fio ({0}). O estado do fio está indefinido.</string>
    <string name="err_oneResultIsRequired">Tabela sem valor. Pelo menos um resultado é requerido!</string>
    <string name="err_output_N_notDefined">Saída {0} não definida</string>
    <string name="err_pinMap_NoNameForPin_N">Nenhum rótulo para o pino {0}</string>
    <string name="err_pinMap_Pin_N_AssignedTwicePin">Pino {0} com dupla atribuição!</string>
    <string name="err_pinMap_noEqualsfound">Nenhum  = encontrado!</string>
    <string name="err_pinMap_pin_N0_isNotAnInput">Pino {0} não é de entrada!</string>
    <string name="err_pinMap_pin_N0_isNotAnOutput">Pino {0} não é de saída!</string>
    <string name="err_pinMap_toMannyInputsDefined">Entradas demais em uso!</string>
    <string name="err_pinMap_toMannyOutputsDefined">Saídas demais em uso!</string>
    <string name="err_pinNotPresent">Pino ausente</string>
    <string name="err_pinWithoutName">Encontrado um pino sem rótulo.</string>
    <string name="err_clockWithoutName">Encontrado um clock sem rótulo. Se houver um clocl integrado, esse deverá ter um rótulo.</string>
    <string name="err_pin_N0_atElement_N1_notFound">Pino {0} nãp encontrado no componente {1}</string>
    <string name="err_pin_N_notFound">Pino {0} não encontrado</string>
    <string name="err_pin_N_unknown">Pino {0} desconhecido</string>
    <string name="err_seemsToOscillate">Oscilação aparente.
        Melhor analizar a execução do circuito no modo de execução passo-a-passo.</string>
    <string name="err_portIsInUse">A porta remota está em uso! Há outra instância em execução?</string>
    <string name="err_selectorInputCountMismatch">Número de entradas não coincide com a largura em bits do seletor</string>
    <string name="err_spitterDefSyntaxError">Erro de sintaxe na definição do distribuidor {0}</string>
    <string name="err_splitterBitsMismatch">A largura em bits do distribuidor não coincide</string>
    <string name="err_splitterNotAllBitsDefined">Nem todos os bits de entrada estão definidos!</string>
    <string name="err_splitterNotUnambiguously">Bits de entrada definidos várias vezes!</string>
    <string name="err_spitterToManyBits">Somente são permitidos 64 bits no distribuidor!</string>
    <string name="err_tableBecomesToSmall">Duas entradas requeridas!</string>
    <string name="err_toManyInputs_max_N0_is_N1">Variáveis demais (entradas+flip-flops), são permitidas {0} mas {1} foram encontradas.</string>
    <string name="err_toManyInputsIn_N0_max_N1_is_N2">Variáveis demais usadas em {0},
        são permitidas {1}, mas {2} foram encontradas.</string>
    <string name="err_varNotAllowedInCUPL_N">Variável {0} não permitida em fonte CUPL!</string>
    <string name="err_varNotDefined_N">Variável {0} não definida</string>
    <string name="err_parserUnexpectedToken_N">Token {0} inesperado</string>
    <string name="err_parserMissingClosedParenthesis">Falta fechar parênteses</string>
    <string name="err_notANumber_N0_inLine_N1">Valor {0} na linha {1} não é um número!</string>
    <string name="err_testDataExpected_N0_found_N1_numbersInLine_N2">Valor esperado {0}, mas encontrado {1} na linha {2}!</string>
    <string name="err_unexpectedToken_N0_inLine_N1">Token inesperado ({0}) na linha {1}.</string>
    <string name="err_variable_N0_notFound">Variável {0} não encontrada!</string>
    <string name="err_noTestInputSignalsDefined">Nenhum sinal de entrada definido no arranjo de testes!</string>
    <string name="err_noTestOutputSignalsDefined">Nenhum sinal de saída definido no arranjo de testes!</string>
    <string name="err_noTestData">Não há dados para testes.</string>
    <string name="err_remoteExecution">Erro durante a execução de um comando remoto</string>
    <string name="err_pullUpAndDownNotAllowed">Não é permitido conectar um resistor de pull up e pull down ao mesmo fio.</string>
    <string name="err_openingDocumentation">Não foi possível abrir o navegador.</string>
    <string name="err_couldNotCreateFolder_N0">Não foi possível criar a pasta {0}!</string>
    <string name="err_switchHasNoNet">Não é permitido conectar apenas entradas a uma chave.</string>
    <string name="err_file_N0_ExistsTwiceBelow_N1">O arquivo {0} existe várias vezes abaixo {1}.</string>
    <string name="err_couldNotFindIncludedFile_N0">Não foi possível encontrar o arquivo {0}.</string>
    <string name="err_postProcessErrorIn_N0">Erro durante a execução de {0}.</string>
    <string name="err_processDoesNotTerminate_N">O processo {0} não tem retorno!</string>
    <string name="err_processExitedWithError_N1_N2">O processo retorna um valor diferente de zero {0}: {1}</string>
    <string name="err_errorRunningFitter">Erro ao iniciar o instalador externo!</string>
    <string name="err_noExpressionsAvailable">Não há equações mínimas!</string>
    <string name="err_varName_N_UsedTwice">A variável {0} está duplicada!</string>
    <string name="err_fileNeedsToBeSaved">O arquivo precisa ser salvo!</string>
    <string name="err_recursiveNestingAt_N0">O circuito {0} importa a si mesmo!</string>
    <string name="err_minimizationFailed">O resultado da minimização não está correto.!
        Os nomes das variáveis podem não ser únicos.</string>
    <string name="err_toManyIterations">Iterações demais em uma repetição.</string>
    <string name="err_diodeNeedsPullUpResistorAtOutput">Diodo requer resistores de pull up em todoas as suas saídas!</string>
    <string name="err_diodeNeedsPullDownResistorAtOutput">Diodo requer resistores de pull down em todas as suas saídas!</string>
    <string name="err_testSignal_N_notFound">Sinal de teste {0} não encontrado no circuito!</string>
    <string name="err_toManyBits_Found_N0_maxIs_N1">Somente permitidos {1} bits, mas {0} foram encontrados!</string>
    <string name="err_MultiBitFlipFlopFound">Flip-flops para mais de um bit não são permitidos!</string>
    <string name="err_invalidTransmissionGateState">As duas entradas de controle de uma porta de transmissão devem ser invertidas!</string>
    <string name="err_nameUsedTwice_N">O sinal {0} está duplicado!</string>
    <string name="err_errorParsingTestdata">Erro durante a varredura dos dados para testes.</string>
    <string name="err_backtrackOf_N_isImpossible">O componente modelo {0} não pode ser analisado.</string>
    <string name="err_errorInPowerSupply">Erro ao conectar uma fonte de alimentação a {0}.</string>
    <string name="err_pinIsNotANumber_N">O número do pino {0} não é inteiro!</string>
    <string name="err_vhdlExporting">Erro ao exportar para VHDL.</string>
    <string name="err_vhdlNoEntity_N">Nenhum código VHDL disponível para {0}!</string>
    <string name="err_verilogNoElement_N">Nenhum código Verilog disponível para {0}!</string>
    <string name="err_vhdlPin_N_hasNoNumber">Pino {0} sem número!</string>
    <string name="err_vhdlErrorWritingTestBench">Erro ao criar os casos de testes!</string>
    <string name="err_vhdlValuesOfType_N_notAllowed">Valores de tipo {0} não são permitidos!</string>
    <string name="err_vhdlANameIsMissing">Falta nome. Todos os pinos têm rótulos (por exemplo)?</string>
    <string name="err_toManyVars">Variáves em excesso!</string>
    <string name="err_invalidExpression">Expressão inválida!</string>
    <string name="err_function_N0_notFoundInLine_N1">Função {0} não encontrada na linha {1}!</string>
    <string name="err_wrongNumOfArgsIn_N0_InLine_N1_found_N2_expected_N3">Número de parâmetros incorreto na função {0} na linha {1} (encontrados {2}, esperados {3})!</string>
    <string name="err_invalidValue_N0_inFunction_N1">Valor inválido {0} na função {1}!</string>
    <string name="err_Node_N_isAComponent">O nome do caminho inválido {0}.</string>
    <string name="err_loadingLibrary">Erro ao carregar uma biblioteca.</string>
    <string name="err_noManifestFound">O arquivo JAR não contém manifesto!</string>
    <string name="err_noMainFoundInManifest">O manifesto não contém uma entrada para a Main-Class!</string>
    <string name="err_mainClass_N_NotFound">Não foi possível encontrar a classe {0}!</string>
    <string name="err_couldNotInitializeMainClass_N">Não foi possível criar uma instãncia para a classe {0}!</string>
    <string name="err_notMoreOutBitsThanInBits">Necessário haver mais bits de entrada que de saída!</string>
    <string name="err_constantsNotAllowed">~Não é possível definir pinos físicos para valores constantes!</string>
    <string name="err_invalidNumberFormat_N_N">O string {0} não é um número válido (pos {1})!</string>
    <string name="err_invalidPinName_N">O nome {0} não é permitido!</string>
    <string name="err_whiteSpaceNotAllowedInTT2Name">Espaços em branco não são permitidos em nome de arquivo TT2!</string>
    <string name="err_tableHasToManyResultColumns">A tabela tem colunas demais!</string>
    <string name="err_errorExportingZip">Erro ao gravar arquivo compactado (zip).</string>
    <string name="err_moreThanOneFastClock">Apenas um componente de clock com alta frequência é permitido.</string>
    <string name="err_circuitHasCycles">O circuito contém ciclos. Não é possível analisar tal circuito.
        Ciclos podem ocorrer se a saída de uma porta é realimentada com entrada da mesma.
        O uso de chaves, FETs ou relés podem causar ciclos.</string>
    <string name="err_monoflopRequiresOneClock">Se um monoflop for usado, deverá haver um único componente de clock!</string>
    <string name="err_centralDefinedRomsAreNotSupported">ROM's definidas nas configurações não têm suporte!</string>
    <string name="err_couldNotCreateElement_N">Não foi possível criar um componente do tipo {0}!</string>

    <string name="err_errorWritingDataToProcess">Não foi possível gravar valores no processo externo!</string>
    <string name="err_errorReadingDataFromProcess">Não foi possível ler valores do processo externo!</string>
    <string name="err_errorCreatingProcess">Não foi possível criar o processo externo!</string>
    <string name="err_timeoutReadingData_O">Excedido o tempo de leitura para dados do processo externo!
        {0}</string>
    <string name="err_notEnoughDataReceived_O">Dados insuficientes recebidos!
        {0}</string>
    <string name="err_invalidCharacterReceived_N_O">O texto recebido contém um caractere inválido: {0}!
        {1}</string>
    <string name="err_processTerminatedUnexpected_O">O processo terminou de forma inesperada!
        {0}</string>
    <string name="err_couldNotTerminateProcess">Não foi possível terminar o processo!</string>
    <string name="err_couldNotStartProcess_N">Não foi possível iniciar o processo: {0}</string>
    <string name="err_exitValueNotNull_N_O">O status de saída da aplicação não foi 0, mas {0}:
        {1}</string>
    <string name="err_canOnlyExportExternalVHDL">Código externo somente pode ser exportado se for em VHDL!</string>
    <string name="err_canOnlyExportExternalVerilog">Código externo somente pode ser exportado se for em Verilog!</string>
    <string name="err_ifExternalComponentIsUsedTwiceCodeMustBeIdentical_N">Se um componente externo for usado várias vezes, o código deverá ser o mesmo! Efeitos: {0}</string>
    <string name="err_writingToStdOut_O">Não foi possível escrever na saída padrão:
        {0}</string>
    <string name="err_ghdlNotInstalled">
        O simulador de VHDL (ghdl) parece não estar instalado. Recomendável instalar ghdl (http://ghdl.free.fr/) e tentar de novo. Se ainda houver problemas, conferir os caminhos para os executáveis do ghdl nas configuraçãoes do Digital.
    </string>
    <string name="err_iverilogNotInstalled">
        O simulador Icarus Verilog parece não estar instalado. Recomendável instalar o iverilog (http://iverilog.icarus.com/) e tentar de novo. Se ainda houver problemas, conferir os caminhos para os executáveis do iverilog nas configurações do Digital.
    </string>
    <string name="err_errorAnalysingCircuit_N">Erro ao analisar o circuito: {0}</string>
    <string name="err_romNeedsALabelToBeExported">Toda ROM necessita um rótulo único para ser exportada!</string>
    <string name="err_counterNeedsMoreBits">O contador necessita de dois bits no mínimo.</string>
    <string name="err_namesAreNotUnique_N">O nome "{0}" não é único!</string>
    <string name="err_clocksNotAllowedInAsyncMode">Elementos de clock não podem ser usados em modo assíncrono.</string>
    <string name="err_verilogExporting">Erro ao exportar para Verilog.</string>
    <string name="err_noRomFound">Nenhuma memória de programa encontrada! A memória de programa precisa ser indicada como tal.</string>
    <string name="err_errorLoadingRomData">Erro ao carregar a memória de programa.</string>
    <string name="err_parsingSVG">Erro durante a leitura do arquivo SVG.</string>
    <string name="err_morePinsDefinedInSVGAsNeeded">O arquivo SVG contém pinos que não existem no circuito.</string>

    <string name="err_allMemoriesNeedToHaveTheSameByteWidth">Todas as memórias em que dados deverão ser carregados requerem a mesma largura de bits.</string>
    <string name="err_ProgMemLabelsNotDifferent">Se programas serão carregados em várias RAMs, todas deverão ter nomes distintos.
        A ordem lexicográfica determinará a ordenação das RAMs.</string>
    <string name="err_whileExecutingTests_N0">Durante a execução de testes "{0}" um erro foi encontrado!</string>

    <string name="key_AddrBits">Bits de endereço</string><!-- ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM -->
    <string name="key_AddrBits_tt">Número de bits de endereço usado.</string>
    <string name="key_Bits">Bits de dados</string><!-- And, NAnd, Or, NOr, XOr, XNOr, Not, LookUpTable, Delay, Out, In, Ground, VDD, Const, PullUp, PullDown, Driver, DriverInvSel, Multiplexer, Demultiplexer, D_FF, D_FF_AS, Register, ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM, GraphicCard, Counter, Add, Sub, Mul, BarrelShifter, Comparator, Neg, BitCount, Switch, Relay, PFET, NFET, FGPFET, FGNFET, TransGate -->
    <string name="key_Bits_tt">Número de bits de dados usados.</string>
    <string name="key_Color">Cor</string><!-- LED, LightBulb, Seven-Seg, Seven-Seg-Hex, LedMatrix -->
    <string name="key_Color_tt">A cor do elemento.</string>
    <string name="key_backgroundColor">Cor de fundo (background)</string>
    <string name="key_backgroundColor_tt">Cor de fundo para o circuito quando estiver integrado a outro. Não é usada em encapsulamentos DIL.</string>
    <string name="key_Cycles">Ciclos de temporização</string><!-- Break -->
    <string name="key_Cycles_tt">Se a quantidade de ciclos for alcançada sem um sinal de interrupção, uma situação de erro se estabelecerá.</string>
    <string name="key_Data">Dados</string><!-- LookUpTable, ROM, EEPROM -->
    <string name="key_Data_tt">Os valores armazenados nesse elemento.</string>
    <string name="key_Default">Valor padrão</string><!-- Demultiplexer, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS -->
    <string name="key_Default_tt">Valor definido para o circuito quando for ligado.
        No demultiplexador, esse valor será definido para as saídas não selecionadas.</string>
    <string name="key_InDefault">Valor padrão</string><!-- In -->
    <string name="key_InDefault_tt">Valor definido para o circuito quando for ligado. "Z" significa alta impedância.</string>
    <string name="key_isHighZ">Entrada tri-state</string><!-- In, Splitter -->
    <string name="key_isHighZ_tt">Se definido, permite-se que a entrada esteja em alta impedância. Em um componente de entrada, 
        isso também será permitido, se ("Z") estiver definido como valor padrão.</string>

    <string name="key_avoidActiveLow">Nenhuma saída em zero.</string>
    <string name="key_avoidActiveLow_tt">Evitar saída em zero. Isso será útil especialmente quando forem definidos circuitos com relés .
        Somente poderá ser ativada se uma saída em alta impedância for permitida.</string>       
        
    <string name="key_Description">Descrição</string><!-- Out, In, Text -->
    <string name="key_Description_tt">Uma breve descrição do elemento e como usá-lo.</string>
    <string name="key_Frequency">Frequência/Hz</string><!-- Clock -->
    <string name="key_Frequency_tt">Frequência em tempo real a ser usada no clock de tempo real</string>
    <string name="key_IEEEShapes">Usar formatos IEEE 91-1984</string>
    <string name="key_IEEEShapes_tt">Usar formatos IEEE 91-1984 em lugar dos retangulares</string>
    <string name="key_Inputs">Número de entradass</string><!-- And, NAnd, Or, NOr, XOr, XNOr, LookUpTable -->
    <string name="key_Inputs_tt">Número de entradas usado. Cada entrada necessitará estar contectada.</string>
    <string name="key_Label">Rótulo</string><!-- Out, LED, In, Clock, Button, Probe, LightBulb, LedMatrix, RotEncoder, Keyboard, Terminal, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Register, ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM, GraphicCard, Counter, Add, Sub, Mul, BarrelShifter, Comparator, Switch, Relay, PFET, NFET, FGPFET, FGNFET, Testcase, PowerSupply, Reset, Break -->
    <string name="key_Label_tt">Nome do elemento.</string>
    <string name="key_Size">Tamanho</string><!-- LED, SevenSeg -->
    <string name="key_Size_tt">Tamanho do formato no circuito.</string>
    <string name="key_Language">Idioma</string>
    <string name="key_Language_tt">Idioma na interface gráfica (GUI). Será efetivo apenas após reinicialização.</string>
    <string name="key_NetName">Nome da rede</string><!-- Tunnel -->
    <string name="key_NetName_tt">ATodas as redes com nomes idênticas estarão ligadas entre si.</string>
    <string name="key_InputSplitting">Entrada para o distribuidor</string><!-- Splitter -->
    <string name="key_InputSplitting_tt">Se, por exemplo, quatro bits, dois bits mais outros dois serão usados como entradas,
        isso poderá ser configurado como "4,2,2". A quantidade indicará o número de bits. Por conveniência, o asterisco
        poderá ser usado: 16 bits poderão ser configurados como "[bits]*[quantidade]", ou seja, "1*16".
        Também é possível especificar os bits a serem usados diretamente e em qual ordem.
        Por exemplo, "4-7,0-3" configurará os bits 4-7 e 0-3. Essa notação permitirá qualquer arranjo de bits desejado.
        Os bits de entrada deverão ser especificados de forma completa e inequívoca.</string>
    <string name="key_OutputSplitting">Saída do distribuidor</string><!-- Splitter -->
    <string name="key_OutputSplitting_tt">Se, por exemplo, quatro bits, dois bits mais outros dois serão usados como saídas,
        isso poderá ser configurado como "4,2,2". A quantidade indicará o número de bits. Por conveniência, o asterisco
        poderá ser usado: 16 bits poderão ser configurados como "[bits]*[quantidade]", ou seja, "1*16".
        Também é possível especificar os bits a serem usados diretamente e em qual ordem.
        Os bits de saída poderão ser combinados várias vezes: "0-7,1-6,4-7"</string>
    <string name="key_SelectorBits">Número de bits do seletor</string><!-- Multiplexer, Demultiplexer, Decoder -->
    <string name="key_SelectorBits_tt">Número de bits usados na entrada do seletor.</string>
    <string name="key_Signed">Operação com sinal</string><!-- Comparator, Div -->
    <string name="key_Signed_tt">Se selecionado, a operação será executada usando valores com sinal (em complemento de 2).</string>
    <string name="key_Closed">Fechada</string><!-- Switch -->
    <string name="key_Closed_tt">Estado inicial definido para a chave.</string>
    <string name="key_Value">Valor</string><!-- Const -->
    <string name="key_Value_tt">Valor de uma constante.</string>
    <string name="key_Width">Largura</string>
    <string name="key_Width_tt">Largura do símbolo a ser usada se o circuito for componente de outro.</string>
    <string name="key_Height">Altura</string>
    <string name="key_Height_tt">Altura do símbolo a ser usada se o circuito for componente de outro.</string>
    <string name="key_autoReload">Carga inicial do modelo</string><!-- ROM -->
    <string name="key_autoReload_tt">Recarregar o arquivo hexadecimal toda vez que o modelo for ligado.</string>
    <string name="key_flipSelPos">Alternar posição do seletor</string><!-- Driver, DriverInvSel, Multiplexer, Demultiplexer, Decoder -->
    <string name="key_flipSelPos_tt">Essa opção permitirá deslocar o pino do seletor para o lado oposto.</string>
    <string name="key_intFormat">Formato para número</string><!-- Probe -->
    <string name="key_intFormat_tt">Formato a ser usado para mostrar números.</string>
    <string name="key_intFormat_ascii">ASCIIi</string>
    <string name="key_intFormat_bin">binário</string>
    <string name="key_intFormat_dec">decimal</string>
    <string name="key_intFormat_decSigned">decimal com sinal</string>
    <string name="key_intFormat_def">padrão</string>
    <string name="key_intFormat_hex">hexadecimal</string>
    <string name="key_barrelSigned">Entrada para o deslocamento com sinal</string><!-- BarrelShifter -->
    <string name="key_barrelSigned_tt">Entrada para o deslocamento em complemento de 2</string>
    <string name="key_barrelShifterMode">Modo</string><!-- BarrelShifter -->
    <string name="key_barrelShifterMode_tt">Modo do registrador de deslocamento</string>
    <string name="key_barrelShifterMode_logical">Lógico</string>
    <string name="key_barrelShifterMode_rotate">Rotação</string>
    <string name="key_barrelShifterMode_arithmetic">Aritmético</string>
    <string name="key_direction">Direção</string><!-- BarrelShifter -->
    <string name="key_direction_tt">Definir direção.</string>
    <string name="key_direction_left">esquerda</string>
    <string name="key_direction_right">direita</string>
    <string name="key_maxStepCount">Número máximo de passos a serem mostrados</string><!-- Data -->
    <string name="key_maxStepCount_tt">Número máximo de valores armazenados.
        Se o quantidade máxima for alcançada, os valores mais antigos serão descartados.</string>
    <string name="key_microStep">Mostrar passo-a-passo</string><!-- Data -->
    <string name="key_microStep_tt">Mostrar todos os passos graficamente.</string>
    <string name="key_rotation">Rotação</string><!-- And, NAnd, Or, NOr, XOr, XNOr, Not, LookUpTable, Delay, Out, LED, In, Clock, Button, Probe, LightBulb, LedMatrix, RotEncoder, Keyboard, Terminal, Ground, VDD, Const, Tunnel, Splitter, PullUp, PullDown, Driver, DriverInvSel, Multiplexer, Demultiplexer, Decoder, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Register, ROM, RAMDualPort, RAMSinglePort, RAMSinglePortSel, EEPROM, GraphicCard, Counter, Add, Sub, Mul, BarrelShifter, Comparator, Neg, BitCount, DiodeForward, DiodeBackward, Switch, Fuse, Relay, PFET, NFET, FGPFET, FGNFET, TransGate, PowerSupply, Reset, Break -->
    <string name="key_rotation_tt">Orientação do elemento no circuito.</string>
    <string name="key_runRealTime">Iniciar o clock de tempo real</string><!-- Clock -->
    <string name="key_runRealTime_tt">Se habilitado o clock da execução será iniciado juntamente com a ligação do circuito</string>
    <string name="key_showDataGraph">Mostrar o gráfico de medidas juntamente com o início da simulação</string>
    <string name="key_showDataGraph_tt">Ao iniciar a simulação, o gráifco de valores medidos também será mostrado.</string>
    <string name="key_showDataGraphMicro">Mostrar o gráfico de medidas juntamente com o início da simulação passo-a-passo</string>
    <string name="key_showDataGraphMicro_tt">Ao iniciar a simulação, o gráifco de valores medidos também será mostrado no modo passo-a-passo.
        Todas as mudanças em portas estarão relacionadas no gráfico.</string>
    <string name="key_showDataTable">Mostrar o gráfico de medidas juntamente com o início da simulação</string>
    <string name="key_showDataTable_tt">Quando a simulação iniciar, uma tabela com os valores medidos será mostrada.</string>
    <string name="key_termHeight">Linhas</string><!-- Terminal -->
    <string name="key_termHeight_tt">Número de linhas a serem mostradas.</string>
    <string name="key_termWidth">Caracteress por linha</string><!-- Terminal -->
    <string name="key_termWidth_tt">Número de caracteres a serem mostrados em cada linha.</string>
    <string name="key_valueIsProbe">Usar como valor medido</string><!-- RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Register -->
    <string name="key_valueIsProbe_tt">Se definido, o valor será usado como o de medição, e será mostrado no gráfico e também na tabela de dados.
        Além disso, um rótulo deverá ser especificado para servir como identificação do valor.</string>
    <string name="key_Testdata">Dados para teste</string><!-- Testcase -->
    <string name="key_Testdata_tt">Descrição de um caso de teste.
        Detalhes de sintaxe poderão ser encontrados na caixa de diálogo para ajuda no editor de caso de teste.</string>
    <string name="key_graphicWidth">Largura em pixels</string><!-- GraphicCard -->
    <string name="key_graphicWidth_tt">Largura da tela em pixels.</string>
    <string name="key_graphicHeight">Altura em pixels</string><!-- GraphicCard -->
    <string name="key_graphicHeight_tt">Altura da tela em pixels.</string>
    <string name="key_isProgramMemory">Memória de programa</string><!-- ROM -->
    <string name="key_isProgramMemory_tt">Tomar o conteúdo da ROM como a memória de programa. Dessa forma, poderá ser acessado por uma IDE externa.</string>
    <string name="key_isProgramCounter">Contador de programa</string>
    <string name="key_isProgramCounter_tt">Tomar o registrador como contador de programa. O valor do registrador será tomado
        a partir da IDE do montador externo para marcar a linha de código corrente durante a depuração.</string>
    <string name="key_Blown">Programado</string><!-- DiodeForward, DiodeBackward, Fuse, FGPFET, FGNFET -->
    <string name="key_Blown_tt">Se o diodo estiver "programado" ou não ("blown").
        Em uma porta flutuante FET, estará com carga.
        Poderá ser definido apenas pela letra 'p'.</string>
    <string name="key_ExpressionFormat">Formato</string>
    <string name="key_ExpressionFormat_tt">Formato da tela para expressões.</string>
    <string name="key_relayNormallyClosed">Relé normalmente fechado.</string><!-- Relay -->
    <string name="key_relayNormallyClosed_tt">Se o relé estiver fechado, a entrada estará em nível baixo.</string>
    <string name="key_poles">Número de polos</string><!-- Relay -->
    <string name="key_poles_tt">Número de polos disponíveis.</string>
    <string name="key_commonCathode">cátodo comum</string><!-- Seven-Seg -->
    <string name="key_commonCathode_tt">Se a entrada for selecionada como cátodo comum, também será simulada.</string>
    <string name="key_ledPersistence">Prevenir o piscamento (flicker)</string><!-- Seven-Seg, LedMatrix -->
    <string name="key_ledPersistence_tt">Se não for possível aumentar a frequência o bastante para que o efeito de piscamento possa desaparecer.
        Com essa opção se poderá estabilizar o display mantendo os LEDs ligados até que o cátodo comum vá para nível baixo novamente.
        Isso simulará uma frequência acima da crítica para a fusão.</string>
    <string name="key_atf1502Fitter">Filtro ATF15xx</string>
    <string name="key_atf1502Fitter_tt">Caminho para o filtro ATF15xx.
        Fornecer a pasta que contenha os arquivos fit15xx.exe fornecidos pela Microchip (antes ATMEL).</string>
    <string name="key_pin">Número do pino</string>
    <string name="key_pin_tt">Um campo vazio significará que o sinal não está associado ao pino.</string>
    <string name="key_rowDataBits">Linhas</string><!-- LedMatrix -->
    <string name="key_rowDataBits_tt">Especificação do número de linhas mediante a largura em bits da palavra correspondente.</string>
    <string name="key_colAddrBits">Bits de endereço das colunas</string><!-- LedMatrix -->
    <string name="key_colAddrBits_tt">Endereços das colunas individuais. Três bits corresponderão a oito colunas.</string>
    <string name="key_lockedMode">Modificação bloqueada</string>
    <string name="key_lockedMode_tt">O circuito está bloqueado. É possível configurar diodos e FGF-FETs.</string>
    <string name="key_pinNumber">Número do pino</string><!-- Out, In, Clock -->
    <string name="key_pinNumber_tt">Número desse pino. Usado para a representação de um circuito com encapsulamento DIL e 
        quando a a atribuição ao pino for usada na programação de um CPLD.
        Se houver vários bits, todos os números de pinos poderão ser especificados por uma lista, separados por vírgulas.</string>
    <string name="key_pinCount">Número de pinos DIL</string>
    <string name="key_pinCount_tt">Número de pinos. Se igual a zero, significa que o número de pinos será determinado automaticamente.</string>
    <string name="key_defTreeSelect">A hierarquia de componentes visível desde a inicialização.</string>
    <string name="key_defTreeSelect_tt">Se definido, fará com que a hierarquia de componentes seja visível desde a inicialização.</string>
    <string name="key_inverterConfig">Entradas invertidas</string><!-- And, NAnd, Or, NOr, XOr, XNOr, RS_FF, JK_FF, D_FF, T_FF, JK_FF_AS, D_FF_AS, Counter -->
    <string name="key_inverterConfig_tt">É possível selecionar entradas cujos valores serão invertidos.</string>
    <string name="key_fontSize">Tamanho da fonte em menus [%]</string>
    <string name="key_fontSize_tt">O tamanho das fontes usadas no menu é dada em uma porcentagem do tamanho padrão.</string>
    <string name="key_withEnable">Entrada para habilitação</string><!-- T_FF -->
    <string name="key_withEnable_tt">Se definido, tornará a entrada de habilitação (T) disponível.</string>
    <string name="key_unidirectional">Unidirecional</string><!-- PFET, NFET -->
    <string name="key_unidirectional_tt">Transistores unidirectionais propagarão um sinal somente da fonte para o dreno.
        Eles são muito mais rápidos para simular do que os transistores bidirecionais. Desde que não haja realimentação do dreno para a fonte, nesse modo,
        o transistor não poderá causar curto-circuito de fios quando estiver conduzindo. Assim, será possível simular
        certos circuitos CMOS.</string>
    <string name="key_activeLow">Ativo em nível baixo</string><!-- Button -->
    <string name="key_activeLow_tt">Se selecionada a saída estará em nível baixo, quando o circuito estiver ativo.</string>
    <string name="key_libraryPath">Biblioteca</string>
    <string name="key_libraryPath_tt">Pasta contendo a biblioteca com sub-circuitos predefinidos.
        Contém, por exemplo, os componentes da sére 74xx. Também será possível adicionar circuitos próprios que estejam guardados nesse mesmo lugar.
        Deve-se garantir que os nomes de todos os arquivos nessa pasta e subpastas sejam únicos.</string>
    <string name="key_grid">Mostrar grade.</string>
    <string name="key_grid_tt">Mostrar uma grade na tela principal.</string>
    <string name="key_mapToKey">Mapear para o teclado</string><!-- Button -->
    <string name="key_mapToKey_tt">Botão mapeado para o teclado.
        Para usar as teclas do cursor, utilizar as teclas de direção UP, DOWN, LEFT ou RIGHT.</string>
    <string name="key_jarPath">Biblioteca Java</string>
    <string name="key_jarPath_tt">Arquivo jar contendo componentes adicionais implementados em Java.</string>
    <string name="key_showWireBits">Mostrar o número de fios em um barramento.</string>
    <string name="key_showWireBits_tt">ATENÇÃO: O valor será atualizado somente quando a simulação for iniciada.</string>
    <string name="key_inputBits">Largura em bits da entrada</string><!-- BitExtender -->
    <string name="key_inputBits_tt">O número de bits da saída deverá ser maior do que o número de bits da entrada.</string>
    <string name="key_outputBits">Largura em bits da saída</string><!-- BitExtender -->
    <string name="key_outputBits_tt">O número de bits da saída deverá ser maior queo o número de bits da entrada.</string>
    <string name="key_textFontSize">Tamanho da fonte</string>
    <string name="key_textFontSize_tt">Definição do tamanho de fonte a ser usado nesse texto.</string>
    <string name="key_delayTime">Duração</string>
    <string name="key_delayTime_tt">Unidades de tempo do atraso de propagação das portas comuns.</string>
    <string name="key_invertOutput">Saída invertida</string>
    <string name="key_invertOutput_tt">Se definido, inverterá a saída.</string>
    <string name="key_timerDelay">Largura de pulso</string>
    <string name="key_timerDelay_tt">A largura de pulso é medida em ciclos de clock.</string>
    <string name="key_splitterSpreading">Propagação</string>
    <string name="key_splitterSpreading_tt">Configuração de como irão se propagar as entradas e saídas no circuito.</string>
    <string name="key_romContent">Conteúdo das ROM's</string>
    <string name="key_romContent_tt">Conteúdo de todas as ROM's usadas</string>

    <string name="key_applicationType">Aplicação</string>
    <string name="key_applicationType_tt">Definição de qual aplicação usar.</string>
    <string name="key_applicationType_Generic">Genérico</string>
    <string name="key_applicationType_GHDL">GHDL</string>
    <string name="key_applicationType_IVERILOG">IVerilog</string>
    <string name="key_externalInputs">Entradas</string>
    <string name="key_externalInputs_tt">Entradas do processo externo.
        Lista de nomes de sinais separados por vírgulas. Após cada nome de sinal, separado por dois-pontos, um número de bits
        pode ser especificado. As entradas de 8 bits de um somador poderão ser descritas como  "a:8,b:8,c_in".</string>
    <string name="key_externalOutputs">Saídas</string>
    <string name="key_externalOutputs_tt">As saídas do processo externo.
        Lista de nomes de sinais separados por vírgulas. Após cada nome de sinal, separado por dois-pontos, um número de bits
        pode ser especificado. As saídas de 8 bits de um somador poderão ser descritas como  "a:8,b:8,c_in". "s:8,c_out".</string>
    <string name="key_Code">Código de programa</string>
    <string name="key_Code_tt">Definição do código de programa a ser executado na aplicação externa.</string>
    <string name="key_ghdlPath">GHDL</string>
    <string name="key_ghdlPath_tt">Caminho parao arquivo executável ghdl. Somente será necessário se for desejado usar ghdl para simular
        componentes definidos em vhdl.</string>
    <string name="key_iverilogPath">IVerilog</string>
    <string name="key_iverilogPath_tt">Caminho para a pasta de instalação do Icarus Verilog. Somente será necessário se for desejado usar iverilog para simular
        componentes definidos em  verilog.</string>
    <string name="key_maxValue">Valor máximo</string>
    <string name="key_maxValue_tt">Se o valor zero for fornecido, o maior valor possível será usado (todos os bits em 1).</string>

    <string name="key_dipDefault">Saída em nível alto</string>
    <string name="key_dipDefault_tt">Valor padrão de saída de um DIP switch quando a simulação iniciar.</string>

    <string name="key_macMouse">Usar clicks do mouse MacOS.</string>
    <string name="key_macMouse_tt">Usar CTRL-click em lugar de botão direito.</string>
    <string name="key_noComponentToolTips">Sem dicas de ferramentas para os componentes no painel principal.</string>
    <string name="key_noComponentToolTips_tt">Se definido, nenhuma dica sobre ferramentas para os componentes no painel principal será exibida.
        Especialmente no caso de apresentações, essas dicas de ferramentas poderão ser omitidas.</string>

    <string name="key_ATMISP">ATMISP</string>
    <string name="key_ATMISP_tt">Caminho para o arquivo executável ATMISP.exe. Se definido, o software ATMISP poderá ser ativado automaticamente!</string>

    <string name="key_customShape">Formato customizado</string>
    <string name="key_customShape_tt">Importar um arquivo SVG</string>

    <string name="key_preloadProgram">Memória de programa com carregamento prévio na inicialização.</string>
    <string name="key_preloadProgram_tt">Quando da simulação de um processador que use uma RAM como memória de programa,
        é difícil iniciá-lo pois o conteúdo da RAM geralmente começa com zeros ao iniciar-se a simulação.
        Essa configuração permitirá a carregar previamente dados na memória de programa.
        Para isso, a memória de programa na simulação deverá ser marcada para tal.
    </string>
    <string name="key_preloadProgramFile">Arquivo de programa</string>
    <string name="key_preloadProgramFile_tt">Arquivo que deverá ser carregado na memória de programa ao iniciar-se a simulação
        a simulação.
    </string>

    <string name="key_RectWidth">Largura</string>
    <string name="key_RectWidth_tt">Largura em unidades da grade</string>
    <string name="key_RectHeight">Altura</string>
    <string name="key_RectHeight_tt">Altura em unidades da grade</string>
    <string name="key_RectInside">Texto interno</string>
    <string name="key_RectInside_tt">Colocar texto interno ao retângulo.</string>
    <string name="key_RectBottom">Texto embaixo</string>
    <string name="key_RectBottom_tt">Colocar texto embaixo do retângulo.</string>
    <string name="key_RectRight">Texto à direita</string>
    <string name="key_RectRight_tt">Colocar texto à direita do retângulo.</string>    

    <string name="key_wideShape">Formato ampliado</string>
    <string name="key_wideShape_tt">Usará um formato ampliado para visualizar a porta.</string>

    <string name="key_shapeType">Formato</string>
    <string name="key_shapeType_tt">Formato a ser usado na representação de circuito integrado a outro.
        No modo "Simples", as entradas estarão mostradas à esquerda, e as saídas, à direita de um retângulo.
        Em "Layout", as posições de entradas e saídas, bem como suas orientações no circuito, definirão as
        posições dos pinos. Assim será possível ter pinos nas partes de cima e de baixo.
        Se selecionado "DIL-Chip", esse encapsulamento será usado para apresentar o circuito. Os números dos pinos das entradas e das saídas
        determinarão as posições dos pinos nesse caso.
    </string>
    <string name="key_shapeType_DEFAULT">Padrão</string>
    <string name="key_shapeType_SIMPLE">Simples</string>
    <string name="key_shapeType_DIL">DIL-Chip</string>
    <string name="key_shapeType_LAYOUT">Layout</string>
    <string name="key_shapeType_CUSTOM">Definido pelo usuário</string>

    <string name="key_textOrientation">Orientação</string>
    <string name="key_textOrientation_tt">Posição de coordenada relativa ao texto.</string>
    <string name="key_textOrientation_LEFTBOTTOM">embaixo à esquerda</string>
    <string name="key_textOrientation_CENTERBOTTOM">embaixo no centro</string>
    <string name="key_textOrientation_RIGHTBOTTOM">embaixo à direita</string>
    <string name="key_textOrientation_RIGHTCENTER">no centro à direita</string>
    <string name="key_textOrientation_RIGHTTOP">em cima à direita</string>
    <string name="key_textOrientation_CENTERTOP">em cima no centro</string>
    <string name="key_textOrientation_LEFTTOP">em cima à esquerda</string>
    <string name="key_textOrientation_LEFTCENTER">no centro à esquerda</string>
    <string name="key_textOrientation_CENTERCENTER">no centro</string>

    <string name="mod_insertWire">Fio inserido.</string>
    <string name="mod_insertCopied">Inserção a partir da área de transferência.</string>
    <string name="mod_setKey_N0_in_element_N1">Valor ''{0}'' no componente ''{1}'' modificado.</string>
    <string name="mod_setAttributesIn_N">Atributos do componente ''{0}'' modificado.</string>
    <string name="mod_wireDeleted">Fio removido.</string>
    <string name="mod_movedOrRotatedElement_N">Componente ''{0}'' movido ou rotacionado.</string>
    <string name="mod_movedWire">Fio movido.</string>
    <string name="mod_deletedSelection">Seleção removida.</string>
    <string name="mod_insertedElement_N">Componente ''{0}'' inserido.</string>
    <string name="mod_deletedElement_N">Componente ''{0}'' removido.</string>
    <string name="mod_insertedWire">Fio inserido.</string>
    <string name="mod_movedSelected">Seleção movida.</string>
    <string name="mod_undo_N">Desfazer: {0}</string>
    <string name="mod_redo_N">Refazer: {0}</string>
    <string name="mod_circuitAttrModified">Atributos de circuito modificados.</string>
    <string name="mod_modifiedMeasurementOrdering">Medidas ordenadas.</string>
    <string name="mod_set_N_BitsToSelection">Definição da largura em bitas em {0} nos componentes selecionados.</string>
    <string name="mod_groupEdit">Atributos modificados nos componentes selecionados.</string>
    <string name="mod_splitWire">Dividir um fio em dois outros.</string>

    <string name="lib_Logic">Lógica</string>
    <string name="lib_arithmetic">Aritmética</string>
    <string name="lib_flipFlops">Flip-Flops</string>
    <string name="lib_io">Entradas e saídas</string>
    <string name="lib_memory">Memória</string>
    <string name="lib_mux">Plexers</string>
    <string name="lib_wires">Conexões</string>
    <string name="lib_switching">Chaves</string>
    <string name="lib_misc">Diversos</string>
    <string name="lib_more">mais</string>
    <string name="lib_ram">RAM</string>
    <string name="lib_eeprom">EEPROM</string>

    <string name="menu_about">Sobre</string>
    <string name="menu_analyse">Análises</string>
    <string name="menu_analyse_tt">Analisar o circuito corrente</string>
    <string name="menu_cut">Cortar</string>
    <string name="menu_copy">Copiar</string>
    <string name="menu_custom">Personalizar</string>
    <string name="menu_library">Biblioteca</string>
    <string name="menu_delete">Remover componentes</string>
    <string name="menu_delete_tt">Remover componente individual selecionado ou grupo de componentes.</string>
    <string name="menu_edit">Editar</string>
    <string name="menu_editAttributes">Configurações específicas do circuito</string>
    <string name="menu_editAttributes_tt">Configurações específicas do circuito afetarão o comportamento do circuito corrente.
        Por exemplo, o formato que representará o circuito quando integrado em outro.
        Essas configurações serão armazenadas juntamente com o circuito.</string>
    <string name="menu_editSettings">Configurações</string>
    <string name="menu_editSettings_tt">As configurações globais do simulador especificação, dentre outras coisas,
        do idioma, a simbologia a ser usada ou os caminhos para as ferramentas externas.</string>
    <string name="menu_element">Parar a simulação</string>
    <string name="menu_element_tt">Parar a simulação e permitir a edição do circuito.</string>
    <string name="menu_elements">Componentes</string>
    <string name="menu_export">Exportar</string>
    <string name="menu_exportPNGLarge">Exportar PNG grande</string>
    <string name="menu_exportPNGSmall">Exportar PNG pequeno</string>
    <string name="menu_exportSVG">Exportar SVG</string>
    <string name="menu_exportSVGLaTex">Exportar SVG + LaTeX</string>
    <string name="menu_exportSVGLaTexInOut">Exportar SVG + LaTeX + entrada/saídas pequenas</string>
    <string name="menu_exportAnimatedGIF">Exportar GIF animado</string>
    <string name="menu_fast">Execução rápida</string>
    <string name="menu_fast_tt">Executará o circuito até que uma interrupção seja detectada por uso de um componente BRK.</string>
    <string name="menu_file">Arquivo</string>
    <string name="menu_help">Ajuda</string>
    <string name="menu_update">Atualizar</string>
    <string name="menu_update_tt">Atualizar os componentes do menu.</string>
    <string name="menu_maximize">Ajustar ao tamanho da janela</string>
    <string name="menu_micro">Execução passo-a-passo</string>
    <string name="menu_micro_tt">Executar o circuito passo-a-passo</string>
    <string name="menu_new">Novo</string>
    <string name="menu_new_tt">Criar um circuito novo, vazio.</string>
    <string name="menu_newSub">Novo circuito integrado</string>
    <string name="menu_newSub_tt">Abrirá uma nova janeta para ser criado um novo circuito integrado, que posteriormente poderá ser usado no circuito corrente.</string>
    <string name="menu_open">Abrir</string>
    <string name="menu_openRecent">Abrir recente</string>
    <string name="menu_openRecentNewWindow">Abrir recente em nova janela</string>
    <string name="menu_openWin">Abrir em nova janela</string>
    <string name="menu_openWin_tt">Abrir circuito em nova janela</string>
    <string name="menu_orderInputs">Ordenar entradas</string>
    <string name="menu_orderInputs_tt">Ordenar as entradas para circuito integrado</string>
    <string name="menu_orderMeasurements">Ordenar valores medidos</string>
    <string name="menu_orderMeasurements_tt">Ordenar os valores medidos em gráficos e tabelas</string>
    <string name="menu_orderOutputs">Ordenar saídas</string>
    <string name="menu_orderOutputs_tt">Ordenas as saídas para circuito integrado.</string>
    <string name="menu_paste">Colar</string>
    <string name="menu_insertAsNew">Colar em nova janela</string>
    <string name="menu_insertAsNew_tt">O conteúdo da área de transferência será colado na nova janela.</string>
    <string name="menu_rotate">Rotacionar</string>
    <string name="menu_sim">Simulação</string>
    <string name="menu_run">Iniciar a simulação</string>
    <string name="menu_run_tt">Iniciar a simulação do circuito.</string>
    <string name="menu_save">Salvar</string>
    <string name="menu_saveAs">Salvar como</string>
    <string name="menu_saveData">Salvar dados</string>
    <string name="menu_saveData_tt">Salvar dados em arquivo CSV</string>
    <string name="menu_speedTest">Teste de velocidade</string>
    <string name="menu_speedTest_tt">Calcular a máxima frequência de clock.</string>
    <string name="menu_step">Passo</string>
    <string name="menu_step_tt">Calcular um avanço em porta simples</string>
    <string name="menu_synthesise">Sintetizar</string>
    <string name="menu_synthesise_tt">Gerar expressões booleanas mínimas dada a tabela-verdade.</string>
    <string name="menu_table_N_variables">{0} variáveis</string>
    <string name="menu_table_create">Criar</string>
    <string name="menu_table_createCUPL_tt">Criar um arquivo fonte CUPL contendo a definição do circuito.</string>
    <string name="menu_table_createTT2_tt">Criar o arquivo contendo descrição segundo o formato Berkeley Logic Interchange Format (BLIF).
        Dessa forma o filtro Atmel será iniciado para criar o arquivo JEDEC. </string>
    <string name="menu_table_createCircuit">Circuito</string>
    <string name="menu_table_createCircuit_tt">Criar um circuito capaz de reproduzir a tabela-verdade.</string>
    <string name="menu_table_createCircuitJK">Circuito com flip-flops JK</string>
    <string name="menu_table_createCircuitJK_tt">Criar um circuito capaz de reproduzir a tabela-verdade. Usar flip-flops JK.</string>

    <string name="menu_table_createCircuitLUT">Circuito com LUTs</string>
    <string name="menu_table_createCircuitLUT_tt">Criar um circuito que reproduzirá uma tabela-verdade. Usará LUTs (LookUp Tables) para criar as expressões.</string>
 
    <string name="menu_table_createNAnd">Circuito com portas NAND</string>
    <string name="menu_table_createNAndTwo">Circuito com portas NAND com duas entradas</string>
    <string name="menu_table_createNAndTwo_tt">Usar apenas portas NAND com duas entradas.</string>
    <string name="menu_table_createNAnd_tt">Criar um circuito capaz de reproduzir a tabela-verdade com apenas portas NAND.</string>
    <string name="menu_table_createNOr">Circuito com portas NOR</string>
    <string name="menu_table_createNOrTwo">Circuito com portas NOR com duas entradas</string>
    <string name="menu_table_createNOrTwo_tt">Usar somente portas NOR com duas entradas.</string>
    <string name="menu_table_createNOr_tt">Criar um circuito capaz de reproduzir a tabela-verdade com apenas portas NOR.</string>
    <string name="menu_table_createTwo">Circuito com portas de duas entradas</string>
    <string name="menu_table_createTwo_tt">criar circuito, usar apenas portas com duas entradas</string>
    <string name="menu_table_createThree">Circuito com três entradas</string>
    <string name="menu_table_createThree_tt">criar circuito, usar portas com no máximo três entradas</string>
    <string name="menu_table_create_hardware">Dispositivo</string>
    <string name="menu_table_create_jedec_tt">Criar arquivo JEDEC para o dispositivo</string>
    <string name="menu_table_exportTableLaTeX">Exportar LaTeX</string>
    <string name="menu_table_exportHex">Exportar HEX</string>
    <string name="menu_table_exportHex_tt">É possível carregar um arquivo HEX em uma ROM ou em uma LUT.</string>
    <string name="menu_table_new">Novo</string>
    <string name="menu_table_new_combinatorial">Combinacional</string>
    <string name="menu_table_new_sequential">Sequencial</string>
    <string name="menu_table_new_sequential_bidir">Sequencial bidirecional</string>
    <string name="menu_table_columns">Colunas</string>
    <string name="menu_table_reorder_inputs">Reordenar/remover variáveis de entrada</string>
    <string name="menu_table_columnsAddVariable">Adicionar variável de entrada</string>
    <string name="menu_table_columnsAddVariable_tt">Adicionar uma nova variável de entrada à tabela.</string>
    <string name="menu_table_reorder_outputs">Reordenar/remover colunas de saída</string>
    <string name="menu_table_columnsAdd">Adicionar coluna de saída</string>
    <string name="menu_table_columnsAdd_tt">Adicionar uma nova coluna de resultado à tabela.</string>
    <string name="menu_table_set">Definir</string>
    <string name="menu_table_setXTo0">Definir X como 0</string>
    <string name="menu_table_setXTo0_tt">Definir "don't cares" como 0.</string>
    <string name="menu_table_setXTo1">Definir X como 1</string>
    <string name="menu_table_setXTo1_tt">Definir "don't cares" como 1.</string>
    <string name="menu_table_JK">Criar expressões com J/K</string>
    <string name="menu_table_setAllToX">Definir todos os valores como X</string>
    <string name="menu_table_setAllToX_tt">Definir todos os valores como "don't care".</string>
    <string name="menu_table_setAllTo0">Definir todos os valores como 0</string>
    <string name="menu_table_setAllTo0_tt">Definir todos os valores como zero.</string>
    <string name="menu_table_setAllTo1">Definir todos os valores como 1</string>
    <string name="menu_table_setAllTo1_tt">Definir todos os valores como um.</string>
    <string name="menu_terminalDelete">Apagar</string>
    <string name="menu_terminalDelete_tt">Apagar o conteúdo do terminal.</string>
    <string name="menu_view">Visualizar</string>
    <string name="menu_zoomIn">Zoom In</string>
    <string name="menu_zoomOut">Zoom Out</string>
    <string name="menu_expression">Expressão</string>
    <string name="menu_expression_tt">Criar circuito dada a expressão.</string>
    <string name="menu_runTests">Executar testes</string>
    <string name="menu_runTests_tt">Executar todos os casos de testes</string>
    <string name="menu_actualToDefault">Definir entradas</string>
    <string name="menu_actualToDefault_tt">Usar os valores atuais das entradas como padrão.</string>
    <string name="menu_restoreAllFuses">Reiniciar diodos e FGFETs</string>
    <string name="menu_restoreAllFuses_tt">Reiniciar todos os diodos (fusíveis) e FGFETs como "não programados". A configuração vigente dos fusíveis será descartada!</string>
    <string name="menu_programDiode">Programar diodo</string>
    <string name="menu_help_elements">Componentes</string>
    <string name="menu_help_elements_tt">Mostrar a lista de todos os componentes disponíveis.</string>
    <string name="menu_viewHelp">Caixa de diálogo para ajuda</string>
    <string name="menu_viewHelp_tt">Mostrar a caixa de diálogo para ajuda com a descrição do circuito corrente.</string>
    <string name="menu_probe_memory">Memória</string>
    <string name="menu_probe_memory_tt">Mostrar os conteúdos dos componentes de memória.</string>
    <string name="menu_treeSelect">Hierarquia de componentes</string>
    <string name="menu_treeSelect_tt">Mostrar a hierarquia de componentes à esquerda.</string>
    <string name="menu_karnaughMap">K-Map</string>
    <string name="menu_karnaughMap_tt">Mostrar a representação K-Map da tabela!</string>

    <string name="menu_special">Funções 74xx especiais</string>
    <string name="menu_addPrefix">Adicionar prefixo para entrada e saída</string>
    <string name="menu_addPrefix_tt">Um prefixo será adicionado a todas as entradas e saídas selecionadas.
        Isso será usado para simplificar a duplicação de circuitos dentro dos 74xx.</string>
    <string name="menu_removePrefix">Remover prefixo para entrada e sáida</string>
    <string name="menu_removePrefix_tt">O primeiro caractere dos rótulos das entradas e saídas será removido.
        Isso será usado para simplificar a duplicação de circuitos dentro dos 74xx.</string>
    <string name="menu_numbering">Assistente para pino</string>
    <string name="menu_numbering_tt">Assistente para aplicar números de pinos às entradas e às saídas.</string>
    <string name="menu_removePinNumbers">Remover números de pinos</string>
    <string name="menu_removePinNumbers_tt">Removerá todos os números de pinos em um circuito</string>
    <string name="msg_pin_numbering_N">Selecionar pino {0}:</string>

    <string name="menu_undo">Desfazer</string>
    <string name="menu_undo_tt">Reverter a última modificação</string>
    <string name="menu_redo">Refazer</string>
    <string name="menu_redo_tt">Aplicar a última modificação revertida de novo.</string>
    <string name="menu_showDataAsGraph">Mostrar gráfico</string>
    <string name="menu_showDataAsGraph_tt">Mostrar os dados em forma gráfica.</string>
    <string name="menu_showDataAsTable">Mostrar tabela</string>
    <string name="menu_showDataAsTable_tt">Mostrar valores com uma tabela.</string>
    <string name="menu_addPowerSupply">Adicionar fonte de alimentação</string>
    <string name="menu_addPowerSupply_tt">Adicionar uma fonte de potência para o circuito.</string>
    <string name="menu_exportVHDL">Exportar para VHDL</string>
    <string name="menu_exportVHDL_tt">Exportar o circuito para VHDL</string>
    <string name="menu_exportVerilog">Exportar para Verilog</string>
    <string name="menu_exportVerilog_tt">Exportar o circuito para Verilog</string>
    <string name="menu_pdfDocumentation">Documentação</string>
    <string name="menu_openPdfDocumentation">Abrir {0}</string>
    <string name="msg_errorOpeningDocumentation">Erro ao abrir arquivo PDF!</string>

    <string name="menu_showDataGraph">Mostrar o gráfico de medições</string>
    <string name="menu_showDataGraph_tt">Mostrar o gráfico com os valores medidos em janela separada.</string>
    <string name="menu_showDataTable">Mostrar tabela com valores medidos</string>
    <string name="menu_showDataTable_tt">Mostrar tabela com valores medidos em janela separada.</string>
    <string name="menu_exportZIP">Exportar para arquivo ZIP</string>
    <string name="menu_exportZIP_tt">Exportar o circuito para um arquivo ZIP.
        O arquivo ZIP conterá todos os arquivos que forem necessários para a operação do circuito.</string>
    <string name="menu_labelPins">Rotular entradas e saídas</string>
    <string name="menu_labelPins_tt">Definir rótulo para entradas e saídas que não tiverem algum.</string>


    <string name="message">&lt;h1&gt;Digital&lt;/h1&gt;Um simulator simples para circuitos digitais.
        Elaborado por H. Neemann em 2016-2018.

        Os ícones foram tomados de &lt;a href=&quot;http://tango.freedesktop.org&quot;&gt;Tango Desktop Project&lt;/a&gt;.

        Para conhecer melhor o projeto, visitar &lt;a href=&quot;https://github.com/hneemann/[[name]]&quot;&gt;GitHub&lt;/a&gt;.
        Última versão disponível em &lt;a href=&quot;https://github.com/hneemann/[[name]]/releases/latest&quot;&gt;download&lt;/a&gt;.

        Questões poderão ser endereçadas para &lt;a href=&quot;https://github.com/hneemann/[[name]]/issues/new?body=version:%20[[version]]&amp;labels=bug&quot;&gt;issue&lt;/a&gt; ou sugestões
        para &lt;a href=&quot;https://github.com/hneemann/[[name]]/issues/new?labels=enhancement&quot;&gt;enhancement&lt;/a&gt;.
    </string>
    <string name="msg_N_nodes">{0} nodos</string>
    <string name="msg_analyseErr">Erro ao analisar o circuito</string>
    <string name="msg_clockError">Erro durante a mudança de estado do clock</string>
    <string name="msg_color">Cor</string>
    <string name="msg_errorCalculatingStep">Erro ao calcular um passo</string>
    <string name="msg_errorCreatingModel">Erro ao criar o circuito</string>
    <string name="msg_errorDuringCalculation">Erro durante a simplificação</string>
    <string name="msg_errorDuringHardwareExport">Erro durante a criação da configuração de hardware.</string>
    <string name="msg_errorEditingValue">Erro ao editar um valor de atributo</string>
    <string name="msg_errorImportingModel_N0">Erro ao importar o circuito {0}!</string>
    <string name="msg_errorUpdatingLibrary">Erro ao atualizar a biblioteca de componentes!!</string>
    <string name="msg_errorReadingFile">Erro ao ler arquivo</string>
    <string name="msg_errorWritingFile">Erro ao escrever arquivo</string>
    <string name="msg_fastRunError">Erro durante execução rápida</string>
    <string name="msg_frequency_N">A frequência máxima é de {0} kHz</string>
    <string name="msg_missingShape_N">Formato {0} não encontrado</string>
    <string name="msg_pins">Atribuição de pino</string>
    <string name="msg_pinMap_pin_N_is_N">Pino {0}: {1}</string>
    <string name="msg_restartNeeded">Reinicialização é necessária para que as mudanças possam ter efeito!</string>
    <string name="msg_remoteUnknownCommand">Comando {0} desconhecido!</string>
    <string name="msg_enterAnExpression">Entrar com uma expressão:</string>
    <string name="msg_runningTestError">Erro ao executar os testes:</string>
    <string name="msg_testResult">Resultado de teste</string>
    <string name="msg_test_N_Passed">{0} com êxito</string>
    <string name="msg_test_N_Failed">{0} com falha</string>
    <string name="msg_testExp_N0_found_N1">E: {0} / F: {1}</string>
    <string name="msg_creatingHelp">Erro ao criar a ajuda!</string>
    <string name="msg_clipboardContainsNoImportableData">A área de transferência não contém dados para importar!</string>
    <string name="msg_selectAnEmptyFolder">Selecionado arquivo vazio!</string>
    <string name="msg_fitterResult">Mensagem de filtro externo</string>
    <string name="msg_startExternalFitter">Execução de filtro externo</string>
    <string name="msg_actualCircuit">Circuito corrente</string>
    <string name="msg_fileNotAccessible">O nome de arquivo selecionado não pode ser importado para o projeto corrente!</string>
    <string name="msg_fileIsNotUnique">O nome de arquivo não é único!
        Todos os arquivos na pasta de trabalho e em todas as subpastas deverão ter nomes únicos. Isso também se aplicará
        à pasta com a biblioteca. Se a pasta de trabalho contiver um arquivo 7400.dig, esse não poderá ser usado or ou buscado em
        biblioteca.
        Se houver um arquivo 7400.dig na pasta de trabalho, não poderá ser usado ou buscado em biblioteca,
        porque esse nome de arquivo não poderá mais ser usado.
    </string>
    <string name="msg_duplicateLibraryFiles">Há vários arquivos com nomes idênticos, os quais não poderão ser usados 
        de forma exclusiva! Nessa condição estão:</string>
    <string name="msg_and_N_More">e {0} mais.</string>
    <string name="msg_fileNotImportedYet">O arquivo ainda não foi importado.</string>
    <string name="msg_fileExists">O arquivo {0} já existe! Sobrescrever?</string>
    <string name="msg_test_missingLines">(Entradas demais!)</string>
    <string name="msg_test_missingLines_tt">Todos os testes foram executados, mas nem todos os resultados mostrados.
        A avaliação dos resultados de testes, no entando, é considerada correta!</string>
    <string name="msg_isLocked">A edição do circuito está suspensa. O bloqueio poderá ser removido em 
        "{0} -> {1} -> {2}".
        Entretanto, copiar componentes e a configuração de diodos e FG-FETs será possível pelo uso da tecla [P] mesmo durante o bloqueio.</string>
    <string name="msg_speedTestError">Erro durante o teste de velocidade!</string>
    <string name="msg_pin_N">Pino {0}</string>
    <string name="msg_numberingWizard">Assistente para a numeração</string>
    <string name="msg_framesWritten_N">Quadros escritos: {0}</string>
    <string name="msg_errorWritingGif">Erro ao gravar o arquivo GIF!</string>
    <string name="btn_gifComplete">Pronto</string>
    <string name="btn_gifComplete_tt">O arquivo GIF está completo e fechado.</string>
    <string name="msg_gifExport">Exportar GIF</string>
    <string name="msg_errCausedBy">causado por</string>
    <string name="msg_inputsToInvert">entradas a inverter</string>
    <string name="msg_none">nenhum</string>
    <string name="msg_errGettingPinNames">Não foi possível determinar os nomes dos pinos.</string>
    <string name="msg_errInFile_N">Ocorrido no arquivo {0}.</string>
    <string name="msg_affectedComponentsAre_N">Afetados estão: {0}.</string>
    <string name="msg_signal_N">Sinal {0}</string>
    <string name="msg_invalidSignalsAnalysed">Para executar a análise do circuito, todas as entradas e saídas
        deverão ser únicos!</string>
    <string name="msg_thereAreMissingPinNumbers">Não há números PIN atribuídos aos pinos {0}!
        Pinos livres receberão atribuição automática. O circuito não poderá, portanto, ser usado em um hardware real na maioria dos casos!</string>
    <string name="msg_modelHasErrors">Somente será possível exportar um circuito sem erros!</string>
    <string name="msg_noKVMapAvailable">Nenhum  K- Map disponível!</string>
    <string name="msg_dataNotUpdatedAnymore">Dados não serão mais atualizados!</string>
    <string name="msg_modifyThisAttribute">Modificar esse valor</string>
    <string name="msg_invalidEditorValue">Um dos campos contém valor inválido!</string>
    <string name="msg_create CHNFile">Criação de arquivo CHN.</string>
    <string name="msg_tableHasManyRowsConfirm">O tamanho da tabela exigirá um tempo bem maior para sua exportação.
        Iniciar a exportação assim mesmo?</string>
    <string name="msg_circuitIsRequired">Para criar a descrição de hardware, um circuito deverá ser criado e analisado.
        Uma tabela-verdade sozinha não poderá ser usada para gerar uma descrição de hardware.</string>
    <string name="win_romDialog">ROM's incluídas</string>
    <string name="msg_noData">não há dados</string>

    <string name="msg_errorClosingExternalProcess">Não foi possível fechar o processo externo!</string>

    <string name="msg_checkResult">Verificar resultado:</string>
    <string name="btn_checkCode">Verificar</string>
    <string name="btn_checkCode_tt">Iniciar a aplicação para verificar se um código fornecido está correto.
        Se esse não for o caso, a mensagem de erro para aplicação externa será apresentada.
        Se possível, as definições de entradas e saídas também serão adaptadas a paritr desse código.</string>
    <string name="msg_applicationFileNotFound">Arquivo executável "{0}" não encontrado!</string>
    <string name="msg_enterText">Entrar texto!</string>

    <string name="btn_startATMISP">Iniciar ATMISP</string>
    <string name="btn_startATMISP_tt">Iniciar o programa externo ATMISP. Esse deverá estar previamente instalado.</string>
    <string name="msg_errorStartingATMISP">Erro ao iniciar ATMISP!
        O caminho para o arquivo executável ATMISP.exe especificado nas configurações está correto?</string>
    <string name="msg_ATMISPIsStillRunning">ATMISP já está em execução!
        Após o fechamento desse diálogo, o ATMISP será encerrado!
        Certificar-se que o processo esteja completo antes de fechar esse diálogo!</string>

    <string name="menu_runAllTests">Executar todos os testes</string>
    <string name="menu_runAllTests_tt">Executar todos os testes na pasta corrente.</string>
    <string name="msg_testPassed_N">{0} linhas de testes aprovadas</string>
    <string name="msg_testFile">Arquivo testado</string>
    <string name="msg_truthTable">Tabela-verdade</string>
    <string name="msg_errorImportingSvg">Erro ao importar o arquivo SVG.</string>
    <string name="msg_errorCreatingSvgTemplate">Erro ao criar o modelo SVG.</string>

    <string name="ok">OK</string>
    <string name="rot_0">0°</string>
    <string name="rot_180">180°</string>
    <string name="rot_270">270°</string>
    <string name="rot_90">90°</string>
    <string name="stat_clocks">{0} meio ciclos</string>
    <string name="tt_deleteItem">Remover o item selecionado</string>
    <string name="tt_moveItemDown">Mover o item para baixo</string>
    <string name="tt_moveItemUp">Mover o item para cima</string>
    <string name="win_allSolutions">Todas as soluções possíveis</string>
    <string name="win_confirmExit">Confirmar a saída!</string>
    <string name="win_measures">Medidas</string>
    <string name="win_measures_fullstep">Medidas na maior velocidade</string>
    <string name="win_measures_microstep">Medidas no modo passo-a-passo</string>
    <string name="win_saveChanges">Salvar alterações?</string>
    <string name="win_stateChanged">Estado alterado!</string>
    <string name="win_table">Tabela</string>
    <string name="win_table_exportDialog">Exportar</string>
    <string name="win_itempicker_title">Selecionar</string>
    <string name="win_testdata_N">Dados de teste {0}</string>
    <string name="win_data">Dados</string>
    <string name="win_valueInputTitle_N">Entrada {0}</string>
    <string name="win_karnaughMap">Mapa de Karnaugh</string>

    <string name="btn_help">Ajuda</string>

    <string name="win_romDialogHelpTitle">Conteúdo de ROM Central</string>
    <string name="msg_romDialogHelp"><![CDATA[
        <html>
        <h3>Motivação</h3>
        Quando um circuito contendo uma é incorporado múltiplas vezes, os conteúdos da ROM
        serão normalmente utilizados em cada instância desse circuito. Sob certas circunstâncias,
        no entanto, poderá ser desejável que tal circuito possa ser incorporado várias vezes,
        mas com diferentes conteúdos em ROM para cada instância.<br/>
        Esse problema ocorre, por exemplo, se uma ROM 74xx for usada várias vezes, mas com diferentes
        conteúdos de memória.<br/>
        <h3>Função</h3>
        Nesse local, portanto, os conteúdos poderão ser definidos para todas as ROM's no circuito.
        Quando o modelo de simulação for gerado, cada ROM será inicializada com os conteúdos armazenados
        diretamente na respectiva ROM. Em seguida será verificado se há um conteúdo alternativo 
        definido aqui. Se esse for o caso, o conteúdo definido aqui será carregado na respectiva ROM.
        <h3>Uso</h3>
        Deve-se notar que cada ROM irá requerer um nome único usado como identificação.
        Para isso, usar o asterico ('*') no rótulo da ROM. O asterisco será então substituído pelo caminho completo
        constituído pelos nomes dos circuitos integrados.
        Se um circuito contiver apenas uma única ROM, isso será suficiente para se usar o asterisco como rótulo.
        Todos os circuitos integrados deverão term nomes únicos para cada ROM.
        </html>
        ]]>
    </string>

    <string name="msg_newRelease_N"><![CDATA[
        <html>
        <h1>Nova versão {0} disponível</h1>
        <p>Há uma nova versão do simulador disponível.</p>
        <p>Em <a href="https://github.com/hneemann/[[name]]/releases/latest">Release Notes</a>
        poderão ser encontradas as alterações e melhorias.</p>
        <p>Em <a href="https://github.com/hneemann/[[name]]/releases/latest">download</a> se poderá encontrar a nova versão.</p>
        </html>
    ]]></string>

    <string name="msg_expressionHelpTitle">Expressões</string>
    <string name="msg_expressionHelp">Para definir uma expressão poderão ser usadas todas as notações mais comuns:

        And: &quot;&amp;&quot;, &quot;&amp;&amp;&quot;, &quot;*&quot;, &quot;∧&quot;
        Or: &quot;|&quot;, &quot;||&quot;, &quot;+&quot;, &quot;∨&quot;, &quot;#&quot;
        XOr: &quot;^&quot;, &quot;⊻&quot;
        Not: &quot;!&quot;, &quot;~&quot;, &quot;&#172;&quot;

        Como usual AND tem precedência sobre OR e XOR.

        Múltiplas expressões poderão ser separadas por "," ou ";".
        Se desejado dar nome às expressões se poderá usar o comando "let"
        "let U=A+B, let V=A*B"</string>
    <string name="msg_testVectorHelpTitle">Arranjos de teste</string>
    <string name="msg_testVectorHelp"><![CDATA[<html>
    <head><style>pre { background-color: #E0E0E0;}</style></head>
    <body>
<p>A primeira linha deverá conter os nomes das entradas e das saídas.
As linhas seguintes deverão conter os valores esperados.
Um 'X' representará um "don't care", e um 'Z' representará um valor em alta impedância.
Se um 'C' for usado,  inicialmente, todos os outros valores serão definidos, e após um ciclo de clock 
seus valores serão comparados. Dessa forma será mais fácil testar lógica sequencial.
Um linha que for iniciada por um sinal ('#') será um comentário.</p>

<p>Dessa forma um teste para um contador de 2-bits poderia se parecer com isso:</p>

<pre>
C Q1 Q0
0 0  0
C 0  1
C 1  0
C 1  1
C 0  0
</pre>

<p>The tests are executed by Run->Testes de execução.</p>
<p>
Para tornar mais fácil a criação de muitos arranjos de testes, há o comando 'repeat([n])':
Se um linha começar por 'repeat([n])', [n] linhas de testes serão geradas.
A variável 'n' poderá ser usada para gerar os dados de testes. Por exemplo, 'repeat(16)'
16 linhas serão criadas, onde n variar de 0 até 15. Se houver entradas com múltiplos bits,
e esses forem definidos juntos por um valor binário, isso poderá ser feito usando o comando
'bits([bits], [valor])'. Isso poderá ser usado para criar [bits] com esse [valor].</p>

<p>A seguir há um exemplo para testar um somador de 4-bits:</p>

<pre>
           C_i-1  A_3 A_2 A_1 A_0  B_3 B_2 B_1 B_0  C_i S_3 S_2 S_1 S_0
repeat(256)  0    bits(4,n>>4)     bits(4,n)        bits(5,(n>>4)+(n&15))
repeat(256)  1    bits(4,n>>4)     bits(4,n)        bits(5,(n>>4)+(n&15)+1)
</pre>

<p>Os sinais de entrada serão o carry-in (C_i-1) e os oito bits de entrada A_3-A_0 e B_3-B_0.
Os 4 bits de entrada serão gerados pela instrução 'bits'. O resultado (C_i, S_3-S_0) também será gerado
pela mesma instrução.
Isso irá ocorrer um vez com C_i-1 = 0 e na próxima linha com C_i-1 = 1.
Dessa forma, 512 linhas de testes serão gerados para cobrir todas as configurações possíveis das entradas.</p>
<p>Se múltiplas linhas forem repetidas, ou se repetições aninhadas forem requeridas, o comando de repetição
poderá ser usado. O exemplo acima poderia ser implementado como mostrado a seguir:</p>

<pre>
           C_i-1  A_3 A_2 A_1 A_0  B_3 B_2 B_1 B_0  C_i S_3 S_2 S_1 S_0
loop(a,16)
  loop(b,16)
             0    bits(4,a)        bits(4,b)        bits(5,a+b)
             1    bits(4,a)        bits(4,b)        bits(5,a+b+1)
  end loop
end loop
</pre>

<p>Poderia ser útil para gerar valores aleatórios para casos de testes.
Isso poderá ser criado pela função 'random([n])'. O valor gerado será maior ou igual a
zero e menor que [n]. Considerando um multiplicador de 16-bits como exemplo,
um teste completo não poderá ser executado pois deveria ter 2^32 combinações das entradas.
Um teste de regressão para multiplicar 100000 valores aleatórios poderia se parecer como isso:</p>

<pre>
   A    B      Y
loop(i,100000)
  let a = random(1&lt;&lt;16);
  let b = random(1&lt;&lt;16);
  (a)  (b)   (a*b)
end loop
</pre>

<p>Uma entrada que permita um valor em alta impedância também poderá ser usada como valor de saída de teste.
Nesse caso, o nome do sinal poderá ser usado com o sufixo "_out" para ser lido de volta e ter o valor comparado.
Para isso, a entrada correspondente deverá ser definida como de alta impedância ('Z').</p>

<pre>OE CLK D D_out
0   0  0 0
0   C  1 1
1   0  z 1
0   C  0 0
1   0  z 0
</pre>

<p>O circuito para esse teste deverá ter apenas uma entrada 'D', a qual poderá estar em estado de alta impedância.
Portanto, o sinal 'D_out' também será avaliado para se verificar o valor desse caso.</p>

</body></html>]]></string>

    <string name="fsm_title">Máquina de Estados Finitos (FSM)</string>
    <string name="fsm_noMove">Nenhuma transição</string>
    <string name="fsm_moveTrans">Transições</string>
    <string name="fsm_moveStates">Transições+Estados</string>
    <string name="fsm_set_N">definido {0}</string>
    <string name="menu_fsm">Máquina de Estados Finitos (FSM)</string>
    <string name="menu_fsm_tt">Abrir uma caixa de diálogo para editar a Máquina de Estados Finitos (FSM).</string>
    <string name="menu_fsm_create">Criar</string>
    <string name="menu_fsm_create_table">Tabela de transições de estado</string>
    <string name="menu_fsm_create_counter">Criar contador</string>
    <string name="menu_fsm_create_counter_N">{0} estados</string>
    <string name="menu_fsm_Help_tt">Ajuda para operar o editor FSM.</string>
    <string name="err_notDeterministic_N">A FSM não é determinística: {0}</string>
    <string name="err_fsmNumberUsedTwice_N">Estado número {0} usada duas vezes.</string>
    <string name="err_fsmNoInitialState">Não há estado inicial (estado inicial zero).</string>
    <string name="err_fsmState_N_notFound">Estado ''{0}'' não encontrado!</string>
    <string name="err_fsmInvalidOutputAssignment_N">Atribuição errada para a saída (''{0}'')!</string>
    <string name="err_fsmErrorInCondition_N">Erro na condição ''{0}''!</string>
    <string name="key_stateNum">Número do Estado</string>
    <string name="key_stateNum_tt">O número que representa esse estado.</string>
    
    <string name="key_isInitialState">Estado inicial</string>
    <string name="key_isInitialState_tt">Se definido, esse será o estado inicial.</string>

    <string name="key_stateValues">Saídas</string>
    <string name="key_stateValues_tt">Definirá os valores de saídas.
        Com atribuições simples como "A=1, B=0" as saídas poderão ser definidas.
        Com instruções como "A=101", saídas com múltiplos bits poderão ser definidas.
        Saídas que não forem definidas aqui  terão valor igual a zero nos estados.
        Para transições, saídas não especificas permanecerão inalteradas.</string>
    <string name="key_transCond">Condição</string>
    <string name="key_transCond_tt">Uma expressão booleana.</string>
    <string name="key_transRad">Raio</string>
    <string name="key_transRad_tt">Raio do círculo.</string>
    <string name="msg_fsmCantCreateTable">Não é possível criar a tabela de transições de estado.</string>
    <string name="msg_fsmNewState">Novo estado</string>
    <string name="msg_fsm_errorLoadingFile">Erro ao carregar um arquivo!</string>
    <string name="msg_fsm_errorStoringFile">Erro ao armazenar em um arquivo!</string>
    <string name="msg_fsmHelpTitle">Ajuda do editor de FSM</string>
    <string name="msg_fsmHelp"><![CDATA[
<html><head></head>
<body>
  <h3>Operação do mouse</h3>
  <dl>
    <dt>Criar um estado:</dt>
    <dd>Clicar o botão direito do mouse em área livre.</dd>
    <dt>Criar uma transição:</dt>
    <dd>Pressionar o botão direito do mouse no estado de origem e arrastar até o estado de destino.</dd>
    <dt>Remover um estado ou uma transição:</dt>
    <dd>Mover o mouse sobre o objeto e pressionar o botão [Del].</dd>
    <dt>Mover um estado ou uma transição:</dt>
    <dd>Pressionar o botão esquerdo do mouse e arrastar.</dd>
    <dt>Editar um estado ou uma transição:</dt>
    <dd>Clicar o botão direito do mouse sobre o estado ou a transição.</dd>
  </dl>
  <h3>Função de ajuda para layout</h3>
  <dl>
    <dt>nenhum movimento:</dt>
    <dd>A função de ajuda para layout desabilitada.</dd>
    <dt>Transições:</dt>
    <dd>A função de ajuda para layout moverá as setas da transição para evitar sobreposições.</dd>
    <dt>Transições+Estados</dt>
    <dd>A função de ajuda para layout moverá ambos, estados e transitções, para ajudar a criar um layout bem equilibrado.</dd>
  </dl>
  <h3>Interpretação das transições</h3>
  Para simplificar a geração de um autômato determinístico, transições incondicionais serão tratadas de forma especial:
  uma transição incondicional somente será executada se nenhuma outra satisfizer a condição de transição.
  Portanto, não poderá haver uma transição incondicional e transições condicionais que comecem no mesmo estado.
  Uma transição incondicional determinará para qual estado a máquina de estado se deslocará, se nenhuma outra transição
  condição puder ser atendida.
  Se não houver nenhuma transição incondicional a partir de um estado, a máquina permanecerá nesse estado se nenhuma outra
  condição de transição puder ser atendida.
</body></html>]]></string>

</resources>