<?xml version="1.0" encoding="UTF-8"?>
<!--  IMPORTANT
Do not edit this file directly!
This makes it very difficult for me to continue to maintain the translation.
The only exception are simple typos.
Pull requests in which this file is modified beyond simple typos cannot be accepted.
In the file howTo.md you can find more details about translations.
--><resources>
    <string name="addr">Dirección</string>
    <string name="tableOfContent">Índice</string>
    <string name="general">General</string>
    <string name="revision">Revisión</string>
    <string name="date">Fecha</string>
    <string name="settings">Esto describe los ajustes del simulador disponibles</string>
    <string name="maxValue">máximo</string>
    <string name="attr_dialogTitle">Propiedades</string>
    <string name="attr_openCircuit">Abrir circuito</string>
    <string name="attr_openCircuitLabel">Incluir circuito:</string>
    <string name="attr_openCircuit_tt">Abre el circuito en una ventana nueva</string>
    <string name="attr_help">Ayuda</string>
    <string name="attr_help_tt">Muestra una pequeña descripción de este elemento</string>
    <string name="attr_panel_primary">Básico</string>
    <string name="attr_panel_secondary">Avanzado</string>
    <string name="btn_discard">Descartar cambios</string>
    <string name="btn_edit">Editar</string>
    <string name="btn_editFurther">Seguir editando</string>
    <string name="btn_load">Cargar</string>
    <string name="btn_save">Guardar</string>
    <string name="btn_create">Crear</string>
    <string name="btn_create_tt">Crear un circuito en otra ventana</string>
    <string name="btn_editDetached">Editar por separado</string>
    <string name="btn_editDetached_tt">Abre el diálogo como no modal</string>
    <string name="btn_openInBrowser">Navegador</string>
    <string name="btn_openInBrowser_tt">Abre texto de ayuda en el navegador. Permite imprimir el texto.</string>
    <string name="btn_clearData">Borrar</string>
    <string name="btn_clearData_tt">Todos los valores se ponen a cero</string>
    <string name="btn_addTransitions">Transiciones</string>
    <string name="btn_addTransitions_tt">Se añaden todas las transiciones posibles. Se usa para crear casos para probar
        el simulador
    </string>
    <string name="btn_newName">Nuevo nombre</string>
    <string name="btn_saveAnyway">Guardar de todos modos</string>
  <string name="btn_overwrite">Sobreescribir</string>
  <string name="btn_apply">Aplicar</string>
  <string name="btn_editRom_tt">Editar el contenido de la ROM/EEPROM seleccionada</string>
  <string name="btn_clearRom_tt">Borra los datos almacenados en la ROM seleccionada. El contenido almacenado en la ROM se usa en su lugar</string>
  <string name="btn_saveTemplate">Plantilla</string>
  <string name="btn_saveTemplate_tt">Crea una plantilla SVG que puede editarse con Inkscape</string>
  <string name="btn_loadSvg">Importar</string>
  <string name="btn_loadSvg_tt">Importar un archivo SVG. Para crear un SVG adecuado, es mejor primero crear
		una plantilla SVG y luego editarla</string>
  <string name="msg_warning">Aviso</string>
  <string name="cancel">Cancelar</string>
  <string name="digital">Digital</string>
  <string name="expression">Expresión</string>
  <string name="elem_Help_inputs">Entradas</string>
  <string name="elem_Help_outputs">Salidas</string>
  <string name="elem_Help_attributes">Propiedades</string>
  <string name="elem_Basic_In">{0}: valor de entrada para la operación lógica</string>
  <string name="elem_Basic_Out">Devuelve el resultado de la operación lógica</string>
  <string name="elem_And">AND</string>
  <string name="elem_And_tt">Puerta AND. Devuelve un 1 sólo si todas las entradas son 1.
		Es también posible usar buses con varios bits como entradas y salidas. En tal caso, la AND se ejecuta bit a bit.
		Esto quiere decir que los bits de menor peso de todas las entradas se operan con la AND y forman el bit de menor peso de la salida.
		Lo mismo sucede con el bit 1, el bit 2, etc.</string>
  <string name="elem_NAnd">NAND</string>
  <string name="elem_NAnd_tt">Combinación de AND y NOT.
		Devuelve 0 sólo si todas las entradas son 1. Si una de las entradas es 0, la salida es 1.
		Se pueden usar buses como entradas de varios bits. En este caso, la operación se aplica a cada bit de las entradas</string>
  <string name="elem_Or">OR</string>
  <string name="elem_Or_tt">Puerta OR. Devuelve un 1 si por lo menos una de los entradas vale 1.
		Si todas las entradas son 0, la salida es también 0.
		Es también posible usar buses con varios bits como entradas y salida. En ese caso, la OR se ejecuta bit a bit.
		Esto quiere decir que los bits de menor peso de las entradas están operados con una OR y el resultado es el bit de menor peso de la salida.
		Lo mismo sucede con el bit 1, el bit 2, etc.</string>
  <string name="elem_NOr">NOR</string>
  <string name="elem_NOr_tt">Combinación de OR y NOT.
		Devuelve un 0 si una de las entradas vale 1. Si todas las entradas son 0, la salida es 1.
		Es posible usar buses con varios bits por entrada. En tal caso, la operación se aplica a cada bit de las entradas.</string>
  <string name="elem_XOr">XOR</string>
  <string name="elem_XOr_tt">Si se usan dos entradas, la salida es 0 si las dos entradas son iguales.
		En otro caso, la salida estará a 1.
		Si se usan más de dos entradas, se comporta como XOR en cascada (A XOR B XOR C = ((A XOR B) XOR C).
		También es posible usar buses con varios bits por entrada. En tal caso, la operación se aplica a cada bit
		de las entradas.</string>
  <string name="elem_XNOr">XNOR</string>
  <string name="elem_XNOr_tt">Combinación de XOR y NOT. A las entradas se les hace una operación XOR, y el resultado se invierte.
		También es posible usar buses con varios bits por entrada. En tal caso, la operación se aplica a cada uno
		de los bits de entrada.</string>
  <string name="elem_Not">NOT</string>
  <string name="elem_Not_tt">Invierte el valor de la entrada. Convierte un 1 en un 0 y viceversa.
		También es posible usar un bus con varios bits por entrada. En tal caso, la operación se aplica a cada bit de las entradas.</string>
  <string name="elem_Not_pin_in">Entrada de la puerta NOT</string>
  <string name="elem_Not_pin_out">Valor de la entrada invertido</string>
  <string name="elem_LookUpTable">Tabla de Consulta (LUT)</string>
  <string name="elem_LookUpTable_short">TdC (LUT)</string>
  <string name="elem_LookUpTable_tt">Extrae el valor de salida de una tabla de consulta.
		Esta puerta, por tanto, puede simular cualquier otra.</string>
  <string name="elem_LookUpTable_pin_in">Entrada {0}. Esta entrada en combinación con todas las demás define la
		dirección del valor almacenado que se va a devolver</string>
  <string name="elem_LookUpTable_pin_out">Devuelve el valor almacenado en la posición que indican las entradas.</string>
  <string name="elem_Delay">Retardo</string>
  <string name="elem_Delay_tt">Retarda la señal en función de un tiempo de propagación.
		Retarda una señal por un número ajustable de retardos de puertas.
		Todos los demás componentes de Digital tienen un retardo de puerta como retardo de propagación</string>
  <string name="elem_Delay_pin_in">Entrada de la señal que se va a retardar</string>
  <string name="elem_Delay_pin_out">La señal de entrada retrasada un tiempo de retardo de puerta</string>
  <string name="elem_Out">Salida</string>
  <string name="elem_Out_tt">Puede usarse para mostrar una señal de salida en un circuito.
		Este elemento también se usa para conectar un circuito con un circuito incrustado.
		En tal caso la conexión es bidireccional.
		También se usa para asignar un número de pin, si se genera código para un CPLD o una FPGA.</string>
  <string name="elem_Out_pin_in">Este valor se usa para la conexión de salida.</string>
  <string name="elem_LED">LED</string>
  <string name="elem_LED_tt">Un LED puede usarse para visualizar un valor de salida de un bit.
		Se enciende si la entrada vale 1.</string>
  <string name="elem_LED_pin_in">Entrada del LED. El LED se enciende si la entrada está a 1.</string>
  <string name="elem_RGBLED">LED RGB</string>
  <string name="elem_RGBLED_tt">Un LED RGB cuyo color se puede controlar con tres entradas.
		En cada una de ellas se conecta un canal para el color.</string>
  <string name="elem_RGBLED_pin_R">Canal del color rojo</string>
  <string name="elem_RGBLED_pin_G">Canal del color verde</string>
  <string name="elem_RGBLED_pin_B">Canal del color azul</string>
  <string name="elem_In">Entrada</string>
  <string name="elem_In_tt">Puede usarse para controlar manualmente una señal de entrada de un circuito con el ratón.
		Este componente también se usa para conectar un circuito con otro incrustado.
		En este caso la conexión es bidireccional.</string>
  <string name="elem_In_pin_out">Proporciona el valor de esta entrada</string>
  <string name="elem_DipSwitch">Interruptor DIP</string>
  <string name="elem_DipSwitch_tt">Interruptor DIP simple, que puede dar 0 o 1 como salida.</string>
  <string name="elem_DipSwitch_pin_out">Valor de salida del interruptor</string>
  <string name="elem_Clock">Señal de reloj</string>
  <string name="elem_Clock_tt">Señal de reloj. Es posible controlarla con un reloj en tiempo real.
		Dependiendo de la complejidad del circuito, la frecuencia que muestre el reloj puede ser menor que la seleccionada.
		Si la frecuencia supera los 50 Hz, la representación gráfica del circuito no se actualizará en cada ciclo de reloj
		por lo que los colores de los cables no se actualizarán.
		Si el reloj en tiempo real no se activa, el reloj puede ser controlado por clics de ratón.
		También se usa para asignar un número de pin, si se va a generar código para un CPLD o una FPGA.</string>
  <string name="elem_Clock_pin_C">Conmuta entre 0 y 1 con la frecuencia de reloj seleccionada.</string>
  <string name="elem_Button">Pulsador</string>
  <string name="elem_Button_tt">Pulsador simple que vuelve a su posición cuando se libera</string>
  <string name="elem_Button_pin_out">Señal de salida del botón</string>
  <string name="elem_Text">Texto</string>
  <string name="elem_Text_tt">Muestra un texto en el circuito.
		No afecta a la simulación.
		El texto puede cambiarse en el diálogo de Propiedades</string>
  <string name="elem_Rectangle">Rectángulo</string>
  <string name="elem_Rectangle_tt">Muestra un rectángulo en el circuito.
		No afecta a la simulación. Si se usa un signo menos en el encabezado, éste se omite.</string>
  <string name="elem_Probe">Sonda</string>
  <string name="elem_Probe_tt">Un valor medido puede verse en una gráfico o en una tabla de medidas.
		Este componente puede usarse para observar fácilmente valores de circuitos incrustados.
		No afecta a la simulación.</string>
  <string name="elem_Probe_pin_in">El valor de la medida</string>
  <string name="elem_LightBulb">Bombilla</string>
  <string name="elem_LightBulb_tt">La bombilla tiene dos conexiones. Si la atraviesa corriente, se enciende. La dirección de la corriente no importa.
		La bombilla se enciende cuando las entradas tienen diferente valor. Por tanto, se comporta igual que una puerta XOR</string>
  <string name="elem_LightBulb_pin_A">Conector A</string>
  <string name="elem_LightBulb_pin_B">Conector B</string>
  <string name="elem_PolarityAwareLED">LED con dos conexiones</string>
  <string name="elem_PolarityAwareLED_tt">LED con conexiones para el cátodo y el ánodo. El LED se encienda si el ánodo está conectado a nivel alto y el cátodo a nivel bajo.
		Este LED no se puede usar como resistencia pull-down. Funciona únicamente como elemento que indica funcionamiento.
		La resistencia que se ve está destinada a representar la resistencia serie que se precisa para limitar la corriente.</string>
  <string name="elem_PolarityAwareLED_pin_A">Ánodo del LED</string>
  <string name="elem_PolarityAwareLED_pin_C">Cátodo del LED</string>
  <string name="elem_Seven-Seg">Display de 7 segmentos</string>
  <string name="elem_Seven-Seg_tt">Display de siete segmentos. Cada segmento tiene su propia entrada de control.
		Se numeran con las letras 'a', 'b', 'c', 'd', 'e', 'f', 'g', en sentido dextrógiro, empezando
		por el segmento horizontal superior.</string>
  <string name="elem_Seven-Seg_pin_a">Esta entrada controla el segmento 'a'.</string>
  <string name="elem_Seven-Seg_pin_b">Esta entrada controla el segmento 'b'.</string>
  <string name="elem_Seven-Seg_pin_c">Esta entrada controla el segmento 'c'.</string>
  <string name="elem_Seven-Seg_pin_d">Esta entrada controla el segmento 'd'.</string>
  <string name="elem_Seven-Seg_pin_e">Esta entrada controla el segmento 'e'.</string>
  <string name="elem_Seven-Seg_pin_f">Esta entrada controla el segmento 'f'.</string>
  <string name="elem_Seven-Seg_pin_g">Esta entrada controla el segmento 'g'.</string>
  <string name="elem_Seven-Seg_pin_dp">Esta entrada controla el punto decimal.</string>
  <string name="elem_Seven-Seg_pin_cc">Cátodo común. Para encender los ledes, esta entrada tiene que estar a 0.</string>
  <string name="elem_Seven-Seg-Hex">Display de 7 segmentos hexadecimal</string>
  <string name="elem_Seven-Seg-Hex_tt">Display de 7 segmentos con una entrada hexadecimal de 4 bits.</string>
  <string name="elem_Seven-Seg-Hex_pin_d">El valor en esta entrada se visualiza en el display.</string>
  <string name="elem_Seven-Seg-Hex_pin_dp">Esta entrada controla el punto decimal.</string>
  <string name="elem_SixteenSeg">Display de 16 segmentos</string>
  <string name="elem_SixteenSeg_tt">La entrada de LED tiene 16 bits, que controlan los segmentos. La segunda entrada controla el punto decimal.</string>
  <string name="elem_SixteenSeg_pin_led">Bus de 16 bits para controlar los ledes.</string>
  <string name="elem_SixteenSeg_pin_dp">Esta entrada controla el punto decimal</string>
  <string name="elem_LedMatrix">Matriz de ledes</string>
  <string name="elem_LedMatrix_tt">Matriz de ledes. Los ledes se muestran en una ventana aparte.
		Los ledes de una columna del display se controlan mediante una expresión de datos. En la otra entrada,
      se selecciona la columna actual. Por tanto, se hace una representación multiplexada.
      Los ledes se pueden encender indefinidamente en la simulación para evitar el parpadeo.
  </string>
    <string name="elem_LedMatrix_pin_r-data">El estado de la fila de una columna de ledes.
        Cada bit de esta expresión representa el estado de una fila de la columna actual.
    </string>
    <string name="elem_LedMatrix_pin_c-addr">El número de la columna actual cuyo estado actual está visible en la otra
        entrada.
    </string>
    <string name="elem_Data">Gráfica de datos</string>
    <string name="elem_Data_tt">Muestra un dibujo de los datos dentro del panel del circuito.
        Pueden dibujarse ciclos de reloj completos o cambios en puertas simples.
        No afecta a la simulación.
    </string>
    <string name="elem_RotEncoder">Encoder rotatorio</string>
    <string name="elem_RotEncoder_tt">Mando rotatorio con un encoder rotatorio. Se usa para detectar giros.</string>
    <string name="elem_RotEncoder_pin_A">Señal A del encoder</string>
    <string name="elem_RotEncoder_pin_B">Señal B del encoder</string>
    <string name="elem_Keyboard">Teclado</string>
    <string name="elem_Keyboard_tt">Teclado que puede usarse para introducir texto.
        Este componente almacena la entrada, que puede leerse posteriormente.
        Una ventana aparte se abre para escribir el texto
    </string>
    <string name="elem_Keyboard_pin_C">Reloj. Un flanco de subida elimina el último carácter de la memoria.</string>
    <string name="elem_Keyboard_pin_en">Si está alto, la salida D está activa y sale un carácter.
        También habilita la entrada de reloj.
    </string>
    <string name="elem_Keyboard_pin_D">El último carácter escrito, o cero si no hay ningún carácter disponible.
        La salida es el carácter Java de 16 bits
    </string>
    <string name="elem_Keyboard_pin_av">Esta salida indica que hay caracteres disponibles.
        Se puede usar para disparar una interrupción.
    </string>
    <string name="elem_Terminal">Terminal</string>
    <string name="elem_Terminal_tt">Puedes escribir caracteres ASCII en el terminal.
        El terminal abre su propia ventana para visualizar la salida.
    </string>
    <string name="elem_Terminal_pin_C">Reloj. Un flanco de subida escribe el valor de la entrada en la terminal.
    </string>
    <string name="elem_Terminal_pin_D">El dato que se va a escribir en la terminal.</string>
    <string name="elem_Terminal_pin_en">Un 1 en esta entrada habilita la entrada de reloj.</string>
    <string name="elem_MIDI">MIDI</string>
    <string name="elem_MIDI_tt">Usa el MIDI del sistema para tocar notas.</string>
    <string name="elem_MIDI_pin_N">Nota</string>
    <string name="elem_MIDI_pin_V">Volumen</string>
    <string name="elem_MIDI_pin_OnOff">Si está activo, funcionará al presionar una tecla del teclado.
        Si no está activo, funcionará al liberar la tecla.
    </string>
    <string name="elem_MIDI_pin_en">Habilita el componente</string>
    <string name="elem_MIDI_pin_PC">Si está a 1, el valor que haya en N se usará para cambiar el instrumento.</string>
    <string name="elem_MIDI_pin_C">Reloj</string>
    <string name="elem_Ground">Tierra</string>
    <string name="elem_Ground_tt">Conexión a tierra. La salida es siempre cero.</string>
    <string name="elem_Ground_pin_out">La salida siempre devuelve 0.</string>
  <string name="elem_VDD">Fuente de tensión</string>
  <string name="elem_VDD_tt">Conexión a la fuente de tensión. La salida es siempre 1.</string>
  <string name="elem_VDD_pin_out">Esta salida siempre devuelve 1.</string>
  <string name="elem_Const">Valor constante</string>
  <string name="elem_Const_tt">Componente que devuelve un valor dado como simple constante. El valor puede fijarse en el diálogo de propiedades.</string>
  <string name="elem_Const_pin_out">Devuelve el valor dado como constante.</string>
  <string name="elem_Tunnel">Túnel</string>
    <string name="elem_Tunnel_tt">Conecta componentes sin cable. Todos los elementos "túnel" que tengan el mismo nombre
        de red
        están conectados entre sí. Funciona sólo localmente, por lo que no es posible conectar diferentes circuitos.
        Los túneles sin nombre se ignoran en silencio.
    </string>
  <string name="elem_Tunnel_pin_in">Conexión al túnel</string>
    <string name="elem_Splitter">Divisor/Agregador</string>
  <string name="elem_Splitter_tt">Divide o crea un haz de cables o un bus de datos con más de un bit.
		Con un bus es posible, por ejemplo, generar conexiones de 16 bits sin tener que generar 16 cables individuales.
		Las 16 conexiones pueden agruparse en un cable.
		El divisor tiene una dirección, es decir, sólo puede transmitir señales en una dirección.</string>
  <string name="elem_Splitter_pin_in">Los bits de entrada {0}</string>
  <string name="elem_Splitter_pin_in_one">El bit de entrada {0}</string>
  <string name="elem_Splitter_pin_out">Los bits de salida {0}</string>
  <string name="elem_Splitter_pin_out_one">El bit de salida {0}</string>
  <string name="elem_BusSplitter">Divisor bidireccional</string>
  <string name="elem_BusSplitter_tt">Puede usarse para buses de datos, y simplifica la construcción de módulos de memoria
		en encapsulado DIL, por lo que la implementación del bus de datos se simplifica.</string>
  <string name="elem_BusSplitter_pin_OE">Activo, el valor del terminal de datos D común se propaga a la salida de bits D[i].
		En caso contrario, los bits D[i] se propagan a la salida común D.</string>
  <string name="elem_BusSplitter_pin_D">Conexión común de datos.</string>
  <string name="elem_BusSplitter_pin_D_N">Bit de datos {0} del divisor.</string>
  <string name="elem_PullUp">Resistencia pull-up</string>
  <string name="elem_PullUp_pin_out">Un "alto débil"</string>
  <string name="elem_PullUp_tt">Si una red está en estado de alta impedancia, esta resistencia pone la red a alto.
		En otro caso, este componente no hace nada.</string>
  <string name="elem_PullDown">Resistencia pull-down</string>
  <string name="elem_PullDown_pin_out">Un "bajo débil"</string>
  <string name="elem_PullDown_tt">Si la red está en estado de alta impedancia, esta resistencia pone la red a masa.
		En otro caso, este componente no tiene efecto.</string>
  <string name="elem_Driver">Driver</string>
  <string name="elem_Driver_tt">Un driver puede usarse para conectar un valor de señal a otro cable.
		El driver se controla por la entrada "sel".
		Si "sel" está bajo, la salida está en alta impedancia.
		Si "sel" está alto, la salida tomará el valor de la entrada.</string>
  <string name="elem_Driver_pin_in">Valor de entrada del driver</string>
  <string name="elem_Driver_pin_out">Si la entrada "sel" es 1, la entrada pasa a esta salida.
		Si la entrada "sel" es 0, esta salida estará en estado de alta impedancia.</string>
  <string name="elem_Driver_pin_sel">Pin para controlar el driver.
		Si su valor es 1, la entrada se propaga a la salida.
		Si el valor es 0, la salida estará en estado de alta impedancia.</string>
  <string name="elem_DriverInvSel">Driver, selector invertido</string>
  <string name="elem_DriverInvSel_tt">Un driver puede usarse para conectar una palabra de datos a otra línea.
      El driver se controla por la entrada "sel".
      Si "sel" está a 1, la salida estará en alta impedancia.
      Si "sel" está a 0, la salida contendrá el valor de la entrada.
  </string>
    <string name="elem_DriverInvSel_pin_in">Valor de entrada del driver.</string>
    <string name="elem_DriverInvSel_pin_sel">Pin para controlar el driver.
        Si su valor es 0, la entrada se propaga a la salida.
        Si su valor es 1, la salida pasará a estado de alta impedancia.
    </string>
    <string name="elem_DriverInvSel_pin_out">Si la entrada "sel" es 0, la entrada se propaga a esta salida.
        Si la entrada "sel" es 1, esta salida estará en alta impedancia.
    </string>
    <string name="elem_Multiplexer">Multiplexor</string>
    <string name="elem_Multiplexer_tt">Componente que usa el valor del pin de selección (sel) para decidir qué valor de
        entrada se pone en la salida.
    </string>
    <string name="elem_Multiplexer_input">El {0} dato de entrada del multiplexor.</string>
    <string name="elem_Multiplexer_output">El valor de la entrada seleccionada.</string>
    <string name="elem_Multiplexer_pin_sel">Esta entrada se emplea para seleccionar el dato de entrada que pasará a la
        salida.
    </string>
    <string name="elem_Demultiplexer">Demultiplexor</string>
    <string name="elem_Demultiplexer_tt">Componente que puede enviar el valor de entrada a una cualquiera de varias
        salidas.
        Las otras salidas estarán fijadas al valor por defecto.
    </string>
    <string name="elem_Demultiplexer_pin_sel">Este pin selecciona la salida que se va a emplear.</string>
    <string name="elem_Demultiplexer_pin_in">El valor de esta entrada se propagará a la salida de datos seleccionada.
    </string>
    <string name="elem_Demultiplexer_output">Salida de datos {0}.</string>
    <string name="elem_Decoder">Decodificador</string>
  <string name="elem_Decoder_tt">Uno de los pines seleccionables es 1. Todas las demás salidas son 0.</string>
  <string name="elem_Decoder_output">Salida {0}. Esta salida es 1 si se selecciona mediante la entrada "sel"</string>
  <string name="elem_Decoder_pin_sel">Esta entrada selecciona la salida que está habilitada
        La salida seleccionada está a 1. Todas las demás salidas están a 0.</string>
  <string name="elem_BitSelector">Selector de bit</string>
  <string name="elem_BitSelector_tt">Selecciona un bit de un bus de datos.</string>
  <string name="elem_BitSelector_pin_in">Bus de entrada</string>
  <string name="elem_BitSelector_pin_sel">Esta entrada selecciona el bit</string>
  <string name="elem_BitSelector_pin_out">Bit seleccionado.</string>
  <string name="elem_PriorityEncoder">Codificador con prioridad</string>
  <string name="elem_PriorityEncoder_short">Prioridad</string>
  <string name="elem_PriorityEncoder_tt">Si una de las entradas está activa, su número pasa a la salida.
		Si varias entradas están activas a la vez, el número más alto se pasa a la salida.</string>
  <string name="elem_PriorityEncoder_pin_num">Número de la entrada fijada</string>
  <string name="elem_PriorityEncoder_pin_any">Si esta entrada está activa, al menos una de las entradas está activa.</string>
  <string name="elem_PriorityEncoder_input">La entrada {0} del codificador con prioridad.</string>
  <string name="elem_RS_FF_AS">Flip-Flop RS</string>
  <string name="elem_RS_FF_AS_short">RS</string>
  <string name="elem_RS_FF_AS_tt">Componente para almacenar un bit.
		Dispone de las funciones "set" y "reset" para fijar o borrar el bit almacenado.
		Si ambas entradas valen 1, ambas salidas se pondrán a uno.
		Si ambas entradas se ponen a 0 a la vez, el estado final será indeterminado.</string>
  <string name="elem_RS_FF_AS_pin_S">Entrada de Set</string>
  <string name="elem_RS_FF_AS_pin_R">Entrada de Reset.</string>
  <string name="elem_RS_FF_AS_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_RS_FF_AS_pin_~Q">Devuelve el inverso del valor almacenado.</string>
  <string name="elem_RS_FF">Flip-Flop RS con reloj</string>
  <string name="elem_RS_FF_short">RS</string>
  <string name="elem_RS_FF_tt">Componente para almacenar un bit.
         Permite a las funciones "set" y "reset" fijar o borrar el bote almacenado.
         Si ambas entradas (S,R) están a 1 en el flanco de subida del reloj, el estado final es indeterminado</string>
  <string name="elem_RS_FF_pin_S">La entrada de Set</string>
  <string name="elem_RS_FF_pin_C">Entrada de reloj. Un flanco de subida inicia un cambio de estado.</string>
  <string name="elem_RS_FF_pin_R">Enterada de Reset</string>
  <string name="elem_RS_FF_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_RS_FF_pin_~Q">Devuelve el ingreso del valor almacenado.</string>
  <string name="elem_JK_FF">Flip-Flop JK</string>
  <string name="elem_JK_FF_short">JK</string>
  <string name="elem_JK_FF_tt">Puede almacenar (J=K=0), fijar (J=1,K=0), reiniciar (J=0, K=1) o invertir (J=K=1) el valor almacenado.
        El cambio de estado se produce sólo en un flanco de subida en la entrada de reloj.</string>
  <string name="elem_JK_FF_pin_J">Entrada Set del Flip-Flop</string>
  <string name="elem_JK_FF_pin_C">Entrada de reloj. Un flanco de subida provoca un cambio de estado.</string>
  <string name="elem_JK_FF_pin_K">Entrada de Reset del Flip-Flop</string>
  <string name="elem_JK_FF_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_JK_FF_pin_~Q">Devuelve el inverso del valor almacenado.</string>
  <string name="elem_D_FF">Flip-Flop tipo D</string>
  <string name="elem_D_FF_short">D</string>
  <string name="elem_D_FF_tt">Componente empleado para almacenar un valor.
		El valor en el pin D se almacena en un flanco de subida del reloj en el pin C.
		La anchura del bit puede seleccionarse, permitiéndose almacenar múltiples bits.</string>
  <string name="elem_D_FF_pin_D">Entrada del bit que se va a almacenar.</string>
  <string name="elem_D_FF_pin_C">Pin de reloj para almacenar un valor.
		El valor en la entrada D se almacena en un flanco de subida de este pin.</string>
  <string name="elem_D_FF_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_D_FF_pin_~Q">Devuelve el inverso del valor almacenado.</string>
  <string name="elem_T_FF">Flip-Flop tipo T</string>
  <string name="elem_T_FF_short">T</string>
  <string name="elem_T_FF_tt">Almacena un solo bit. Invierte el estado en un flanco de subida introducido por la entrada C.</string>
  <string name="elem_T_FF_pin_T">Habilita la función de conmutación.</string>
  <string name="elem_T_FF_pin_C">Entrada de reloj. Un flanco de subida invierte la salida, si la entrada T está a 1.</string>
  <string name="elem_T_FF_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_T_FF_pin_~Q">Devuelve el inverso del valor almacenado.</string>
  <string name="elem_JK_FF_AS">Flip-Flop JK asíncrono</string>
  <string name="elem_JK_FF_AS_short">JK-As</string>
  <string name="elem_JK_FF_AS_tt">Tiene la posibilidad de almacenar (J=K=0), fijar (J=1, K=0), borrar (J=0, K=1) o conmutar (J=K=1) el valor almacenado.
		El cambio de estado tiene lugar sólo en un flanco de subida en la entrada de reloj C.
		Hay dos entradas adicionales que fijan el estado o lo reinician sin señal de reloj.</string>
  <string name="elem_JK_FF_AS_pin_J">Entrada de Set del Flip-Flop</string>
  <string name="elem_JK_FF_AS_pin_C">Entrada de reloj. Un flanco de subida provoca un cambio de estado.</string>
  <string name="elem_JK_FF_AS_pin_K">Entrada de Reset del Flip-Flop.</string>
  <string name="elem_JK_FF_AS_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_JK_FF_AS_pin_~Q">Devuelve el inverso del valor almacenado.</string>
  <string name="elem_JK_FF_AS_pin_Set">Set asíncrono. Un valor alto en esta entrada fija el Flip-Flop.</string>
  <string name="elem_JK_FF_AS_pin_Clr">Reset asíncrono. Un valor alto en esta entrada borra el Flip-Flop.</string>
  <string name="elem_D_FF_AS">Flip-Flop tipo D, asíncrono</string>
  <string name="elem_D_FF_AS_short">D-AS</string>
  <string name="elem_D_FF_AS_tt">Componente usado para almacenar un valor.
		El valor del pin D se almacena con un flanco de subida por el pin de reloj, C.
		Se puede seleccionar el tamaño de bit, lo cual permite almacenar varios bits.</string>
  <string name="elem_D_FF_AS_pin_D">Entrada del bit que se va a almacenar.</string>
  <string name="elem_D_FF_AS_pin_C">Pin de control para almacenar un bit. El bit de la entrada D se almacena en un flanco de subida de este pin.</string>
  <string name="elem_D_FF_AS_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_D_FF_AS_pin_~Q">Devuelve el inverso del valor almacenado.</string>
  <string name="elem_D_FF_AS_pin_Set">Set asíncrono. Si está a 1, todos los bits almacenados valdrán 1.</string>
  <string name="elem_D_FF_AS_pin_Clr">Clear asíncrono. Si está a uno, todos los bits se ponen a 0.</string>
  <string name="elem_Monoflop">Monoestable</string>
  <string name="elem_Monoflop_short">Monoestable</string>
  <string name="elem_Monoflop_tt">El monoestable se activa con un flanco de subida en la entrada de reloj.
		Después de un tiempo de retardo que es configurable, el monoestable se borrará automáticamente.
		El monoestable se puede disparar varias veces. Se puede usar sólo si hay exactamente un componente reloj presente en el circuito.
		Este componente de reloj se usa como unidad de medida del tiempo de retardo.</string>
  <string name="elem_Monoflop_pin_R">Entrada de Reset. Un valor alto borra el monoestable.</string>
  <string name="elem_Monoflop_pin_C">Entrada de reloj. Un flanco de subida activa el monoestable.</string>
  <string name="elem_Monoflop_pin_Q">salida</string>
  <string name="elem_Monoflop_pin_~Q">salida invertida</string>
  <string name="elem_Register">Registro</string>
  <string name="elem_Register_short">Reg</string>
  <string name="elem_Register_tt">Componente para almacenar valores. El tamaño de bits de la palabra de datos puede escogerse.
		A diferencia de un FF tipo D, el registro proporciona una entrada que habilita al reloj.</string>
  <string name="elem_Register_pin_D">Pin de entrada de la expresión que se va a almacenar</string>
  <string name="elem_Register_pin_C">Entrada de reloj. Un flanco de subida almacena el valor en el pin D.</string>
  <string name="elem_Register_pin_en">Pin de habilitación. Sólo se almacena un valor si este pin está a 1.</string>
  <string name="elem_Register_pin_Q">Devuelve el valor almacenado.</string>
  <string name="elem_ROM">ROM</string>
  <string name="elem_ROM_tt">Elemento de memoria no volátil.
		Los datos almacenados pueden editarse en el diálogo de propiedades.</string>
  <string name="elem_ROM_pin_A">Este pin define la dirección de la expresión que va a la salida.</string>
  <string name="elem_ROM_pin_D">La expresión seleccionada si la entrada "sel" está alta.</string>
  <string name="elem_ROM_pin_sel">Si la entrada es alta, la salida está activada. Si está baja, la salida de datos está en estado de alta impedancia.</string>
  <string name="elem_RAMDualPort">RAM, puertos separados</string>
  <string name="elem_RAMDualPort_short">RAM</string>
  <string name="elem_RAMDualPort_tt">Módulo de RAM con entradas separadas para almacenamiento y salida para leer los datos almacenados.</string>
  <string name="elem_RAMDualPort_pin_A">Dirección desde la que leer o en la que escribir.</string>
  <string name="elem_RAMDualPort_pin_C">Entrada de reloj</string>
  <string name="elem_RAMDualPort_pin_Din">Datos que se van a almacenar en la RAM.</string>
  <string name="elem_RAMDualPort_pin_D">Pin de salida de datos.</string>
  <string name="elem_RAMDualPort_pin_ld">Si esta entrada está a 1, la salida está activa y los datos son visibles en la salida.</string>
  <string name="elem_RAMDualPort_pin_str">Si esta entrada está a 1 y hay un flanco de subida del reloj, los datos se almacenan.</string>
  <string name="elem_BlockRAMDualPort">Bloque de RAM, puertos separados</string>
  <string name="elem_BlockRAMDualPort_short">RAM</string>
  <string name="elem_BlockRAMDualPort_tt">Módulo de RAM con entradas separadas para almacenamiento y salida para lectura de los datos almacenados.
		Esta RAM actualiza la salida sólo en un flanco de subida de la entrada de reloj.
		Esto permite el uso del bloque de RAM en una FPGA.</string>
  <string name="elem_BlockRAMDualPort_pin_A">Dirección desde la que leer o en la que escribir.</string>
  <string name="elem_BlockRAMDualPort_pin_C">Reloj de entrada.</string>
  <string name="elem_BlockRAMDualPort_pin_Din">Datos que van a almacenarse en la RAM.</string>
  <string name="elem_BlockRAMDualPort_pin_D">Pin de salida de los datos.</string>
  <string name="elem_BlockRAMDualPort_pin_str">Los datos se guardan si esta salida está alta y hay un flanco de subida del reloj.</string>
  <string name="elem_EEPROMDualPort">EEPROM, puertos separados</string>
  <string name="elem_EEPROMDualPort_short">EEPROM</string>
  <string name="elem_EEPROMDualPort_tt">Módulo EEPROM con entradas separadas para almacenamiento y salida para lectura de los datos almacenados.</string>
  <string name="elem_EEPROMDualPort_pin_A">Dirección desde la que leer o en la que escribir</string>
  <string name="elem_EEPROMDualPort_pin_C">Entrada de reloj</string>
  <string name="elem_EEPROMDualPort_pin_Din">Datos que se van a almacenar en la EEPROM.</string>
  <string name="elem_EEPROMDualPort_pin_D">Pin de salida de datos</string>
  <string name="elem_EEPROMDualPort_pin_ld">Si esta entrada está alta la salida estará activa y el dato es visible en la salida.</string>
  <string name="elem_EEPROMDualPort_pin_str">Si esta entrada está alta y hay un flanco de subida del reloj el dato se almacena.</string>
  <string name="elem_RAMSinglePort">RAM, puerto bidireccional</string>
  <string name="elem_RAMSinglePort_short">RAM</string>
  <string name="elem_RAMSinglePort_tt">Módulo de RAM con un pin bidireccional para lectura y escritura de datos.</string>
  <string name="elem_RAMSinglePort_pin_A">Dirección en la que leer y escribir.</string>
  <string name="elem_RAMSinglePort_pin_C">Reloj</string>
  <string name="elem_RAMSinglePort_pin_D">Conexión bidireccional de datos.</string>
  <string name="elem_RAMSinglePort_pin_ld">Si esta entrada está alta, la salida estará activa y el dato es visible en ella.</string>
  <string name="elem_RAMSinglePort_pin_str">Si esta entrada está alta y hay un flanco de subida del reloj, el dato se almacena.</string>
  <string name="elem_RAMSinglePortSel">RAM, selecciona chip</string>
  <string name="elem_RAMSinglePortSel_short">RAM</string>
  <string name="elem_RAMSinglePortSel_tt">Módulo de RAM con conexión bidireccional para lectura y escritura de datos.
		Si la entrada CS está baja, el componente está deshabilitado.
		Esto permite construir una RAM más grande con RAMs más pequeñas y un decodificador de direcciones.
		El ciclo de escritura trabaja así: poniendo CS alto, el componente se selecciona.
		Un flanco de subida en WE bloquea la dirección, y el siguiente flanco de bajada en WE almacena el dato.</string>
  <string name="elem_RAMSinglePortSel_pin_A">Dirección en la que leer y escribir.</string>
  <string name="elem_RAMSinglePortSel_pin_WE">Si está en alto, el dato se escribe en la RAM.</string>
  <string name="elem_RAMSinglePortSel_pin_D">Conexión de datos bidireccional.</string>
  <string name="elem_RAMSinglePortSel_pin_CS">Si esta entrada está alta, la RAM está habilitada. En otro caso la salida estará siempre en alta impedancia.</string>
  <string name="elem_RAMSinglePortSel_pin_OE">Si esta entrada está en alto, el valor almacenado va a la salida.</string>
  <string name="elem_EEPROM">EEPROM</string>
  <string name="elem_EEPROM_tt">Módulo EEPROM con conexión bidireccional para lectura y escritura de datos.
		Si la entrada CS está a 0, el componente está deshabilitado.
		Los datos se almacenan como en una ROM. Así, se mantienen cuando la simulación finaliza y se reinicia.
		El ciclo de escritura trabaja así: colocamos CS a alto, y se selecciona el componente.
		Un flanco de subida en WE bloquea la dirección, y el siguiente flanco de bajada en WE almacena los datos.</string>
  <string name="elem_EEPROM_pin_A">Dirección en la que leer y escribir.</string>
  <string name="elem_EEPROM_pin_WE">Si está alta, el dato se escribe en la EEPROM.</string>
  <string name="elem_EEPROM_pin_D">Entrada de datos bidireccional.</string>
  <string name="elem_EEPROM_pin_CS">Si está entrada está alta, la EEPROM está habilitada. En otro caso, la salida está siempre en alta impedancia.</string>
  <string name="elem_EEPROM_pin_OE">Si esta entrada está alta, extrae el valor almacenado.</string>
  <string name="elem_GraphicCard">RAM gráfica</string>
  <string name="elem_GraphicCard_short">Gr-RAM</string>
  <string name="elem_GraphicCard_tt">Se emplea para mostrar un gráfico mapa de bits. Este componente se comporta como una RAM.
		Adicionalmente, muestra el contenido en una ventana gráfica. Cada píxel se representa por una dirección de memoria.
		El valor almacenado define el color del píxel, usando una paleta de color fija.
		Hay dos buffers de pantalla para soportar el paso de página. La entrada B selecciona el buffer que se muestra.
		Así, el tamaño total de memoria es dx * dy * 2 palabras.
		La paleta usada se organiza así: los índices 0-9 corresponden a los colores blanco, negro, rojo, verde, azul, amarillo,
		cian, magenta, naranja y rosa. Los índices 32-63 mapean valores de gris y los índices 64-127 representan
		64 valores de color, cada uno con dos bits por canal de color.
		Esto resulta en una paleta simple que puede ser direccionada con sólo 7 bits.
		Si la arquitectura soporta índices de 16 bits, desde el índice 0x8000, puede usarse un modo de alto color con 5 bits por canal de color
		lo cual permitirá 32768 colores.</string>
  <string name="elem_GraphicCard_pin_A">Dirección en la que leer y escribir.</string>
  <string name="elem_GraphicCard_pin_str">Si esta entrada está alta y hay un flanco de subida del reloj, el dato se almacena.</string>
  <string name="elem_GraphicCard_pin_C">Reloj</string>
  <string name="elem_GraphicCard_pin_ld">Si esta entrada está alta, la salida se activa y el dato es visible en la salida.</string>
  <string name="elem_GraphicCard_pin_B">Selecciona el buffer de pantalla que se va a mostrar.</string>
  <string name="elem_GraphicCard_pin_D">Conexión de datos bidireccional.</string>
  <string name="elem_RAMDualAccess">RAM, puerto dual</string>
  <string name="elem_RAMDualAccess_short">RAM</string>
  <string name="elem_RAMDualAccess_tt">RAM con un puerto que permite escribir y leer desde ella, y un segundo puerto de sólo lectura.
		Este segundo puerto puede usarse para dar acceso a alguna lógica de gráficos al contenido de la memoria.
		De este modo, un procesador puede escribir en la RAM, y una lógica de gráficos puede leer de la RAM.</string>
  <string name="elem_RAMDualAccess_pin_1D">Puerto de salida 1</string>
  <string name="elem_RAMDualAccess_pin_2D">Puerto de salida 2</string>
  <string name="elem_RAMDualAccess_pin_1A">Dirección en la que el puerto 1 es leído o escrito.</string>
  <string name="elem_RAMDualAccess_pin_2A">Dirección empleada para leer por el puerto 2.</string>
  <string name="elem_RAMDualAccess_pin_C">Reloj</string>
  <string name="elem_RAMDualAccess_pin_1Din">Dato que se va a almacenar en la RAM.</string>
  <string name="elem_RAMDualAccess_pin_ld">Si esta entrada está alta, la salida estará activada, y el dato será visible en la salida 1D.</string>
  <string name="elem_RAMDualAccess_pin_str">Si esta entrada está alta y hay un flanco de subida del reloj, el dato se almacena.</string>
  <string name="elem_RegisterFile">Bloque de registro</string>
  <string name="elem_RegisterFile_short">Registro</string>
  <string name="elem_RegisterFile_tt">Memoria con un puerto que permite escribir y dos puertos que permiten leer de la memoria simultáneamente.
		Puede usarse para implementar registros de procesadores.
		Dos registros pueden leerse simultáneamente y un tercero puede ser escrito.</string>
  <string name="elem_RegisterFile_pin_Da">Puerto de salida a</string>
  <string name="elem_RegisterFile_pin_Db">Puerto de salida b</string>
  <string name="elem_RegisterFile_pin_Ra">Registro que es visible en el puerto a.</string>
  <string name="elem_RegisterFile_pin_Rb">Registro que es visible en el puerto b.</string>
  <string name="elem_RegisterFile_pin_Rw">Registro en el que se escriben los datos.</string>
  <string name="elem_RegisterFile_pin_we">Si esta entrada está alta y hay un flanco de subida del reloj, se almacena el dato.</string>
  <string name="elem_RegisterFile_pin_C">Reloj</string>
  <string name="elem_RegisterFile_pin_Din">Dato que se va a almacenar en el registro Rw.</string>
  <string name="elem_Counter">Contador</string>
  <string name="elem_Counter_short">Contador</string>
  <string name="elem_Counter_tt">Contador simple. La entrada de reloj incrementa el contador.
		Puede ser puesta a 0 con la entrada "clr".
		El número de bits del contador puede fijarse en el diálogo de propiedades.</string>
  <string name="elem_Counter_pin_C">Entrada de reloj. Un flanco de subida incrementa el contador.</string>
  <string name="elem_Counter_pin_clr">Reset síncrono del contador si se fija a 1.</string>
  <string name="elem_Counter_pin_ovf">Salida de overflow (desbordamiento). Este pin vale 1 si el contador llega a su valor máximo y en la entrada hay un 1.</string>
  <string name="elem_Counter_pin_out">Devuelve el valor contado.</string>
  <string name="elem_Counter_pin_en">Si se fija a 1, el contador está activo.</string>
  <string name="elem_CounterPreset">Contador con preset</string>
  <string name="elem_CounterPreset_tt">Contador cuyo valor puede fijarse. Además, use pueden indicar n valor máximo y una dirección de conteo.</string>
  <string name="elem_CounterPreset_short">Contador</string>
  <string name="elem_CounterPreset_pin_out">Devuelve el valor contado.</string>
  <string name="elem_CounterPreset_pin_ovf">Pin de overflow (desbordamiento). Se pone a 1 si la entrada "en" vale 1 y el contador alcanza el máximo valor contando ascendente
	o alcanza el 0 en cuenta descendente.</string>
  <string name="elem_CounterPreset_pin_C">Entrada de reloj. Un flanco de subida incremente el contador.</string>
  <string name="elem_CounterPreset_pin_clr">Reset síncrono del contador si se fija a 1.</string>
  <string name="elem_CounterPreset_pin_en">Si se fija a 1, el contador se habilita.</string>
  <string name="elem_CounterPreset_pin_dir">Indica la dirección de conteo. Un "0" indica ascendente.</string>
  <string name="elem_CounterPreset_pin_ld">Si se fija, el valor que haya en "in" se almacenará en el contador en la siguiente señal de reloj.</string>
  <string name="elem_CounterPreset_pin_in">Esta palabra de datos se almacena en el contador cuando "ld" está activo.</string>
  <string name="elem_Add">Sumador</string>
  <string name="elem_Add_short">Suma</string>
  <string name="elem_Add_tt">Componente que hace sumas simples.
		Suma los dos valores enteros de las entras "a" y "b" (a+b).
		El resultado será incrementado en uno si la entrada de acarreo (carry) está activa.</string>
  <string name="elem_Add_pin_a">Primera entrada de la suma.</string>
  <string name="elem_Add_pin_b">Segunda entrada de la suma.</string>
  <string name="elem_Add_pin_s">Resultado de la suma</string>
  <string name="elem_Add_pin_c_i">Entrada de acarreo: si se fija, el resultado se incrementa en uno.</string>
  <string name="elem_Add_pin_c_o">Salida de acarreo. Si se fija ha habido un desbordamiento.</string>
  <string name="elem_Sub">Restar</string>
  <string name="elem_Sub_short">Resta</string>
  <string name="elem_Sub_tt">Componente para restas sencillas.
		Resta los números binarios de las entradas "a" y "b" (a-b).
		Si la entrada de acarreo vale 1, el resultado se disminuye en 1.</string>
  <string name="elem_Sub_pin_c_i">Entrada de acarreo: si está fijada el resultado se reduce en 1.</string>
  <string name="elem_Sub_pin_a">Entrada "a" para la resta.</string>
  <string name="elem_Sub_pin_b">Entrada "b" para la resta.</string>
  <string name="elem_Sub_pin_s">La salida devuelve el resultado de la diferencia.</string>
  <string name="elem_Sub_pin_c_o">La salida devuelve 1 si ocurrió un desbordamiento.</string>
  <string name="elem_Mul">Multiplicar</string>
  <string name="elem_Mul_short">Producto</string>
  <string name="elem_Mul_tt">Componente que multiplica.
		Multiplica los números enteros de las entradas "a" y "b".</string>
  <string name="elem_Mul_pin_a">Entrada del factor "a"</string>
  <string name="elem_Mul_pin_b">Entrada del factor "b"</string>
  <string name="elem_Mul_pin_mul">Salida para el resultado del producto.</string>
  <string name="elem_Div">División</string>
  <string name="elem_Div_short">División</string>
  <string name="elem_Div_tt">Componente que divide.
		Divide el entero de la entrada "a" entre el entero de la entrada "b".
		Si el divisor es cero, se divide por uno.
		Si la división lleva signo, el resto es siempre positivo.</string>
  <string name="elem_Div_pin_a">Dividendo</string>
  <string name="elem_Div_pin_b">Divisor</string>
  <string name="elem_Div_pin_q">Cociente</string>
  <string name="elem_Div_pin_r">Resto</string>
  <string name="elem_BarrelShifter">Registro de desplazamiento</string>
  <string name="elem_BarrelShifter_short">Desplazar</string>
  <string name="elem_BarrelShifter_tt">Componente que desplaza bits.
		Desplaza el valor de entrada un número de bits dado por la entrada de "shift"</string>
  <string name="elem_BarrelShifter_pin_in">Bits de entrada que se van a desplazar.</string>
  <string name="elem_BarrelShifter_pin_shift">Entrada con la anchura del desplazamiento</string>
  <string name="elem_BarrelShifter_pin_out">Salida con el valor desplazado</string>
  <string name="elem_Comparator">Comparador</string>
  <string name="elem_Comparator_tt">Componente que compara valores de bits.
		Compara los números binarios de los pines "a" y "b" y fija las correspondientes salidas.</string>
  <string name="elem_Comparator_pin_a">Entrada del valor "a"</string>
  <string name="elem_Comparator_pin_b">Entrada del valor "b"</string>
  <string name="elem_Comparator_pin_=">Esta salida es 1 si la entrada "a" y "b" son iguales.</string>
  <string name="elem_Comparator_pin_&gt;">Esta salida es 1 si la entrada "a" es mayor que la "b".</string>
  <string name="elem_Comparator_pin_&lt;">Esta salida es 1 si la entrada "a" es menor que la "b"</string>
  <string name="elem_Neg">Negación</string>
  <string name="elem_Neg_short">Neg</string>
  <string name="elem_Neg_pin_in">Entrada de la palabra de datos que se va a negar con complemento a 2</string>
  <string name="elem_Neg_pin_out">Devuelve el resultado de la negación con complemento a 2.</string>
  <string name="elem_Neg_tt">Negación en complemento a 2.</string>
  <string name="elem_BitExtender">Extensor de signo</string>
  <string name="elem_BitExtender_short">SignEx</string>
  <string name="elem_BitExtender_tt">Incrementa la anchura de bits de un valor manteniendo el signo.
		Si la entrada es un solo bit, este bit será la salida de todos los bits de salida.</string>
  <string name="elem_BitExtender_pin_in">Valor de entrada.
		La amplitud del bit de entrada debe ser menor que la del bit de salida.</string>
  <string name="elem_BitExtender_pin_out">Valor de entrada extendido.
		La amplitud del bit de entrada debe ser menor que la del bit de salida.</string>
  <string name="elem_BitCount">Contador de bits</string>
  <string name="elem_BitCount_short">Contador de bits</string>
  <string name="elem_BitCount_tt">Devuelve la cantidad de bits en el valor de entrada.</string>
  <string name="elem_BitCount_pin_in">Entrada en la que los bits se cuentan.</string>
  <string name="elem_BitCount_pin_out">Devuelve el número de bits.</string>
  <string name="elem_DiodeForward">Diodo polarizado</string>
  <string name="elem_DiodeForward_tt">Diodo unidireccional simplificado, usado para poner un cable a VDD. Se usa para implementar una puerta OR.
		Es necesario conectar una resistencia pull-down a la salida del diodo.
		En la simulación el diodo se comporta como una puerta con tres valores:
		Si la entrada está alta, la salida también está alta. En todos los otros casos (la entrada está baja o en alta impedancia)
		la salida está en alta impedancia.
		Así, dos diodos conectados en antiparalelo pueden mantenerse uno a otro en estado alto, lo cual no es posible con diodos reales.
		Éste es un diodo real: no hay pérdida de voltaje a través del diodo en polarización directa.</string>
  <string name="elem_DiodeForward_pin_in">Si la entrada es alta, la salida es también alta. En todos los otros casos la salida estará en alta impedancia.</string>
  <string name="elem_DiodeForward_pin_out">Si la entrada está en alto, la salida también está en alto. En todos los demás casos la salida estará en alta impedancia.</string>
  <string name="elem_DiodeBackward">Diodo a masa</string>
  <string name="elem_DiodeBackward_tt">Diodo unidireccional simplificado, usado para poner un cable a masa. Se usa para implementar una puerta AND.
		Es necesario conectar una resistencia pull-up a la salida de los diodos.
		Si la entrada está baja, la salida estará baja. En los demás casos (entrada alta o alta impedancia) la salida estará en alta impedancia.
		Así dos diodos conectados en antiparalelo pueden mantenerse en estado bajo uno a otro, lo cual no es posible con diodos reales.
		Es un diodo ideal: no hay pérdida de voltaje en polarización directa.</string>
  <string name="elem_DiodeBackward_pin_in">Si la entrada está baja, la salida también estará baja. En todos los demás casos la salida estará en alta impedancia.</string>
  <string name="elem_DiodeBackward_pin_out">Si la entrada está baja, la salida también estará baja. En todos los demás casos la salida estará en alta impedancia.</string>
  <string name="elem_Switch">Conmutador</string>
  <string name="elem_Switch_pin">Una de las conexiones del conmutador.</string>
  <string name="elem_Switch_tt">Conmutador simple.
		No hay retraso por puertas: un cambio de señal se propaga inmediatamente.</string>
  <string name="elem_SwitchDT">Conmutador de dos caminos</string>
  <string name="elem_SwitchDT_tt">Conmutador de dos caminos.
		No hay retraso por puertas: un cambio de señal se propaga inmediatamente.</string>
  <string name="elem_Fuse">Fusible</string>
  <string name="elem_Fuse_tt">Fusible usado para construir memorias programables una sola vez.</string>
  <string name="elem_Fuse_pin_out1">Una de las conexiones del fusible.</string>
  <string name="elem_Fuse_pin_out2">Una de las conexiones del fusible.</string>
  <string name="elem_Relay">Relé</string>
  <string name="elem_Relay_tt">Un relé es un conmutador que puede ser controlado por un electroimán.
		Si la corriente pasa por la bobina del electroimán, el conmutador se cierra o se abre.
		No hay diodo en antiparalelo, por lo que la dirección de la corriente no importa.
		El conmutador se activa si las entradas tienen diferentes valores.
		El relé se comporta igual a una puerta XOR.</string>
  <string name="elem_Relay_pin_in1">Una de las entradas de control del relé.</string>
  <string name="elem_Relay_pin_in2">Una de las entradas de control del relé.</string>
  <string name="elem_RelayDT">Relé de dos contactos</string>
  <string name="elem_RelayDT_tt">Un relé es un conmutador que puede ser controlado por un electroimán.
		Si la corriente pasa por la bobina del electroimán, el conmutador se cierra o se abre.
		No hay diodo en antiparalelo, por lo que la dirección de la corriente no importa.
		El conmutador se activa si las entradas tienen diferentes valores.
		El relé se comporta igual a una puerta XOR.</string>
  <string name="elem_RelayDT_pin_in1">Una de las entradas para controlar el relé.</string>
  <string name="elem_RelayDT_pin_in2">Una de las entradas para controlar el relé.</string>
  <string name="elem_PFET">FET de canal P</string>
  <string name="elem_PFET_tt">FET de canal P.
		La base está conectada a la tensión positiva y el transistor es simulado sin diodo interno.</string>
  <string name="elem_PFET_pin_G">Puerta</string>
  <string name="elem_PFET_pin_S">Fuente</string>
  <string name="elem_PFET_pin_D">Drenaje</string>
  <string name="elem_NFET">FET de canal N</string>
  <string name="elem_NFET_tt">FET de canal N.
		La base está conectada a masa y el transistor se simula sin diodo interno.</string>
  <string name="elem_NFET_pin_G">Puerta</string>
  <string name="elem_NFET_pin_S">Fuente</string>
  <string name="elem_NFET_pin_D">Drenaje</string>
  <string name="elem_FGPFET">FET de canal P de compuerta flotante</string>
  <string name="elem_FGPFET_tt">FET de canal P de compuerta flotante.
		La base está conectada a tierra y el transistor se simula sin diodo interno.
		Si hay carga almacenada en la puerta flotante, el FET no conduce, incluso si la puerta está a 0.</string>
  <string name="elem_FGPFET_pin_G">Puerta</string>
  <string name="elem_FGPFET_pin_S">Fuente</string>
  <string name="elem_FGPFET_pin_D">Drenaje</string>
  <string name="elem_FGNFET">FET de canal N de compuerta flotante</string>
  <string name="elem_FGNFET_tt">FET de canal N de compuerta flotante.</string>
  <string name="elem_FGNFET_pin_G">Puerta</string>
  <string name="elem_FGNFET_pin_S">Fuente</string>
  <string name="elem_FGNFET_pin_D">Drenaje</string>
  <string name="elem_TransGate">Puerta de transmisión</string>
  <string name="elem_TransGate_tt">Un puerta de transmisión real se construye sólo con dos transistores.
		Por tanto, se usa a menudo para ahorrar transistores durante la implementación en silicio.</string>
  <string name="elem_TransGate_pin_A">Entrada A</string>
  <string name="elem_TransGate_pin_B">Entrada B</string>
  <string name="elem_TransGate_pin_S">Entrada de control</string>
  <string name="elem_TransGate_pin_~S">Entrada de control invertida</string>
  <string name="elem_Testcase">Caso de prueba</string>
  <string name="elem_Testcase_tt">Describe un caso de prueba.
		En un caso de prueba (test case) de un circuito, se puede describir cómo éste debería comportarse.
		Podrá entonces automáticamente comprobarse si el comportamiento del circuito corresponde a su descripción.
		Si no es así, se muestra un mensaje de error.
		El texto de ayuda del editor de casos de prueba describe detalladamente cómo puede crearse sicho caso de prueba.</string>
  <string name="elem_AsyncSeq">Temporizador asíncrono</string>
  <string name="elem_AsyncSeq_tt">Permite la configuración del temporizado de un circuito secuencial asíncrono, como una tubería de Muller.
		El circuito debe empezar en un modo de paso de puerta única y debe poder alcanzar un estado estable en el inicio.
		El circuito secuencial puede ser iniciado interactivamente o con una puerta de reset.
		No se permite el uso de un componente de reloj en este modo.</string>
  <string name="elem_PowerSupply">Voltaje</string>
  <string name="elem_PowerSupply_tt">No tiene función. Asegurar que VDD y GND estén conectados.
		Puede emplearse en circuitos 74xx para generar los pines para el suministro de corriente y comprobar el cableado correcto.</string>
  <string name="elem_PowerSupply_pin_VDD">¡Debe estar conectado a VDD!</string>
  <string name="elem_PowerSupply_pin_GND">¡Debe estar conectado a GND!</string>
  <string name="elem_Reset">Reset</string>
  <string name="elem_Reset_pin_Reset">Salida de Reset.</string>
  <string name="elem_Reset_tt">La salida de este componete está alta durante la inicialización del circuito.
		Después de que el circuito se ha estabilizado, la salida pasa a bajo.
		Si la salida está invertida, se comporta al contrario.</string>
  <string name="elem_Break">Pausa</string>
  <string name="elem_Break_pin_brk">Detiene la simulación rápida si se detecta un flanco de subida.</string>
  <string name="elem_Break_tt">Si se usa este componente en el circuito, se habilita el botón "Ejecutar hasta un Break", entre "Iniciar" y "Parar"
		Este botón detiene el circuito hasta que se detecta un flanco de subida en la entrada de este componente.
		Este elemento puede usarse para depurar por el reloj el circuito hasta un punto de Break.
		También se puede implementar un comando BRK ensamblador. Esto permite ejecutar un programa hasta el siguiente comando BRK
		Esta función sólo se puede usar si se desactiva el reloj en tiempo real.</string>
  <string name="elem_External">Externo</string>
  <string name="elem_External_tt">Componente para ejecutar un proceso externo para calcular la función lógica.
		Se usa para especificar el comportamiento de un componente con VHDL o Verilog.
		La simulación real del comportamiento debe hacerse con un simulador externo.
		De momento sólo están soportados el simulador GHDL para VHDL, e Icarus Verilog para Verilog.
		¡La etiqueta del componente debe coincidir con el nombre de la entidad o módulo!</string>
  <string name="elem_Diode">Diodo</string>
  <string name="elem_Diode_tt">Diodo bidireccional simplificado Se usa para implementar una puerta AND o una OR.
		Es un diodo ideal: no hay pérdida de voltaje en la polarización directa.</string>
  <string name="error">Error</string>
  <string name="err_N_isNotInputOrOutput">Pin {0} del componente {1} no es una entrada o una salida</string>
  <string name="err_aSingleClockNecessary">Se necesita un componente de reloj. Todos los flip-flops deben usar una señal de reloj.</string>
  <string name="err_analyseNoInputs">Este circuito no tiene entradas etiquetadas.</string>
  <string name="err_analyseNoOutputs">Este circuito no tiene salidas etiquetadas.</string>
  <string name="err_breakTimeOut">Después de {0} ciclos, no se produjo ninguna interrupción en el punto de interrupción ''{1}''.
		Posiblemente el número de ciclos de tiempo muerto en el componente de interrupción deberían incrementarse.</string>
  <string name="err_builder_exprNotSupported">Expresión {0} no soportada.</string>
  <string name="err_builder_operationNotSupported">Operación {0} no soportada.</string>
  <string name="err_builder_couldNotFillLUT">Error creando la tabla de consulta (LUT).</string>
  <string name="err_burnError">Más de una salida está activa en el mismo cable, provocando un cortocircuito.</string>
  <string name="err_pullUpAndDown">No se puede conectar una resistencia pull-up y otra pull-down en la misma red.</string>
  <string name="err_cannotAnalyse_N">No se puede analizar el Nodo {0}</string>
  <string name="err_containsVarAndNotVar">Contiene [var] y [not var]</string>
  <string name="err_duplicatePinLabel">Pin ''{0}'' del componente ''{1}'' duplicado.</string>
  <string name="err_element_N_notFound">Componente {0} no encontrado</string>
  <string name="err_exact_N0_valuesNecessaryNot_N1">Se necesita valor {0} exacto, no {1}</string>
  <string name="err_ffNeedsToBeConnectedToClock">El flip-flop tiene que conectarse al reloj.</string>
  <string name="err_invalidFileFormat">Formato de archivo no válido</string>
  <string name="err_isAlreadyInitialized">La lógica ya está inicializada</string>
  <string name="err_labelNotConnectedToNet_N">¡Un túnel {0} no está conectado!</string>
  <string name="err_moreThanOneClockFound">Hay más de un reloj</string>
  <string name="err_needs_N0_bits_found_N2_bits">Se necesitan {0} bits, pero se han encontrado {1}</string>
  <string name="err_netOfPin_N_notFound">Red del pin {0} no encontrada</string>
  <string name="err_noClockFound">No se ha encontrado reloj en la lógica</string>
  <string name="err_noInputsAvailable">No hay entradas disponibles para fijar</string>
  <string name="err_noShapeFoundFor_N">No hay forma para el componente {0}</string>
  <string name="err_noValueSetFor_N0_atElement_N1">Nada conectado a la entrada ''{0}'' del componente ''{1}''. No se permiten entradas abiertas.</string>
  <string name="err_notAllOutputsSameBits">No todas las salidas conectadas tienen el mismo número de bits</string>
  <string name="err_notAllOutputsSupportHighZ">Si múltiples salidas están conectadas juntas, todas tienen que ser salidas de tres estados.</string>
  <string name="err_noOutConnectedToWire">Ninguna salida conectada a un cable ({0}). El estado del cable es indeterminado.</string>
  <string name="err_oneResultIsRequired">Tabla demasiado pequeña: se necesita un resultado</string>
  <string name="err_output_N_notDefined">Salida {0} no definida</string>
  <string name="err_pinMap_NoNameForPin_N">El pin {0} no tiene etiqueta</string>
  <string name="err_pinMap_Pin_N_AssignedTwicePin">¡El pin {0} ha sido asignado dos veces!</string>
  <string name="err_pinMap_pin_N0_isNotAnInput">¡El pin {0} no es una entrada!</string>
  <string name="err_pinMap_pin_N0_isNotAnOutput">¡El pin {0} no es una salida!</string>
  <string name="err_pinMap_noEqualsfound">¡No se encuentra =!</string>
  <string name="err_pinMap_toMannyInputsDefined">¡Demasiadas entradas!</string>
  <string name="err_pinMap_toMannyOutputsDefined">¡Demasiadas salidas!</string>
  <string name="err_pinNotPresent">Pin ausente</string>
  <string name="err_pinWithoutName">Hay un pin sin etiqueta.</string>
  <string name="err_clockWithoutName">Hay un reloj sin etiqueta. Si un reloj está incrustado, también necesita etiqueta.</string>
  <string name="err_pin_N0_atElement_N1_notFound">Pin {0} no encontrado en el componente {1}</string>
  <string name="err_pin_N_notFound">El pin {0} no se encuentra</string>
  <string name="err_pin_N_unknown">Pin {0} desconocido</string>
  <string name="err_seemsToOscillate">La lógica parece oscilar.
         Para el análisis puedes ejecutar el circuito en modo paso puerta a puerta</string>
  <string name="err_portIsInUse">¡El puerto remoto se está usando! ¿Hay otra instancia en ejecución?</string>
  <string name="err_selectorInputCountMismatch">El número de entradas no coincide con el selector de conteo de bits</string>
  <string name="err_spitterDefSyntaxError">Error de discos en la definición del separador {0}</string>
  <string name="err_splitterBitsMismatch">El recuento de bits del separador no coincide</string>
  <string name="err_splitterNotAllBitsDefined">No todas las entradas están definidas</string>
  <string name="err_splitterNotUnambiguously">Bits de entrada definidos varias veces</string>
  <string name="err_spitterToManyBits">Sólo se permiten 64 bits en el separador</string>
  <string name="err_tableBecomesToSmall">¡Se necesitan dos entradas!</string>
    <string name="err_toManyInputs_max_N0_is_N1">Demasiadas variables (entradas+flip-flops), las permitidas son {0},
        pero
        hay {1}
    </string>
  <string name="err_toManyInputsIn_N0_max_N1_is_N2">Demasiadas variables usadas en {0};
        las permitidas son {1}, pero hay {2}.</string>
  <string name="err_varNotAllowedInCUPL_N">¡La variable {0} no está permitida en una fuente CUPL!</string>
  <string name="err_varNotDefined_N">La variable {0} no está definida</string>
  <string name="err_parserUnexpectedToken_N">Símbolo no esperado {0}</string>
  <string name="err_parserMissingClosedParenthesis">Falta paréntesis de cierre</string>
  <string name="err_notANumber_N0_inLine_N1">¡El valor {0} de la línea {1} no es un número!</string>
  <string name="err_testDataExpected_N0_found_N1_numbersInLine_N2">¡Se esperaban {0}, pero se han encontrado {1} valores en la línea {2}</string>
  <string name="err_unexpectedToken_N0_inLine_N1">Símbolo inesperado ({0}) en la línea {1}.</string>
  <string name="err_variable_N0_notFound">¡Variable {0} no encontrada!</string>
  <string name="err_noTestInputSignalsDefined">¡No hay señales de entrada definidas en el vector de prueba!</string>
  <string name="err_noTestOutputSignalsDefined">¡No hay señales de salida definidas en el vector de prueba!</string>
  <string name="err_noTestData">No hay datos para realizar la prueba.</string>
  <string name="err_pullUpAndDownNotAllowed">No está permitido conectar resistencias de pull-up y pull-down en el mismo cable.</string>
  <string name="err_openingDocumentation">No se puede abrir el explorador.</string>
  <string name="err_couldNotCreateFolder_N0">¡No se pudo crear la carpeta "{0}"!</string>
  <string name="err_switchHasNoNet">No se puede conectar sólo entradas a un conmutador.</string>
  <string name="err_file_N0_ExistsTwiceBelow_N1">El archivo {0} existe múltiples veces bajo {1}.</string>
  <string name="err_couldNotFindIncludedFile_N0">No pude encontrar el archivo {0}.</string>
  <string name="err_postProcessErrorIn_N0">Error durante la ejecución de "{0}".</string>
  <string name="err_processDoesNotTerminate_N">¡El proceso "{0}" no devuelve nada!</string>
  <string name="err_processExitedWithError_N1_N2">El proceso devuelve el valor no cero {0}: {1}</string>
  <string name="err_errorRunningFitter">¡Error iniciando el adaptador externo!</string>
  <string name="err_noExpressionsAvailable">¡No hay ecuaciones minimizadas!</string>
  <string name="msg_optimizationInProgress">¡Ecuaciones calculadas! ¡Espera un momento, por favor!</string>
  <string name="err_varName_N_UsedTwice">¡La variable {0} se usa dos veces!</string>
  <string name="err_fileNeedsToBeSaved">¡Tienes que guardar el archivo!</string>
  <string name="err_recursiveNestingAt_N0">¡El circuito {0} se importa a sí mismo!</string>
  <string name="err_minimizationFailed">¡El resultado de la minimización no es correcto!
		Puede que los nombres de las variables no sean únicos.</string>
  <string name="err_toManyIterations">Demasiadas iteraciones en un bucle.</string>
  <string name="err_diodeNeedsPullUpResistorAtOutput">¡El diodo necesita una resistencia pull-up en su salida!</string>
  <string name="err_diodeNeedsPullDownResistorAtOutput">¡El diodo necesita una resistencia pull-down en su salida!</string>
  <string name="err_testSignal_N_notFound">¡No se ha encontrado la señal de prueba {0} en el circuito!</string>
  <string name="err_toManyBits_Found_N0_maxIs_N1">¡Sólo se permiten {1} bits, pero se han encontrado {0}!</string>
  <string name="err_MultiBitFlipFlopFound">¡Flip-flops con más de un bit no están permitidos!</string>
  <string name="err_invalidTransmissionGateState">¡Las dos entradas de control de una puerta de transmisión deben estar invertidas!</string>
  <string name="err_nameUsedTwice_N">¡La señal {0} se usa dos veces!</string>
  <string name="err_errorParsingTestdata">Error al analizar los datos de prueba.</string>
  <string name="err_backtrackOf_N_isImpossible">El componente modelo {0} no puede analizarse.</string>
  <string name="err_errorInPowerSupply">Error en el cableado de la fuente de alimentación en {0}.</string>
  <string name="err_pinIsNotANumber_N">¡El número del pin {0} no es un entero!</string>
  <string name="err_vhdlExporting">Error en la exportación a  VHDL.</string>
  <string name="err_vhdlNoEntity_N">¡No hay código VHDL disponible para {0}!</string>
  <string name="err_verilogNoElement_N">¡No hay código Verilog disponible para {0}!</string>
  <string name="err_vhdlErrorWritingTestBench">¡Error en la creación del módulo de estímulo (test bench)!</string>
  <string name="err_vhdlValuesOfType_N_notAllowed">¡Los valores del tipo {0} no están permitidos!</string>
  <string name="err_vhdlANameIsMissing">Falta un nombre. Por ejemplo: ¿tienen todos los pines una etiqueta?</string>
  <string name="err_toManyVars">¡Demasiadas variables!</string>
  <string name="err_invalidExpression">¡Expresión incorrecta!</string>
  <string name="err_function_N0_notFoundInLine_N1">¡Función {0} no encontrada en la línea {1}!</string>
  <string name="err_wrongNumOfArgsIn_N0_InLine_N1_found_N2_expected_N3">El número de argumentos en la función {0} de la línea {1} no es correcto.
		¡Se encontraron {2}, y se esperaban {3}!</string>
  <string name="err_invalidValue_N0_inFunction_N1">Valor incorrecto {0} en la función {1}!</string>
  <string name="err_Node_N_isAComponent">El nombre {0} no está en la ruta.</string>
  <string name="err_loadingLibrary">Error durante la carga de una biblioteca.</string>
  <string name="err_noManifestFound">¡El archivo JAR no contiene manifiesto!</string>
  <string name="err_noMainFoundInManifest">¡El manifiesto no contiene una entrada de Main-Class!</string>
  <string name="err_mainClass_N_NotFound">¡No se pudo encontrar la clase {0}!</string>
  <string name="err_couldNotInitializeMainClass_N">¡No pudo instanciarse la clase {0}!</string>
  <string name="err_notMoreOutBitsThanInBits">¡Tiene que haber más bits de entrada que de salida!</string>
  <string name="err_constantsNotAllowed">¡No es posible asignar pines físicos a valores constantes!</string>
  <string name="err_invalidNumberFormat_N_N">¡La cadena {0} no es un número válido (pos {1})!</string>
  <string name="err_invalidPinName_N">!El nombre "{0}" no está permitido!</string>
  <string name="err_whiteSpaceNotAllowedInTT2Name">¡No se permiten espacios en blanco en el nombre de un archivo TT2!</string>
  <string name="err_tableHasToManyResultColumns">¡La tabla tiene demasiadas columnas!</string>
  <string name="err_errorExportingZip">Error creando el archivo ZIP.</string>
  <string name="err_moreThanOneFastClock">Sólo se permite un componente de reloj con alta frecuencia.</string>
  <string name="err_circuitHasCycles">El circuito contiene ciclos. No es posible analizar analizar tal circuito.
		Un ciclo aparece si la salida de una puerta realimenta una de los entradas de la misma puerta.
		El uso de interruptores, FET o relé también provoca ciclos.</string>
  <string name="err_monoflopRequiresOneClock">Si se usa un monoestable, ¡debe haber exactamente un componente de reloj!</string>
  <string name="err_couldNotCreateElement_N">¡No se pudo crear un componente del tipo {0}!</string>
  <string name="err_centralDefinedRomsAreNotSupported">¡Las ROM definidas en la configuración no son soportadas!</string>
  <string name="err_namesAreNotUnique_N">¡El nombre "{0}" no es único!</string>
  <string name="err_errorWritingDataToProcess">¡No pudieron escribirse valores en el proceso externo!</string>
  <string name="err_errorReadingDataFromProcess">¡No pudieron leerse valores del proceso externo!</string>
  <string name="err_errorCreatingProcess">¡No pudo crearse el proceso externo!</string>
  <string name="err_timeoutReadingData_O">¡Tiempo muerto leyendo datos del proceso externo!
		{0}</string>
  <string name="err_notEnoughDataReceived_O">¡No se han recibido datos suficientes!
		{0}</string>
  <string name="err_invalidCharacterReceived_N_O">¡El texto recibido contiene un carácter no válido: {0}!
		{1}</string>
  <string name="err_processTerminatedUnexpected_O">¡El proceso finalizó de forma inesperada!
		{0}</string>
  <string name="err_couldNotTerminateProcess">¡No se pudo finalizar el proceso!</string>
  <string name="err_couldNotStartProcess_N">No se pudo iniciar el proceso: {0}</string>
  <string name="err_exitValueNotNull_N_O">El estado de salida de la aplicación no era cero, sino {0}:
		{1}</string>
  <string name="err_canOnlyExportExternalVHDL">¡El código externo sólo se puede exportar si es VHDL!</string>
  <string name="err_canOnlyExportExternalVerilog">¡El código externo sólo se puede exportar si es Verilog!</string>
  <string name="err_ifExternalComponentIsUsedTwiceCodeMustBeIdentical_N">¡Si un componente externo se usa múltiples veces, el código debe ser idéntico! Efectos: {0}</string>
  <string name="err_writingToStdOut_O">No se pudo escribir en stdOut:
		{0}</string>
  <string name="err_ghdlNotInstalled">El simulador de VHDL, GHDL, parece no estar instalado. Instale GHDL (http://ghdl.free.fr/) y pruebe de nuevo. Si todavía hay problemas, compruebe la ruta del ejecutable de GHDL en la configuración de Digital.</string>
  <string name="err_iverilogNotInstalled">El simulador de Verilog, Icarus, parece no estar instalado. Instale Verilog (http://iverilog.icarus.com) y pruebe de nuevo. Si todavía hay problemas, compruebe la ruta del ejecutable de iVerilog en la configuración de Digital.</string>
  <string name="err_errorAnalysingCircuit_N">Error analizando el circuito: {0}</string>
  <string name="err_romNeedsALabelToBeExported">¡Todas las ROM necesitan una etiqueta específica para ser exportadas!</string>
  <string name="err_lutNeedsALabelToBeExported">¡Todas las tablas de consulta (LUT) necesitan una etiqueta específica para ser exportadas!</string>
  <string name="err_counterNeedsMoreBits">El contador precisa al menos dos bits.</string>
  <string name="err_clocksNotAllowedInAsyncMode">Los elementos reloj no se pueden usar en modo asíncrono.</string>
  <string name="err_verilogExporting">Error en la exportación a Verilog.</string>
  <string name="err_noRomFound">¡No se encontró memoria para el programa! La memoria para el programa necesita estar etiquetada como tal.</string>
  <string name="err_errorLoadingRomData">Error en la carga de la memoria del programa.</string>
  <string name="err_parsingSVG">Error en la lectura del archivo SVG.</string>
  <string name="err_morePinsDefinedInSVGAsNeeded">El archivo SVG contiene pines que no existen en el circuito.</string>
  <string name="err_allMemoriesNeedToHaveTheSameByteWidth">Todas las memorias en las que se van a cargar datos necesitan el mismo tamaño de bits.</string>
  <string name="err_ProgMemLabelsNotDifferent">Si los programas se van a cargar en varias RAMs, cada una debe tener un nombre diferente.
		El orden de las RAMs se establece alfabéticamente.</string>
  <string name="err_midiSystemNotAvailable">El MIDI del sistema no está disponible.</string>
  <string name="err_midiChannel_N_NotAvailable">El canal MIDI {0} no está disponible.</string>
  <string name="err_midiInstrument_N_NotAvailable">El instrumento MIDI {0} no está disponible.</string>
  <string name="err_midiInstrumentsNotAvailable">Los instrumentos MIDI no están disponibles.</string>
  <string name="err_whileExecutingTests_N0">¡Ocurrió un error durante la ejecución de los tests "{0}"!</string>
  <string name="key_AddrBits">Bits de dirección</string>
  <string name="key_AddrBits_tt">Número de bits de dirección empleados.</string>
  <string name="key_Bits">Bits de datos</string>
  <string name="key_Bits_tt">Número de bits de datos empleados.</string>
  <string name="key_Color">Color</string>
  <string name="key_Color_tt">Color del elemento.</string>
  <string name="key_backgroundColor">Color del fondo</string>
  <string name="key_backgroundColor_tt">El color del fondo del circuito cuando se incrusta en otro circuito. No se emplea para empaquetados DIL.</string>
  <string name="key_Cycles">Ciclos de tiempos muertos</string>
  <string name="key_Cycles_tt">Si dicha cantidad de ciclos se alcanza sin señal de pausa, se crea un error.</string>
  <string name="key_Data">Datos</string>
  <string name="key_Data_tt">Valores almacenados en este elemento.</string>
  <string name="key_Default">Por defecto</string>
  <string name="key_Default_tt">Este valor se fija si se inicia el circuito.
		En el demultiplexor, este valor se fija para las salidas no seleccionadas.</string>
  <string name="key_InDefault">Por defecto</string>
  <string name="key_InDefault_tt">Este valor se fija si el circuito arranca. Una "Z" significa "estado de alta impedancia".</string>
  <string name="key_isHighZ">Es una entrada de tres estados</string>
  <string name="key_isHighZ_tt">Si se marca, la entrada tendrá permitido estar en estado de alta impedancia. En un elemento de entrada,
		esto se permite si el estado de alta impedancia se fija como valor por defecto.</string>
  <string name="key_avoidActiveLow">Salida no cero.</string>
  <string name="key_avoidActiveLow_tt">Evita la salida cero. Esto es especialmente útil cuando se configura circuitos de relés.
		Se puede activar sólo si se permite una salida de alta impedancia.</string>
  <string name="key_Description">Descripción</string>
  <string name="key_Description_tt">Breve descripción del elemento y su uso.</string>
  <string name="key_Frequency">Frecuencia/Hz</string>
  <string name="key_Frequency_tt">La frecuencia en tiempo real empleada para el reloj real.</string>
  <string name="key_IEEEShapes">Usa las formas IEEE 91-1984</string>
  <string name="key_IEEEShapes_tt">Usa las formas IEEE 91-1984 en lugar de formas rectangulares</string>
  <string name="key_Inputs">Número de entradas</string>
  <string name="key_Inputs_tt">Cantidad de entradas usada. Cada entrada tiene que estar conectada.</string>
  <string name="key_Label">Etiqueta</string>
  <string name="key_Label_tt">Nombre de este elemento.</string>
  <string name="key_Size">Tamaño</string>
  <string name="key_Size_tt">Tamaño de la forma en el circuito.</string>
  <string name="key_Language">Idioma</string>
  <string name="key_Language_tt">Idioma de la interfaz. Sólo tendrá efecto tras reiniciar.</string>
  <string name="key_NetName">Nombre de la red</string>
  <string name="key_NetName_tt">Todas las redes con el mismo nombre están conectadas entre sí.</string>
  <string name="key_InputSplitting">División de las entradas</string>
  <string name="key_InputSplitting_tt">Si, por ejemplo, tenemos cuatro bits, dos bits y otros dos más que se van a usar como entradas,
		esto puede configurarse con "4,2,2". El número indica la cantidad de bits.
		Por conveniencia, puede emplearse el asterisco: 16 bits puede configurarse con "[Bits]*[Número]" como "1*16".
		También es posible especificar los bits que se van a usar directamente en cualquier orden.
		Por ejemplo, "4-7,0-3" configura los bits 4-7 y 0-3. Esta notación permite cualquier disposición de los bits.</string>
  <string name="key_OutputSplitting">División de la salida</string>
  <string name="key_OutputSplitting_tt">Si, por ejemplo, tenemos cuatro bits, dos bits y otros dos más van a emplearse como salidas,
		esto puede configurarse con "4,2,2". El número indica la cantidad de bits.
		Por conveniencia, puede usarse también el asterisco: 16 bits puede configurarse con "[Bits]*[Número]" como "1*16".
		También es posible indicar los bits que se van a usar en cualquier orden.
		Por ejemplo, "4-7,0-3" configura los bits 4-7 y 0-3. Esta notación permite cualquier disposición de los bits.
		Los bits de salida pueden usarse varias veces: "0-7,1-6,4-7".</string>
  <string name="key_SelectorBits">Número de los bits del selector</string>
  <string name="key_SelectorBits_tt">Número de bits empleados para el selector de entrada.</string>
  <string name="key_Signed">Operación con signo</string>
  <string name="key_Signed_tt">Si está seleccionado, la operación se hace con valores con signo (complemento a 2).</string>
  <string name="key_Closed">Cerrado</string>
  <string name="key_Closed_tt">Fija el estado inicial del conmutador.</string>
  <string name="key_Value">Valor</string>
  <string name="key_Value_tt">Valor de la constante.</string>
  <string name="key_Width">Anchura</string>
  <string name="key_Width_tt">Anchura del símbolo si el circuito se usa como componente en otro circuito.</string>
  <string name="key_Height">Altura</string>
  <string name="key_Height_tt">Altura del símbolo si el circuito se emplea como componente en otro circuito.</string>
  <string name="key_autoReload">Recargar al iniciar el modelo</string>
  <string name="key_autoReload_tt">Recarga el archivo HEX cada vez que el modelo se ejecuta.</string>
  <string name="key_flipSelPos">Cambia la posición del selector</string>
  <string name="key_flipSelPos_tt">Esta opción te permite mover el pin del selector al otro lado del plexor.</string>
  <string name="key_intFormat">Formato de número</string>
  <string name="key_intFormat_tt">El formato se emplea para mostrar los números.</string>
  <string name="key_intFormat_ascii">ASCII</string>
  <string name="key_intFormat_bin">Binario</string>
  <string name="key_intFormat_dec">Decimal</string>
  <string name="key_intFormat_decSigned">Decimal con signo</string>
  <string name="key_intFormat_def">Por defecto</string>
  <string name="key_intFormat_hex">Hexadecimal</string>
  <string name="key_barrelSigned">La entrada de desplazamiento tiene signo</string>
  <string name="key_barrelSigned_tt">La entrada de desplazamiento tiene formato complemento a 2</string>
  <string name="key_barrelShifterMode">Modo</string>
  <string name="key_barrelShifterMode_tt">Modo del registro de desplazamiento</string>
  <string name="key_barrelShifterMode_logical">Lógico</string>
  <string name="key_barrelShifterMode_rotate">Girar</string>
  <string name="key_barrelShifterMode_arithmetic">Aritmético</string>
  <string name="key_direction">Dirección</string>
  <string name="key_direction_tt">Fijar dirección.</string>
  <string name="key_direction_left">izquierda</string>
  <string name="key_direction_right">derecha</string>
  <string name="key_maxStepCount">Número máximo de pasos que mostrar</string>
  <string name="key_maxStepCount_tt">Máximo número de valores almacenados.
		Si el máximo se alcanza, se descartan los valores más viejos.</string>
  <string name="key_microStep">Mostrar pasos de puerta individual</string>
  <string name="key_microStep_tt">Muestra todos los pasos de puerta simple en el gráfico.</string>
  <string name="key_rotation">Rotación</string>
  <string name="key_rotation_tt">Orientación del elemento en el circuito.</string>
  <string name="key_runRealTime">Iniciar el reloj de tiempo real</string>
  <string name="key_runRealTime_tt">Si está habilitado, el reloj de simulación comienza cuando el circuito arranca</string>
  <string name="key_showDataGraph">Mostrar la barra de medida al comienzo de la simulación</string>
  <string name="key_showDataGraph_tt">Cuando empieza la simulación, se muestra un gráfico con los valores medidos.</string>
  <string name="key_showDataGraphMicro">Muestra gráfica de medidas en el modo puerta única al comienzo de la simulación</string>
  <string name="key_showDataGraphMicro_tt">Cuando comienza la simulación, se muestra un gráfico con los valores medidos en el modo paso de puerta</string>
  <string name="key_showDataTable">Muestra valores medidos al comenzar la simulación</string>
  <string name="key_showDataTable_tt">Cuando empieza la simulación, se muestra una tabla con los valores medidos</string>
  <string name="key_termHeight">Líneas</string>
  <string name="key_termHeight_tt">Número de líneas que se mostrarán.</string>
  <string name="key_termWidth">Caracteres por línea</string>
  <string name="key_termWidth_tt">Número de caracteres mostrados en una línea.</string>
  <string name="key_valueIsProbe">Usar como valor de medida</string>
  <string name="key_valueIsProbe_tt">Si se marca, el valor es un valor de medida, y aparece en la tabla de datos y el gráfico.
		Además, debe especificarse una etiqueta que sirva como identificación del valor.</string>
  <string name="key_Testdata">Datos de prueba</string>
  <string name="key_Testdata_tt">Descripción de los valores de prueba.
		Pueden encontrarse detalles de la sintaxis en el diálogo de ayuda del editor de datos de prueba.</string>
  <string name="key_graphicWidth">Anchura en píxeles</string>
  <string name="key_graphicWidth_tt">Anchura de la pantalla en píxeles.</string>
  <string name="key_graphicHeight">Altura en píxeles</string>
  <string name="key_graphicHeight_tt">Altura de la pantalla en píxeles.</string>
  <string name="key_isProgramMemory">Memoria del programa</string>
  <string name="key_isProgramMemory_tt">Convierte a esta ROM a memoria de programa. Por ello podrá accederse a ella desde un IDE externo.</string>
  <string name="key_isProgramCounter">Contador de programa</string>
  <string name="key_isProgramCounter_tt">Hace de este registro un contador de programa El valor de este registro es devuelto
		al IDE ensamblador externo para marcar la línea actual de código durante la depuración.</string>
  <string name="key_Blown">Programado</string>
  <string name="key_Blown_tt">Si se marca, el diodo estará "flotante" o "programado".
		En un FET de puerta flotante, ésta estará cargada.
      Puedes cambiar este ajuste con la tecla "p".
  </string>
    <string name="key_ExpressionFormat">Formato</string>
    <string name="key_ExpressionFormat_tt">Formato en pantalla de las expresiones.</string>
    <string name="key_relayNormallyClosed">El relé está normalmente cerrado.</string>
    <string name="key_relayNormallyClosed_tt">Si se marca, el relé estará cerrado si la entrada es baja.</string>
    <string name="key_poles">Contar contactos</string>
    <string name="key_poles_tt">Cantidad de contactos disponibles</string>
    <string name="key_commonCathode">Conexión común</string>
    <string name="key_commonCathode_tt">Si está seleccionado, se simula la entrada de ánodo o cátodo común</string>
    <string name="key_ledPersistence">Evitar el parpadeo</string>
    <string name="key_ledPersistence_tt">No se puede incrementar la frecuencia tanto como para que desaparezca el
        parpadeo.
        Sin embargo, para suprimir el parpadeo, se puede activar "afterglow" para los ledes con esta opción.
        Si está activado, los ledes permanecen encendidos, incluso si uno de los pines cambia a "alta impedancia".
        Esto simula una frecuencia por encima de la frecuencia crítica de parpadeo.
    </string>
    <string name="key_atf1502Fitter">Adaptador ATF15xx</string>
    <string name="key_atf1502Fitter_tt">Ruta al adaptador para el ATF15xx.
        Introduce la carpeta que contiene el archivo fit15xx.exe proporcionado por Microchip (antigua ATMEL).
    </string>
    <string name="key_pin">Número de pin</string>
    <string name="key_pin_tt">Un campo vacío indica que esta señal no está asignada a un pin.</string>
    <string name="key_rowDataBits">Filas</string>
    <string name="key_rowDataBits_tt">Especifica el número de filas indicando el número de bits de la palabra que la
        designa.
    </string>
    <string name="key_colAddrBits">Bits de dirección de las columnas</string>
    <string name="key_colAddrBits_tt">Direcciona columnas individuales. Tres bits indican ocho columnas.</string>
  <string name="key_lockedMode">Modificación bloqueada</string>
  <string name="key_lockedMode_tt">El circuito está bloqueado. Es posible configurar diodos y FGF-FETs.</string>
  <string name="key_pinNumber">Número de pin</string>
  <string name="key_pinNumber_tt">Número de este pin. Se usa para la representación de un circuito como encapsulado DIL y
		la asignación de pines cuando se programa un CPLD.
		Si hay varios bits, todos los números de pines deben especificarse en una lista separada por comas.</string>
  <string name="key_pinCount">Número de pines DIL</string>
  <string name="key_pinCount_tt">Número de pines. Cero indica que el número de pines se calcula automáticamente</string>
  <string name="key_defTreeSelect">Vista árbol de componentes visible en el inicio</string>
  <string name="key_defTreeSelect_tt">Marcado, la vista de árbol de componentes es visible en el inicio</string>
  <string name="key_inverterConfig">Salidas invertidas</string>
  <string name="key_inverterConfig_tt">Puedes seleccionar las entradas que estarán invertidas</string>
  <string name="key_fontSize">Tamaño de la fuente de los menús</string>
  <string name="key_fontSize_tt">Tamaño de las fuentes usadas en el menú en % del tamaño por defecto</string>
  <string name="key_withEnable">Habilita la entrada</string>
  <string name="key_withEnable_tt">Si se marca, se dispondrá de una entrada de habilitación (T).</string>
  <string name="key_unidirectional">Unidireccional</string>
  <string name="key_unidirectional_tt">Los transistores unidireccionales propagan una señal sólo de la fuente al drenaje.
		Son mucho más rápidos de simular que los bidireccionales. Puesto que no hay realimentación del drenaje a la fuente,
		los transistores no cortocircuitan cables al conducir.
		Este modo es necesario en algunos circuitos CMOS.</string>
  <string name="key_activeLow">Activo a 0</string>
  <string name="key_activeLow_tt">Si se marca, la salida es baja si el componente está activo.</string>
  <string name="key_libraryPath">Biblioteca</string>
  <string name="key_libraryPath_tt">Carpeta que contiene la biblioteca de subcircuitos predefinida.
		Contiene, por ejemplo, los componentes de la serie 74xx.
		También puedes añadir tus circuitos guardándolos en esta ubicación.</string>
  <string name="key_grid">Mostrar rejilla</string>
  <string name="key_grid_tt">Muestra una rejilla en la ventana principal.</string>
  <string name="key_mapToKey">Controlar con el teclado</string>
  <string name="key_mapToKey_tt">El botón se controla con el teclado.
		Para usar las flechas del teclado, usa ARRIBA, ABAJO, IZQUIERDA o DERECHA como etiquetas.</string>
  <string name="key_jarPath">Biblioteca Java</string>
  <string name="key_jarPath_tt">Archivo .jar con componentes adicionales implementado en Java.</string>
  <string name="key_showWireBits">Muestra el número de cables de un bus.</string>
  <string name="key_showWireBits_tt">ATENCIÓN: el valor se actualiza sólo cuando empieza la simulación.</string>
  <string name="key_inputBits">Introduce anchura de bit</string>
  <string name="key_inputBits_tt">El número de bits de salida debe ser mayor que el de bits de entrada.</string>
  <string name="key_outputBits">Anchura del bit de salida</string>
  <string name="key_outputBits_tt">El número de bits de salida debe ser mayor que el de bits de entrada.</string>
  <string name="key_textFontSize">Tamaño de fuente</string>
  <string name="key_textFontSize_tt">Fija el tamaño de fuente que se usará para el texto.</string>
  <string name="key_delayTime">Duración</string>
  <string name="key_delayTime_tt">Tiempo de demora en unidades de retraso de propagación de puertas.</string>
  <string name="key_invertOutput">salida invertida</string>
  <string name="key_invertOutput_tt">Si se marca, la salida estará invertida.</string>
  <string name="key_timerDelay">Anchura de pulso</string>
  <string name="key_timerDelay_tt">La anchura de pulso se mide en ciclos de reloj.</string>
  <string name="key_splitterSpreading">Propagación</string>
  <string name="key_splitterSpreading_tt">Configura la propagación de las entradas y salidas del circuito.</string>
  <string name="key_romContent">Contenido de la ROM</string>
  <string name="key_romContent_tt">Contenido de todas las ROMs empleadas.</string>
  <string name="key_applicationType">Aplicación</string>
  <string name="key_applicationType_tt">Indica qué aplicación usar.</string>
  <string name="key_applicationType_Generic">Genérica</string>
  <string name="key_applicationType_GHDL">GHDL</string>
  <string name="key_applicationType_IVERILOG">iVerilog</string>
  <string name="key_externalInputs">Entradas</string>
  <string name="key_externalInputs_tt">Entradas del proceso externo.
		Es una lista de nombres de señales separadas por comas. Para cada nombre de señal, usando ":", puede indicarse
		el número de bits. Las entradas de un sumador de 8 bits podrían, por ejemplo, describirse como "a:8,b:8;C_in".</string>
  <string name="key_externalOutputs">Salidas</string>
  <string name="key_externalOutputs_tt">Salidas de un proceso externo.
		Es una lista de nombres de señales separadas por comas. Para cada nombre de señal, usando ":", puede indicarse
		el número de bits. Las salidas de un sumador de 8 bits podrían describirse, por ejemplo, como "s:8,C_out".</string>
  <string name="key_Code">Código del programa</string>
  <string name="key_Code_tt">Código del programa que va a ejecutar la aplicación externa.</string>
  <string name="key_ghdlPath">GHDL</string>
  <string name="key_ghdlPath_tt">Ruta al archivo ejecutable de GHDL. Sólo es necesario si utilizas GHDL para simular
		componentes definidos con VHDL.</string>
  <string name="key_iverilogPath">iVerilog</string>
  <string name="key_iverilogPath_tt">Ruta a la carpeta de instalación de Icarus Verilog. Sólo es necesaria si quieres usar iVerilog para simular
		componentes definidos con Verilog.</string>
  <string name="key_maxValue">Valor máximo</string>
  <string name="key_maxValue_tt">Si se introduce un ero, se utilizará el valor máximo (todos los bits serán uno).</string>
  <string name="key_dipDefault">Salida alta</string>
  <string name="key_dipDefault_tt">El valor de salida por defecto del conmutador DIP cuando empieza la simulación.</string>
  <string name="key_macMouse">Usa los clics de ratón de MacOS.</string>
  <string name="key_macMouse_tt">Usa CTRL-clic en lugar de clic derecho.</string>
  <string name="key_ATMISP">ATMISP</string>
  <string name="key_ATMISP_tt">Ruta al archivo ejecutable ATMISP.exe. Si se marca, el software ATMISP puede iniciarse automáticamente.</string>
  <string name="key_customShape">Forma personalizada</string>
  <string name="key_customShape_tt">Importación de un archivo SVG</string>
  <string name="key_preloadProgram">Precarga la memoria del programa al comienzo.</string>
  <string name="key_preloadProgram_tt">Cuando se simula un procesador que emplea una RAM como memoria del programa,
		es difícil iniciar este procesador, porque el contenido de la RAM está siempre inicializado con ceros al comienzo
		de la simulación. Este ajuste permite cargar los datos en la memoria del programa al comienzo.
		La memoria del programa en la simulación debe también estar marcada.</string>
  <string name="key_preloadProgramFile">Archivo de programa</string>
  <string name="key_preloadProgramFile_tt">Archivo que debería cargarse en la memoria del programa al comienzo de la simulación.</string>
  <string name="key_RectWidth">Anchura</string>
  <string name="key_RectWidth_tt">Anchura en unidades de rejilla</string>
  <string name="key_RectHeight">Altura</string>
  <string name="key_RectHeight_tt">Altura en unidades de rejilla</string>
  <string name="key_RectInside">Texto interior</string>
  <string name="key_RectInside_tt">Coloca texto dentro del rectángulo.</string>
  <string name="key_RectBottom">Texto al pie</string>
  <string name="key_RectBottom_tt">Coloca texto al pie del rectángulo.</string>
  <string name="key_RectRight">Texto a la derecha</string>
  <string name="key_RectRight_tt">Coloca texto a la derecha del rectángulo.</string>
  <string name="key_wideShape">Anchura de la forma</string>
  <string name="key_wideShape_tt">Emplea una forma más ancha para visualizar la puerta.</string>
  <string name="key_shapeType">Forma</string>
  <string name="key_shapeType_tt">La forma que se va a usar para la representación del circuito en un circuito incrustado.
		En el modo "Simple", las entradas se muestran a la izquierda y las salidas a la derecha de un rectángulo simple.
		Con "Diseño", la posición de las entradas y las salidas y su orientación en el circuito determinan
		la posición de los pines. En esta opción puede haber pines arriba o abajo también.
		Cuando se selecciona "Chip DIL", se empleará una máscara DIL para mostrar el circuito.
		El número de pines de las entradas y las salidas determinarán la posición de los pines en este caso.</string>
  <string name="key_shapeType_DEFAULT">Por defecto</string>
  <string name="key_shapeType_SIMPLE">Simple</string>
  <string name="key_shapeType_DIL">Chip DIL</string>
  <string name="key_shapeType_LAYOUT">Diseño</string>
  <string name="key_shapeType_CUSTOM">Definida por el usuario</string>
  <string name="key_textOrientation">Orientación</string>
  <string name="key_textOrientation_tt">Posición del texto en coordenadas relativas.</string>
  <string name="key_textOrientation_LEFTBOTTOM">Izquierda Abajo</string>
  <string name="key_textOrientation_CENTERBOTTOM">Centro Abajo</string>
  <string name="key_textOrientation_RIGHTBOTTOM">Derecha Abajo</string>
  <string name="key_textOrientation_RIGHTCENTER">Derecha Centro</string>
  <string name="key_textOrientation_RIGHTTOP">Derecha Arriba</string>
  <string name="key_textOrientation_CENTERTOP">Centro Arriba</string>
  <string name="key_textOrientation_LEFTTOP">Izquierda Arriba</string>
  <string name="key_textOrientation_LEFTCENTER">Izquierda Centro</string>
  <string name="key_textOrientation_CENTERCENTER">Centro Centro</string>
  <string name="key_midiChannel">Canal MIDI</string>
  <string name="key_midiChannel_tt">Selecciona el canal MIDI que se va a usar.</string>
  <string name="key_midiInstrument">Instrumento MIDI</string>
  <string name="key_midiInstrument_tt">Instrumento MIDI que se va a usar.</string>
  <string name="key_midiProgChange">Permitir cambio en el programa</string>
  <string name="key_midiProgChange_tt">Añade una nueva entrada. Si esta entrada está a alto,
		el valor en la entrada N se usará para cambiar el programa (instrumento).</string>
  <string name="mod_insertWire">Cable añadido.</string>
  <string name="mod_insertCopied">Pegar desde portapapeles</string>
  <string name="mod_setKey_N0_in_element_N1">Valor ''{0}'' en el componente ''{1}'' modificado.</string>
  <string name="mod_setAttributesIn_N">Propiedades del componente ''{0}'' modificadas.</string>
  <string name="mod_wireDeleted">Cable borrado.</string>
  <string name="mod_movedOrRotatedElement_N">Componente ''{0}'' movido o girado.</string>
  <string name="mod_movedWire">Cable movido.</string>
  <string name="mod_deletedSelection">Se ha borrado la selección.</string>
  <string name="mod_insertedElement_N">Componente ''{0}'' incluido.</string>
  <string name="mod_deletedElement_N">Componente ''{0}'' borrado.</string>
  <string name="mod_insertedWire">Cable añadido</string>
  <string name="mod_movedSelected">Selección desplazada.</string>
  <string name="mod_undo_N">Deshacer: {0}</string>
  <string name="mod_redo_N">Rehacer: {0}</string>
  <string name="mod_circuitAttrModified">Propiedades del circuito modificadas.</string>
  <string name="mod_modifiedMeasurementOrdering">Medidas ordenadas.</string>
  <string name="mod_groupEdit">Propiedades de los componentes seleccionados modificadas.</string>
  <string name="mod_splitWire">Divide un cable en dos.</string>
  <string name="lib_Logic">Lógica</string>
  <string name="lib_arithmetic">Aritmética</string>
  <string name="lib_flipFlops">Flip-Flops</string>
  <string name="lib_io">Entrada-Salida</string>
  <string name="lib_memory">Memorias</string>
  <string name="lib_mux">Plexores</string>
  <string name="lib_wires">Cables</string>
  <string name="lib_switching">Interruptores</string>
  <string name="lib_misc">Varios</string>
  <string name="lib_more">Más</string>
  <string name="lib_ram">RAM</string>
  <string name="lib_eeprom">EEPROM</string>
  <string name="menu_window">Ventana</string>
  <string name="menu_about">Acerca de</string>
  <string name="menu_analyse">Análisis</string>
  <string name="menu_analyse_tt">Analiza el circuito actual</string>
  <string name="menu_cut">Cortar</string>
  <string name="menu_copy">Copiar</string>
  <string name="menu_custom">Personalizado</string>
  <string name="menu_library">Biblioteca</string>
  <string name="menu_delete">Borrar componentes</string>
  <string name="menu_delete_tt">Borra el componente seleccionado o un grupo de componentes</string>
  <string name="menu_edit">Editar</string>
  <string name="menu_editAttributes">Ajustes específicos del circuito</string>
  <string name="menu_editAttributes_tt">Los ajustes específicos del circuito afectan al comportamiento del circuito que está abierto.
		Así, por ejemplo, la forma que representa al circuito cuando se incrusta en otros.
		Estos ajustes se almacenan junto al circuito.</string>
  <string name="menu_editSettings">Ajustes</string>
  <string name="menu_editSettings_tt">Los ajustes globales del simulador especifican, entre otras cosas, el idioma, los símbolos que se van a usar
		o las rutas de las herramientas externas.</string>
  <string name="menu_element">Parar la simulación</string>
  <string name="menu_element_tt">Para la simulación y permite editar el circuito</string>
  <string name="menu_elements">Componentes</string>
  <string name="menu_export">Exportar</string>
  <string name="menu_exportPNGLarge">Exportar PNG grande</string>
  <string name="menu_exportPNGSmall">Exportar PNG pequeño</string>
  <string name="menu_exportSVG">Exportar SVG</string>
  <string name="menu_exportAnimatedGIF">Exportar GIF animado</string>
  <string name="menu_fast">Ejecutar hasta un Break</string>
  <string name="menu_fast_tt">Ejecuta el circuito hasta que un componente BRK detecta un break.</string>
  <string name="menu_file">Archivo</string>
  <string name="menu_help">Ayuda</string>
  <string name="menu_update">Actualizar</string>
  <string name="menu_update_tt">Actualiza el menú de componentes.</string>
  <string name="menu_maximize">Ajusta a la ventana</string>
  <string name="menu_micro">Paso a paso puerta sencilla</string>
  <string name="menu_micro_tt">Ejecuta el circuito en modo de puerta sencilla</string>
  <string name="menu_new">Nuevo</string>
  <string name="menu_new_tt">Crea un circuito nuevo</string>
  <string name="menu_newSub">Nuevo circuito incrustado</string>
  <string name="menu_newSub_tt">Abre una ventana nueva para crear un circuito incrustado que puede usarse en este circuito.</string>
  <string name="menu_open">Abrir</string>
  <string name="menu_openRecent">Abrir reciente</string>
  <string name="menu_openRecentNewWindow">Abrir reciente en ventana nueva</string>
  <string name="menu_openWin">Abrir en ventana nueva</string>
  <string name="menu_openWin_tt">Abre un circuito en una ventana nueva</string>
  <string name="menu_orderInputs">Ordenar las entradas</string>
  <string name="menu_orderInputs_tt">Ordena las entradas para usar el circuito en modo incrustado</string>
  <string name="menu_orderMeasurements">Ordenar los valores de las medidas</string>
  <string name="menu_orderMeasurements_tt">Ordena los valores de las medidas en la gráfica y en la vista de tabla.</string>
  <string name="menu_orderOutputs">Ordena las salidas</string>
  <string name="menu_orderOutputs_tt">Ordena las salidas para usar el circuito en modo incrustado.</string>
  <string name="menu_paste">Pegar</string>
  <string name="menu_rotate">Girar</string>
  <string name="menu_sim">Simulación</string>
  <string name="menu_run">Inicio de la simulación</string>
  <string name="menu_run_tt">Inicia la simulación del circuito</string>
  <string name="menu_save">Guardar</string>
  <string name="menu_saveAs">Guardar como</string>
  <string name="menu_saveData">Guardar los datos</string>
  <string name="menu_saveData_tt">Guardar los datos en archivo CSV</string>
  <string name="menu_speedTest">Test de velocidad</string>
  <string name="menu_speedTest_tt">Hace un test de velocidad calculando la frecuencia de reloj máxima.</string>
  <string name="menu_step">Paso de puerta</string>
  <string name="menu_step_tt">Calcula un paso de puerta simple</string>
  <string name="menu_synthesise">Sintetizar</string>
  <string name="menu_synthesise_tt">Genera la expresión booleana mínima a partir de una tabla de verdad.</string>
  
  <string name="menu_table_create">Crear</string>
  <string name="menu_table_createCUPL_tt">Crea un archivo fuente CUPL que contiene al circuito.</string>
  <string name="menu_table_createTT2_tt">Crea un archivo BLIF (Berkeley Logic Interchange Format) que contiene el circuito.
		Después de eso se ejecuta el adaptador Atmel para crear el archivo JEDEC.</string>
  <string name="menu_table_createCircuit">Circuito</string>
  <string name="menu_table_createCircuit_tt">Crea un circuito a partir de una tabla de verdad.</string>
  <string name="menu_table_createCircuitJK">Circuito con flip-flops JK</string>
  <string name="menu_table_createCircuitJK_tt">Crea un circuito a partir de una tabla de verdad, usando flip-flops JK.</string>
  <string name="menu_table_createCircuitLUT">Circuito con Tablas de Consulta (LUT)</string>
  <string name="menu_table_createCircuitLUT_tt">Crea un circuito que reproduce la tabla de verdad. Usa tabla de consulta (LUT) para crear las expresiones.</string>
  <string name="menu_table_createNAnd">Circuito con puertas NAND</string>
  <string name="menu_table_createNAndTwo">Circuito con puertas NAND de dos entradas</string>
  <string name="menu_table_createNAndTwo_tt">Usa sólo puertas NAND de dos entradas.</string>
  <string name="menu_table_createNAnd_tt">Crea un circuito con sólo puertas NAND que reproduce la tabla de verdad.</string>
  <string name="menu_table_createNOr">Circuito con puertas NOR</string>
  <string name="menu_table_createNOrTwo">Circuito con puertas NOR de dos entradas</string>
  <string name="menu_table_createNOrTwo_tt">Usa sólo puertas NOR de dos entradas.</string>
  <string name="menu_table_createNOr_tt">Crea un circuito con sólo puertas NOR que reproduce la tabla de verdad.</string>
  <string name="menu_table_create_hardware">Dispositivo</string>
  <string name="menu_table_create_jedec_tt">Crea un archivo JEDEC para el dispositivo</string>
  <string name="menu_table_exportTableLaTeX">Exporta a LaTeX</string>
  <string name="menu_table_exportHex">HEX</string>
  <string name="menu_table_exportHex_tt">Puedes cargar el archivo HEX a una ROM o a una Tabla de Consulta (LUT).</string>
  <string name="menu_table_new">Nuevo</string>
  <string name="menu_table_new_combinatorial">Combinacional</string>
  <string name="menu_table_new_sequential">Secuencial</string>
  <string name="menu_table_new_sequential_bidir">Secuencial bidireccional</string>
  <string name="menu_table_reorder_inputs">Reordena/Borra variables de entrada</string>
  <string name="menu_table_reorder_outputs">Reordena/Borra columnas de salida</string>
  <string name="menu_table_columnsAdd">Añade columna de salida</string>
  <string name="menu_table_columnsAdd_tt">Añade una nueva columna de resultado a la tabla.</string>
  <string name="menu_table_columnsAddVariable">Añade variable de entrada</string>
  <string name="menu_table_columnsAddVariable_tt">Añade una nueva variable de entrada a la tabla.</string>
  <string name="menu_table_setXTo0">Fijar X a 0</string>
  <string name="menu_table_setXTo0_tt">Convierte los "indiferentes" a 0.</string>
  <string name="menu_table_setXTo1">Poner X a 1</string>
  <string name="menu_table_setXTo1_tt">Convierte los "indiferentes" a 1.</string>
  <string name="menu_table_JK">Crear expresiones J/K</string>
  <string name="menu_table_setAllToX">Fijar todos a X</string>
  <string name="menu_table_setAllToX_tt">Pone todos los valores como "indiferentes".</string>
  <string name="menu_table_setAllTo0">Poner todos a 0</string>
  <string name="menu_table_setAllTo0_tt">Fija todos los valores a cero.</string>
  <string name="menu_table_setAllTo1">Poner todos a 1</string>
  <string name="menu_table_setAllTo1_tt">Fija todos los valores a 1.</string>
  <string name="menu_terminalDelete">Borrar</string>
  <string name="menu_terminalDelete_tt">Borra el contenido de los terminales.</string>
  <string name="menu_view">Ver</string>
  <string name="menu_zoomIn">Zoom adentro</string>
  <string name="menu_zoomOut">Zoom afuera</string>
  <string name="menu_expression">Expresión</string>
  <string name="menu_expression_tt">Crea un circuito a partir de una expresión.</string>
  <string name="menu_runTests">Ejecuta las pruebas</string>
  <string name="menu_runTests_tt">Ejecuta todos los valores de prueba en el circuito</string>
  <string name="menu_actualToDefault">Fijar valores de entrada por defecto.</string>
  <string name="menu_actualToDefault_tt">Usar los valores de entrada actuales como nuevos valores por defecto.</string>
  <string name="menu_restoreAllFuses">Reiniciar todos los diodos y FGFETs</string>
  <string name="menu_restoreAllFuses_tt">Reinicia todos los diodos (fusibles) y FGFETs al estado "no programado".</string>
  <string name="menu_programDiode">Programa diodo</string>
  <string name="menu_help_elements">Componentes</string>
  <string name="menu_help_elements_tt">Muestra una lista de todos los componentes disponibles.</string>
  <string name="menu_viewHelp">Diálogo de ayuda</string>
  <string name="menu_viewHelp_tt">Muestra el diálogo de ayuda que describe el circuito actual</string>
  <string name="menu_probe_memory">Memoria</string>
  <string name="menu_probe_memory_tt">Muestra el contenido de los componentes de memoria.</string>
  <string name="menu_insertAsNew">Pegar en una nueva ventana</string>
  <string name="menu_insertAsNew_tt">El contenido del portapapeles se pega en una nueva ventana.</string>
  <string name="menu_treeSelect">Árbol de componentes</string>
  <string name="menu_treeSelect_tt">Muestra un árbol con los componentes disponibles en el lado izquierdo.</string>
  <string name="menu_special">Funciones especiales 74xx</string>
  <string name="menu_addPrefix">Añade prefijo de entrada/salida</string>
  <string name="menu_addPrefix_tt">Se añade un prefijo a todas las entradas y salidas seleccionadas.
		Se emplea para simplificar el duplicado de circuitos 74xx.</string>
  <string name="menu_removePrefix">Quitar prefijos de entrada/salida</string>
  <string name="menu_removePrefix_tt">Quita el primer carácter de las etiquetas de entradas y salidas.
		Se emplea para simplificar el duplicado de circuitos 74xx.</string>
  <string name="menu_numbering">Asistente de pines</string>
  <string name="menu_numbering_tt">Asistente para aplicar números de pin a las entradas y salidas.</string>
  <string name="menu_removePinNumbers">Quita los números de los pines</string>
  <string name="menu_removePinNumbers_tt">Quita todos los números de los pines del circuito</string>
  <string name="menu_undo">Deshacer</string>
  <string name="menu_undo_tt">Recuperar la última modificación</string>
  <string name="menu_redo">Rehacer</string>
  <string name="menu_redo_tt">Aplica la última recuperada de nuevo</string>
  <string name="menu_showDataAsGraph">Mostrar gráfico</string>
  <string name="menu_showDataAsGraph_tt">Mostrar los datos como un gráfico.</string>
  <string name="menu_showDataAsTable">Mostrar tabla</string>
  <string name="menu_showDataAsTable_tt">Muestra los valores en una tabla.</string>
  <string name="menu_addPowerSupply">Añadir fuente de alimentación</string>
  <string name="menu_addPowerSupply_tt">Añade una fuente de alimentación al circuito.</string>
  <string name="menu_exportVHDL">Exportar a VHDL</string>
  <string name="menu_exportVHDL_tt">Exporta el circuito a VHDL</string>
  <string name="menu_exportVerilog">Exporta a Verilog</string>
  <string name="menu_exportVerilog_tt">Exporta el circuito a Verilog</string>
  <string name="menu_karnaughMap">Mapa de Karnaugh</string>
  <string name="menu_karnaughMap_tt">Muestra un mapa de Karnaugh a partir de la tabla.</string>
  <string name="menu_pdfDocumentation">Documentación</string>
  <string name="menu_openPdfDocumentation">Abrir {0}</string>
  <string name="menu_showDataTable">Mostrar tabla de valores de medidas</string>
  <string name="menu_showDataTable_tt">Muestra una tabla con los valores de medidas en una ventana aparte.</string>
  <string name="menu_showDataGraph">Muestra gráfico de medidas</string>
  <string name="menu_showDataGraph_tt">Muestra un gráfico con los valores medidos en una ventana aparte.</string>
  <string name="menu_exportZIP">Exporta a un archivo ZIP</string>
  <string name="menu_exportZIP_tt">Exporta el circuito como un archivo ZIP.
    El ZIP contendrá todos los archivos que sean necesarios para el funcionamiento del circuito.
  </string>
  <string name="menu_labelPins">Etiquetar entradas y salidas</string>
  <string name="menu_labelPins_tt">Fija una etiqueta a todas las entradas y salidas que no la tienen.</string>
  <string name="msg_errorOpeningDocumentation">¡Error al abrir un archivo PDF!</string>
  <string name="message"><![CDATA[<h1>Digital</h1>
      <p>Un sencillo simulador para circuitos digitales.</p>
      <p>Escrito por H. Neemann entre 2016-2023.</p>
      <p>Los iconos se han tomado de <a href="http://tango.freedesktop.org">Tango Desktop Project</a>.</p>
      <p>Visita el proyecto en la dirección <a href="https://github.com/hneemann/[[name]]">GitHub</a>.
      También disponible en GitHub <a href="https://github.com/hneemann/[[name]]/releases/latest">descarga</a>
      la última versión.</p>
      <p>Allí también puedes aportar un <a
      href="https://github.com/hneemann/[[name]]/issues/new?body=version:%20[[version]]&labels=bug">problema</a>
      o sugerencia
      o <a href="https://github.com/hneemann/[[name]]/issues/new?labels=enhancement">mejoras</a>.</p>
      <p>Traducido al castellano por Ángel Millán León</p>]]></string>
  <string name="msg_N_nodes">{0} nodos</string>
  <string name="msg_analyseErr">Error al analizar el circuito</string>
  <string name="msg_color">Color</string>
  <string name="msg_errorCalculatingStep">Error al calcular un paso</string>
  <string name="msg_errorCreatingModel">Error al crear el circuito</string>
  <string name="msg_errorDuringCalculation">Error durante la simplificación</string>
  <string name="msg_errorDuringHardwareExport">Error al crear la configuración de hardware.</string>
  <string name="msg_errorEditingValue">Error al editar el valor de una propiedad</string>
  <string name="msg_errorImportingModel_N0">¡Error al importar el circuito {0}!</string>
  <string name="msg_errorUpdatingLibrary">¡Error al actualizar la biblioteca del componente!</string>
  <string name="msg_errorReadingFile">Error al leer un archivo</string>
  <string name="msg_remoteUnknownCommand">¡Comando {0} desconocido!</string>
  <string name="msg_errorWritingFile">Error al escribir un archivo</string>
  <string name="msg_frequency_N">La frecuencia máxima es {0} kHz</string>
  <string name="msg_missingShape_N">No se encuentra la forma {0}</string>
  <string name="msg_pins">Asignación de pines</string>
  
  <string name="msg_restartNeeded">¡Se necesita reiniciar para que se produzcan los cambios!</string>
  <string name="msg_enterAnExpression">Introduce una expresión:</string>
  <string name="msg_runningTestError">Error al ejecutar las pruebas:</string>
  <string name="msg_testResult">Resultado de la prueba</string>
  <string name="msg_test_N_Passed">{0} pasado</string>
  <string name="msg_test_N_Failed">{0} fallado</string>
  <string name="msg_test_missingLines">(¡Demasiadas entradas!)</string>
  <string name="msg_test_missingLines_tt">Todos las combinaciones del test se ejecutaron, pero no se muestran los resultados.
		¡La evaluación del resultado de la prueba es, sin embargo, correcta!</string>
  
  <string name="msg_creatingHelp">¡Error al crear la ayuda!</string>
  <string name="msg_clipboardContainsNoImportableData">¡El portapapeles no contiene datos importables!</string>
  <string name="msg_selectAnEmptyFolder">¡Selecciona una carpeta vacía!</string>
  <string name="msg_fitterResult">Mensaje del adaptador externo</string>
  <string name="msg_startExternalFitter">Ejecución del adaptador externo</string>
  <string name="msg_actualCircuit">Circuito actual</string>
  <string name="msg_fileNotAccessible">¡El nombre de archivo seleccionado no es importable desde el proyecto actual!</string>
  <string name="msg_fileIsNotUnique">¡El nombre del archivo no es único!
		Todos los archivos de la carpeta de trabajo y todas las subcarpetas deben tener nombres exclusivos.
		Esto también se aplica a la carpeta de librerías.
		Si tu carpeta de trabajo tiene un archivo 7400.dig, no puedes usarlo, ni tampoco el 7400.dig de la librería,
		porque ese nombre de archivo ya no es único.</string>
  <string name="msg_duplicateLibraryFiles">Hay varios archivos con idénticos nombres, por lo que no serán exclusivos.
		Los archivos afectados son:</string>
  <string name="msg_and_N_More">y {0} más.</string>
  <string name="msg_fileNotImportedYet">El archivo no ha sido importado todavía.</string>
  <string name="msg_fileExists">¡Ya existe el archivo {0}! ¿Quieres sobreescribirlo?</string>
  <string name="msg_isLocked">La edición del circuito está deshabilitada. Puedes quitar el bloqueo de edición en "{0} -&gt; {1} -&gt; {2}".
		Sin embargo, la copia de los componentes y la configuración de los diodos y FG-FETS con la tecla [P] es posible en el modo de bloqueo.</string>
  <string name="msg_speedTestError">¡Error durante el test de velocidad!</string>
  
  <string name="msg_numberingWizard">Asistente de numeración</string>
  <string name="msg_pin_numbering_N">Selecciona el pin {0}:</string>
  <string name="msg_framesWritten_N">Marcos escritos: {0}</string>
  <string name="msg_errorWritingGif">¡Error al escribir en el archivo GIF!</string>
  <string name="btn_gifComplete">Listo</string>
  <string name="btn_gifComplete_tt">El archivo GIF está terminado y cerrado.</string>
  <string name="msg_gifExport">Exportar a GIF</string>
  <string name="msg_errCausedBy">provocado por</string>
  <string name="msg_inputsToInvert">Entradas a invertir</string>
  <string name="msg_none">ninguna</string>
  <string name="msg_errGettingPinNames">No se pudo saber el nombre de los pines.</string>
  <string name="msg_errInFile_N">Ocurrió en el archivo {0}.</string>
  <string name="msg_affectedComponentsAre_N">Afectados son: {0}.</string>
  <string name="msg_signal_N">Señal {0}</string>
  <string name="msg_thereAreMissingPinNumbers">¡No se asignaron números a los pines {0}!
		Los pines libres se asignarán automáticamente.
		El circuito, por tanto, no puede usarse en hardware real en la mayoría de los casos.</string>
  <string name="msg_modelHasErrors">¡Sólo puedes exportar un circuito que no tenga errores!</string>
  <string name="msg_noKVMapAvailable">¡No se puede crear mapa de Karnaugh!</string>
  <string name="msg_dataNotUpdatedAnymore">¡Los datos no se actualizarán más!</string>
  <string name="msg_modifyThisAttribute">Modifica este valor</string>
  <string name="msg_invalidEditorValue">Uno de los campos contiene un valor no válido!</string>
  <string name="msg_create CHNFile">Creación de un archivo CHN.</string>
  <string name="msg_tableHasManyRowsConfirm">La tabla es muy grande, por lo que la exportación tardará un poco.
		¿Empiezo a exportar de todos modos?</string>
  <string name="msg_circuitIsRequired">Para crear una descripción de hardware, primero hay que crear el circuito y analizarlo.
		Una tabla de verdad no puede usarse para generar una descripción de hardware.</string>
  <string name="msg_noData">sin datos</string>
  <string name="msg_errorClosingExternalProcess">¡No se pudo cerrar el proceso externo!</string>
  <string name="msg_checkResult">Comprobar el resultado</string>
  <string name="btn_checkCode">Comprobar</string>
  <string name="btn_checkCode_tt">Inicia la aplicación para comprobar si el código introducido es correcto.
        Si no es así, se muestra el mensaje de error de la aplicación externa.
        Si es posible, las definiciones de las entradas y las salidas también se adaptan al código presente.</string>
  <string name="msg_applicationFileNotFound">¡Archivo ejecutable "{0} no encontrado!</string>
  <string name="msg_enterText">¡Introduce texto!</string>
  <string name="btn_startATMISP">Comienza ATMISP</string>
  <string name="btn_startATMISP_tt">Comienza el programa ATMISP externo. Debe haber sido instalado previamente.</string>
  <string name="msg_errorStartingATMISP">¡Error al iniciar ATMISP!
        ¿Se ha indicado correctamente la ruta al ejecutable ATMISP.exe en los ajustes?</string>
  <string name="msg_ATMISPIsStillRunning">¡ATMISP todavía ejecutándose!
        Cuando se cierre este diálogo, ATMISP finalizará 
        ¡Asegúrese de qué el proceso se haya completado antes de cerrar este diálogo!</string>
  <string name="menu_runAllTests">Ejecuta todas las pruebas</string>
  <string name="menu_runAllTests_tt">Ejecuta todas las pruebas de esta carpeta</string>
  <string name="msg_testPassed_N">{0} filas del test superadas</string>
  <string name="msg_testFile">Archivo probado</string>
  <string name="msg_truthTable">Tabla de verdad</string>
  <string name="msg_errorImportingSvg">Error al importar el archivo SVG.</string>
  <string name="msg_errorCreatingSvgTemplate">Error al crear la plantilla SVG.</string>
  <string name="ok">OK</string>
  <string name="rot_0">0°</string>
  <string name="rot_180">180°</string>
  <string name="rot_270">270°</string>
  <string name="rot_90">90°</string>
  <string name="stat_clocks">Break tras {0} medios ciclos en un punto de break ''{1}''.</string>
  <string name="tt_deleteItem">Borra el objeto seleccionado</string>
  <string name="tt_moveItemDown">Mueve el objeto hacia abajo</string>
  <string name="tt_moveItemUp">Mueve el objeto hacia arriba</string>
  <string name="win_allSolutions">Todas las posibles soluciones</string>
  <string name="win_testdata_N">Datos de prueba {0}</string>
  <string name="win_data">Datos</string>
  <string name="win_confirmExit">¿Confirma la salida?</string>
  <string name="win_measures">Medidas</string>
  <string name="win_measures_fullstep">Medidas tras ciclo completo de reloj</string>
  <string name="win_measures_microstep">Medida tras paso de puerta simple</string>
  <string name="win_saveChanges">¿Guardar los cambios?</string>
  <string name="win_stateChanged">¡Cambió el estado!</string>
  <string name="win_table">Tabla</string>
  <string name="win_table_exportDialog">Exportar</string>
  <string name="win_itempicker_title">Seleccionar</string>
  <string name="win_valueInputTitle_N">Entrada {0}</string>
  <string name="win_karnaughMap">Mapa de Karnaugh</string>
  <string name="win_romDialog">ROMs incluidas</string>
  <string name="btn_help">Ayuda</string>
  <string name="win_romDialogHelpTitle">Contenido de la ROM central</string>
  <string name="msg_romDialogHelp">&lt;html&gt;
        &lt;h3&gt;Justificación&lt;/h3&gt;
        Cuando un circuito que contiene una ROM se incrusta varias veces,
        el contenido de la ROM  lo usa habitualmente cada instancia del circuito.
        Bajo ciertas circunstancias, sin embargo, puede quererse incrustar tal circuito varias veces,
        pero usar diferentes contenidos para cada instancia.&lt;br/&gt;
        Este problema ocurre cuando, por ejemplo, una ROM 74xx se usa varias veces
        pero con diferentes contenidos de memoria.&lt;br/&gt;
        &lt;h3&gt;Función&lt;/h3&gt;
        En este lugar, por tanto, los contenidos pueden definirse para todas las ROMs del circuito
		Cuando el modelo de simulación se genera, cada ROM se inicializa con los contenidos almacenados directamente
		en su respectiva ROM. Entonces se chequea si hay un contenido alternativo definido aquí.
		Si éste es el caso, el contenido definido aquí se carga a la correspondiente ROM.
        &lt;h3&gt;Uso&lt;/h3&gt;
        Debería destacarse que cada ROM necesita un único nombre que la identifique.
		Para hacer esto, use el asterisco ('*') en la etiqueta de la ROM.
		El asterisco se reemplazará por la ruta completa construida con los nombres de los circuitos incrustados.
		Si un circuito contiene sólo un componente de ROM, es suficiente usar sólo el asterisco como una etiqueta para él.
    Todos los circuitos incrustados deben ser nombrados para que un único nombre pueda ser formado para cada componente
    de ROM.
    &lt;/html&gt;
  </string>
  <string name="msg_newRelease_N">&lt;html&gt;
    &lt;h1&gt;Nueva versión {0} disponible&lt;/h1&gt;
    &lt;p&gt;Hay una nueva versión del simulador disponible.&lt;/p&gt;
    &lt;p&gt;En la ruta &lt;a href="https://github.com/hneemann/[[name]]/releases/latest"&gt;, notas de la versión&lt;/a&gt;
    puede econtrar los cambios y mejoras..&lt;/p&gt;
    &lt;p&gt;Aquí puede &lt;a href="https://github.com/hneemann/[[name]]/releases/latest"&gt;descargar&lt;/a&gt; la
    nueva versión.&lt;/p&gt;
    &lt;/html&gt;
  </string>
  <string name="msg_expressionHelpTitle">Expresiones</string>
  <string name="msg_expressionHelp"><![CDATA[
        <p>Para definir una expresión puede usar las notaciones más conocidas:</p>
        <p>
        AND: "&", "&&", "*", "∧"<br/>
        OR: "|", "||", "+", "∨", "#"<br/>
        XOR: "^", "⊻"<br/>
        NOT: "!", "~", "¬"
        </p>
        <p>Como es habitual, AND prevalece sobre OR y XOR.</p>
        <p>Expresiones múltiples pueden separarse con "," or ";".
        Si quiere nombrar las expresiones, puede usar el
        comando let: "let U=A+B, let V=A*B"</p>]]></string>
  <string name="msg_testVectorHelpTitle">Vectores de prueba</string>
  <string name="msg_testVectorHelp">&lt;html&gt;
    &lt;head&gt;&lt;style&gt;pre { background-color: #E0E0E0;}&lt;/style&gt;&lt;/head&gt;
    &lt;body&gt;
      &lt;p&gt; La primera línea tiene que contener los nombres de las entradas y las salidas.
      Las siguientes líneas contienen los valores esperados.
      Una 'X' indica un "indiferente", y una 'Z' indica un valor de alta impedancia.
      Si se usa una 'C', primero todos los valores se fijan, después de que haya un ciclo de reloj y que los valores
      sean comparados.
      Así es más fácil probar la lógica secuencial.
      Una línea que empieza con un signo de número ('#') es un comentario.

      &lt;p&gt;Así, un test para un contador de 2 bits podría ser algo así:&lt;/p&gt;

      &lt;pre&gt;
      C Q1 Q0
      0 0 0
      C 0 1
      C 1 0
      C 1 1
      C 0 0
      &lt;/pre&gt;

      &lt;p&gt; Las pruebas se ejecutan con 'Ejecutar'-&gt;'Ejecutar pruebas'.&lt;/p&gt;
      &lt;p&gt;
      Para crear más fácilmente muchos vectores de prueba, está la instrucción 'repeat([n]):
      Si una línea comienza con 'repeat([n])', [n] líneas de prueba se generarán.
      La variable 'n' puede usarse para generar los datos de la prueba.
      Con 'repeat(16)', se crearán 16 líneas, donde n va de 0 a 15.
      Si hay entradas con múltiples bits y se van a fijar a un valor binario, esto puede hacerse con la instrucción
      'bits([bits], [value])'. Esto se emplea para crear [bits] bits del valor [value].&lt;/p&gt;

      &lt;p&gt;El siguiente es un ejemplo de prueba para un sumador de 4 bits:&lt;/p&gt;

&lt;pre&gt;
           C_i-1  A_3 A_2 A_1 A_0  B_3 B_2 B_1 B_0  C_i S_3 S_2 S_1 S_0
repeat(256)  0    bits(4,n&gt;&gt;4)     bits(4,n)        bits(5,(n&gt;&gt;4)+(n&amp;15))
repeat(256)  1    bits(4,n&gt;&gt;4)     bits(4,n)        bits(5,(n&gt;&gt;4)+(n&amp;15)+1)
&lt;/pre&gt;

&lt;p&gt; Las señales de entrada son el Carry-in (C_i-1) y los ocho bits de entrada A_3-A_0 y B_3-B_0.
Los 4 bits de entrada se generan con la instrucción 'bits'. El resultado (C_i, S_3-S_0) también se genera con la instrucción 'bits'
Esto sucede una vez con C_i-1 = 0 y en la siguiente línea con C_i-1 = 1.
De esta forma, se generan 512 filas de prueba que cubren todas las posibles configuraciones de entrada.&lt;/p&gt;
&lt;p&gt; Si se van a repetir varias filas, o hay bucles anidados, puede usarse la instrucción 'loop'.
El ejemplo de arriba podría implementarse también así:&lt;/p&gt;

      &lt;pre&gt;
      C_i-1 A_3 A_2 A_1 A_0 B_3 B_2 B_1 B_0 C_i S_3 S_2 S_1 S_0
      loop(a,16)
      loop(b,16)
      0 bits(4,a) bits(4,b) bits(5,a+b)
      1 bits(4,a) bits(4,b) bits(5,a+b+1)
      end loop
      end loop
      &lt;/pre&gt;

      &lt;p&gt;En algunas circunstancias puede ser necesario poder reaccionar al estadio inicial del circuito. Por
      tanto, las señales proporcionadas en el circuito pueden usarse dentro del caso de prueba. Por ejemplo, si
      se va a probar un contador que empieza en un estado indefinido, puede ser fijado a un estado definido:&lt;/p&gt;

      &lt;pre&gt;C Q_3 Q_2 Q_1 Q_0

      # clock counter to 1111
      while(!(Q_3 &amp; Q_2 &amp; Q_1 &amp; Q_0))
      C x x x x
      end while

      # start the test execution
      repeat(16) C bits(4,n)
      &lt;/pre&gt;

      &lt;p&gt; Puede ser útil generar números aleatorios en los casos de prueba.
      Esto puede hacerse con la función 'random([n])'. El número generado es mayor o igual que 0 y menor que [n].
      Si suponemos, por ejemplo, un multiplicador de 16 bits, un test completo no podría hacerse, porque hay 2^32
      combinaciones de entrada.
      Una prueba de regresión que multiplicara 100000 números aleatorios podría tener este aspecto:&lt;/p&gt;

      &lt;pre&gt;
      A B Y
      loop(i,100000)
      let a = random(1&amp;lt;&amp;lt;16);
  let b = random(1&amp;lt;&amp;lt;16);
  (a)  (b)   (a*b)
end loop
&lt;/pre&gt;

&lt;p&gt; Una entrada que admite alta impedancia como estado también puede usarse como una salida de prueba.
En tal caso, el nombre de la señal puede usarse con un añadido "_out" para leer y chequear el valor actual.
      Para esto, la entrada correspondiente tiene que fijarse a "alta impedancia"('Z').&lt;/p&gt;

      &lt;pre&gt;OE CLK D D_out
      0 0 0 0
      0 C 1 1
      1 0 z 1
      0 C 0 0
      1 0 z 0
      &lt;/pre&gt;

      &lt;p&gt;El circuito para este test tiene solo una entrada 'D', pero que puede estar en estado de alta impedancia.
      Por tanto, la señal 'D_out' estará también disponible para chequear el valor en este caso.&lt;/p&gt;

&lt;p&gt; En casos especiales, puede que queramos usar las señales proporcionadas por el circuito para producir una nueva señal,
que es la que se va a comprobar. Un ejemplo podría ser una señal de un bus con varios bits, donde solo deberíamos comprobar un bit,
mientras que los demás no tienen influencia en la prueba. En este caso, se puede generar una nueva señal dentro de la prueba
que contenga este solo bit, de modo que las pruebas se puedan definir para este bit.&lt;/p&gt;
&lt;p&gt;Esto se hace con el comando 'declare':&lt;/p&gt;
&lt;pre&gt;A B Bit

declare Bit = (Bus&gt;&gt;3)&amp;1;

0 0  0
0 1  0
1 0  1
1 1  0
&lt;/pre&gt;
&lt;p&gt;En este ejemplo, el tercer bit está aislado de la señal 'Bus' y se saca como la señal 'Bit' para la prueba.
El circuito en sí mismo no contiene ninguna salida llamada 'Bit'&lt;/p&gt;

&lt;p&gt;Las funciones disponibles son:
&lt;dl&gt;
&lt;dt&gt;signExt([bits],[value])&lt;/dt&gt;
&lt;dd&gt;Extiende el valor [value] y conserva el signo en [bits] bits.&lt;/dd&gt;
&lt;dt&gt;random([max])&lt;/dt&gt;
&lt;dd&gt;Devuelve un número entero aleatorio. El valor máximo se especifica con [max].&lt;/dd&gt;
&lt;dt&gt;ite([cond],[then],[else])&lt;/dt&gt;
&lt;dd&gt;Si se cumple la condición [cond], se devuelve el valor [then]. En caso contrario, el valor [else].&lt;/dd&gt;
&lt;/dl&gt;
&lt;/p&gt;


&lt;h3&gt;Procesadores&lt;/h3&gt;
&lt;p&gt; Si se van a comprobar procesadores, necesitamos una inicialización del procesador.
Es posible hacer esta inicialización dentro del caso de prueba.
Así, se pueden aplicar varios casos de prueba en un circuito y cada comprabación puede usarse con su propia inicialización.
Hay tres instrucciones para llevar a cabo esta inicialización:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;El comando 'program' puede usarse para sobreescribir la memoria de programa del procesador.
La instrucción &lt;pre&gt;program(0x8000,0x2d11,0x8000,0x2f21)&lt;/pre&gt; escribe cuatro palabras al comienzo de la memoria de programa.
El resto de palabras valen cero.&lt;/li&gt;.
&lt;li&gt;La instrucción 'memory' puede emplearse para escribir en un componente de RAM:
&lt;pre&gt;memory mem(3)=7;&lt;/pre&gt;
Este ejemplo escribe 7 en la memoria con la etiqueta 'mem' en la dirección 3.&lt;/li&gt;
&lt;li&gt; Un registro con una determinada etiqueta puede ser sobreescrito con el comando 'init'.
&lt;pre&gt;init R0=22;&lt;/pre&gt;
Esta instrucción sobreescribe el registro con la etiqueta 'R0' con el valor 22.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hay que destacar que todas las inicializaciones empleadas se aplican solo una vez antes de la ejecución de la prueba.
No importa en qué línea del caso de prueba esté.
Sin embargo, no se deben usar por encima de la línea del encabezado que contiene la lista de los nombres de las señales.&lt;/p&gt;




      &lt;/body&gt;&lt;/html&gt;</string>
  <string name="fsm_title">Máquina de Estados Finitos (FSM)</string>
  <string name="fsm_noMove">sin movimiento</string>
  <string name="fsm_moveTrans">Transiciones</string>
  <string name="fsm_moveStates">Transiciones+Estados</string>
  <string name="fsm_set_N">Fijar {0}</string>
  <string name="menu_fsm">Máquina de Estados Finitos (FSM)</string>
  <string name="menu_fsm_tt">Abre un diálogo para editar una Máquina de Estados Finitos.</string>
  <string name="menu_fsm_create">Crear</string>
  <string name="menu_fsm_create_table">Tabla de Transiciones de Estados</string>
  <string name="menu_fsm_create_counter">Crear contador</string>
  <string name="menu_fsm_create_counter_N">{0} Estados</string>
  <string name="menu_fsm_Help_tt">Ayuda para manejar el editor de la FSM</string>
  <string name="key_stateNum">Número del estado</string>
  <string name="key_stateNum_tt">Número que representa a este estado.</string>
  <string name="key_isInitialState">Estado inicial</string>
  <string name="key_isInitialState_tt">Si se marca, éste será el estado inicial.</string>
  <string name="key_stateValues">Salidas</string>
  <string name="key_stateValues_tt">Define los valores de salida.
		Las salidas pueden fijarse con asignaciones simples, como "A=1, B=0".
		Las salidas de múltiples bits pueden fijarse con instrucciones como "A=101".
		Las salidas que no estén definidas aquí se fijan a cero en los estados.
		Para las transiciones, las salidas sin especificar permanecen sin cambios.</string>
  <string name="key_transCond">Condición</string>
  <string name="key_transCond_tt">Expresión booleana.</string>
  <string name="key_transRad">Radio</string>
  <string name="key_transRad_tt">Radio del círculo en el diagrama.</string>
  <string name="err_notDeterministic_N">La máquina de estados finitos no es determinista: {0}</string>
  <string name="err_fsmNumberUsedTwice_N">El número del estado {0} se ha usado dos veces.</string>
  <string name="err_fsmNoInitialState">No hay estado inicial (estado número cero).</string>
  <string name="err_fsmState_N_notFound">¡El estado ''{0}'' no se encuentra!</string>
  <string name="err_fsmInvalidOutputAssignment_N">¡Asignación equivocada a la salida (''{0}'')!</string>
  <string name="err_fsmErrorInCondition_N">¡Error en la condición ''{0}''!</string>
  <string name="msg_fsm_errorLoadingFile">¡Error cargando un archivo!</string>
  <string name="msg_fsm_errorStoringFile">¡Error guardando un archivo!</string>
  <string name="msg_fsmNewState">Nuevo estado</string>
  <string name="msg_fsmCantCreateTable">No se puede crear la tabla de transiciones de estado.</string>
  <string name="msg_fsmHelpTitle">Ayuda del editor de máquina de estados finitos (FSM)</string>
  <string name="msg_fsmHelp">&lt;html&gt;&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;h3&gt;Uso del ratón&lt;/h3&gt;
  &lt;dl&gt;
    &lt;dt&gt;Crear un estado:&lt;/dt&gt;
    &lt;dd&gt;Haz clic derecho en un lugar en blanco.&lt;/dd&gt;
    &lt;dt&gt;Crear una transición:&lt;/dt&gt;
    &lt;dd&gt;Pincha con el botón derecho en el primer estado y arrastra hasta el estado de destino.&lt;/dd&gt;
    &lt;dt&gt;Borrar un estado o una transición:&lt;/dt&gt;
    &lt;dd&gt;Mueve el ratón sobre el objeto y presiona la tecla [Del].&lt;/dd&gt;
    &lt;dt&gt;Moviendo un estado o una transición:&lt;/dt&gt;
    &lt;dd&gt;Pincha con el botón izquierdo y arrastra.&lt;/dd&gt;
    &lt;dt&gt;Editar un estado o una transición:&lt;/dt&gt;
    &lt;dd&gt;Haz clic derecho en el estado o en la transición.&lt;/dd&gt;
  &lt;/dl&gt;
  &lt;h3&gt;Función de ayuda al diseño.&lt;/h3&gt;
  &lt;dl&gt;
    &lt;dt&gt;sin movimiento:&lt;/dt&gt;
    &lt;dd&gt;La función de ayuda al diseño está desactivada.&lt;/dd&gt;
    &lt;dt&gt;Transiciones:&lt;/dt&gt;
    &lt;dd&gt;La función de ayuda al diseño mueve las flechas de transición para evitar solapamientos.&lt;/dd&gt;
    &lt;dt&gt;Transiciones+Estados&lt;/dt&gt;
    &lt;dd&gt;La función de ayuda al diseño mueve los estados y las transiciones para crear un diseño claro.&lt;/dd&gt;
  &lt;/dl&gt;
  &lt;h3&gt;Interpretación de las transiciones&lt;/h3&gt;
  Para simplificar la generación de un autómata determinista, las transiciones sin condición se tratan de un modo especial:
  una transición sin condiciones sólo se ejecuta si ninguna otra transición satisface la condición de transición.
  Así, puede haber transiciones sin condición y transiciones con condición que empiecen en el mismo estado.
  Una transición sin condición determina, por tanto, a qué estado se desplaza la máquina de estados si ninguna otra condición de transición se conoce.
  Si no hay transiciones sin condiciones desde un estado, la máquina de estados permanecerá en este estado si ninguna otra condición de transición se conoce.
&lt;/body&gt;&lt;/html&gt;</string>
  <string name="err_clockIsNotUsed">¡El componente "Reloj" no se usa!</string>
  <string name="err_hdlNotKnown_N">HDL no conocido: {0}</string>
  <string name="msg_errorStartCommand_N">Error al iniciar el comando {0}</string>
  <string name="key_enabled">Habilitado</string>
  <string name="key_enabled_tt">Habilita o deshabilita este componente.</string>
  <string name="key_toolChainConfig">Configuración de la toolchain</string>
  <string name="key_toolChainConfig_tt">Se emplea para configurar la integración de una toolchain.
		Permite el arranque de herramientas externas, por ejemplo, programar una FPGA o similar.</string>
  <string name="menu_stats">Estadísticas del circuito</string>
  <string name="menu_stats_tt">Muestra una lista de los componentes empleados.</string>
  <string name="stat_number">Número</string>
  <string name="stat_part">Componente</string>
  <string name="msg_couldNotCreateStats">No se pudieron crear las estadísticas</string>
  <string name="msg_errorReadingToolchainConfig_N">Error al leer la configuración de la toolchain {0}</string>
  <string name="msg_commandStarted_N">¡El comando "{0}" ha empezado! ¡El procesado puede llevar un tiempo!</string>
  <string name="msg_commandEnded_N">¡El comando "{0}" ha sido completado!</string>
  <string name="err_thereIsAUnnamedIO">Hay una entrada o una salida sin nombre</string>
  <string name="err_NameOfIOIsInvalidOrNotUnique_N">La señal "{0}" no es válida o se ha usado varias veces</string>
  <string name="err_substitutingError">Error al sustituir componentes para el análisis.</string>
  <string name="err_evaluatingGenericsCode_N_N">Error en la evaluación del código genérico del circuito. Código
    {1}
    en el Componente: {0}
  </string>
  <string name="msg_errParsingGenerics">Error al analizar código genérico</string>
  <string name="key_generic">Parametrización genérica</string>
  <string name="key_generic_tt">Declaraciones hechas para generar un circuito</string>
  <string name="key_isGeneric">El circuito es genérico</string>
  <string name="key_isGeneric_tt">Permite crear un circuito genérico</string>
  <string name="key_showTutorial">Muestra el tutorial en el arranque</string>
  <string name="key_showTutorial_tt">Habilita el tutorial</string>
  <string name="stat_inputs">Entradas</string>
  <string name="stat_bits">Bits</string>
  <string name="stat_addrBits">Bits de dirección</string>
  <string name="tutorial">Tutorial</string>
  <string name="tutorial1">A continuación, podrás diseñar tu primer circuito tras un breve tutorial:
		
		Primero, pon una entrada en el circuito. Encontrarás las entradas en el menú Componentes▸Entrada-Salida</string>
  <string name="tutorial2">Ahora, añade una segunda entrada al circuito. También puedes hacer clic sobre la entrada que ha aparecido en la barra de herramientas.
		
		Es mejor colocar la segunda entrada a dos espacios de rejilla debajo de la primera.
		Puedes mover el circuito presionando el botón derecho del ratón.
		Haciendo clic sobre las entradas puedes moverlas.</string>
  <string name="tutorial3">A continuación vamos a insertar una puerta "OR Exclusiva".
		Puedes encontrarla en el menú Componentes▸Lógica.
		Coloca el componente a dos espacios de rejilla a la derecha de las entradas.</string>
  <string name="tutorial4">El último componente que vamos a insertar es una salida.
		Colócala a dos espacios de rejilla a la derecha de la puerta "OR Exclusiva".</string>
  <string name="tutorial5">Para completar el circuito hay que dibujar los cables.
	
		Haz clic en el punto rojo de la primera entrada y conecta el cable que aparece a una entrada de la puerta "OR Exclusiva"
		haciendo clic en uno de los puntos azules de dicha puerta.
		¡NO pinches y arrastres con el botón del ratón!</string>
  <string name="tutorial6">Conecta los puntos rojos de las entradas con los puntos azules de la puerta "OR Exclusiva"
		y el punto rojo de dicha puerta con el punto azul de la salida.
		Así de fácil: un punto rojo va a un punto azul.</string>
  <string name="tutorial7">Tu primer circuito ya funcionará.
		Para empezar la simulación, puedes hacer clic en el botón "Simular" de la barra de herramientas.</string>
  <string name="tutorial8">La simulación ya está activa. Ahora puedes cambiar los valores de las entradas haciendo clic en ellas.</string>
  <string name="tutorial9">Para terminar la simulación, haz clic en el botón "Stop" de la barra de herramientas.</string>
  <string name="tutorial10">Para que todo quede perfecto, tendrías que poner etiquetas a las entradas y salidas.
	
		Haz clic con el botón derecho en una entrada para abrir un cuadro de diálogo.
		En MacOS puedes usar el control-clic.
      Así podrás nombrar la entrada.
  </string>
    <string name="tutorial11">Etiqueta todas las entradas y salidas.</string>
    <string name="tutorialUniqueIdents">Los nombres de las entradas y salidas deben ser únicos.</string>
    <string name="tutorialNotNeeded">Saltar el tutorial</string>
    <string name="menu_runToBreakMicro">Ejecutar hasta parar en modo de puerta simple.</string>
    <string name="menu_runToBreakMicro_tt">Ejecuta todos los pasos de puerta sencillos hasta que se detecta un flanco de
        subida en un componente de parada.
        Si no hay componente de parada, se ejecutan los pasos de puerta simple restantes.
    </string>
    <string name="elem_Seven-Seg_pin_ca">Ánodo común. Para encender los ledes, esta entrada deberá estar en ALTO
    </string>
    <string name="key_commonConnectionType">Común</string>
    <string name="key_commonConnectionType_tt">Tipo de conexión común.</string>
    <string name="key_commonConnectionType_cathode">Cátodo</string>
    <string name="key_commonConnectionType_anode">Ánodo</string>
    <string name="key_wireToolTips">Consejos sobre la herramienta cable</string>
    <string name="key_wireToolTips_tt">Si está seleccionado, las líneas de resaltan cuando el ratón para sobre ellas.
    </string>
    <string name="menu_table_showAllSolutions">Muestra el diálogo de resultados</string>
    <string name="menu_table_showAllSolutions_tt">Muestra el cuadro de diálogo de resultados si se cerró manualmente
    </string>
    <string name="msg_codeNotConsistent">Las definiciones de entrada y salida no se pudieron crear automáticamente.
        ¡Por favor, comprueba los ajustes!
    </string>
    <string name="msg_fsmTransition">Transición</string>
    <string name="msg_fsmState">Estado</string>
    <string name="elem_ButtonLED">Pulsador con LED</string>
    <string name="elem_ButtonLED_tt">Un pulsador que vuelve a su estado original cuando se presiona.
        El pulsador tiene un led que puede ser conmutado con una señal de entrada.
    </string>
    <string name="elem_ButtonLED_pin_out">Señal de salida del botón</string>
    <string name="elem_ButtonLED_pin_in">Entrada para controlar el LED</string>
    <string name="elem_VGA">Monitor VGA</string>
    <string name="elem_VGA_tt">Analiza las señales de vídeo entrantes y muestra el gráfico correspondiente.
        Puesto que la simulación no se puede ejecutar en tiempo real, se necesita el reloj de pixel además de las
        señales de vídeo.
    </string>
    <string name="elem_VGA_pin_R">Componente de color rojo</string>
    <string name="elem_VGA_pin_G">Componente de color verde</string>
    <string name="elem_VGA_pin_B">Componente de color azul</string>
    <string name="elem_VGA_pin_H">Señal de sincronización horizontal</string>
    <string name="elem_VGA_pin_V">Señal de sincronización vertical</string>
    <string name="elem_VGA_pin_C">Reloj de píxel</string>
    
    <string name="elem_PinControl_tt">Lógica de control para un pin bidireccional.
        ¡Se precisa este componente sólo en el contexto de generación de VHDL o Verilog, con el fin de crear un puerto
        HDL bidireccional!
    </string>
    <string name="elem_PinControl_pin_wr">Dato que se va a mostrar</string>
    <string name="elem_PinControl_pin_oe">Activa la salida.</string>
    <string name="elem_PinControl_pin_rd">Datos que se van a leer.</string>
    <string name="elem_PinControl_pin_pin">Conector para el pin real. Sólo se debería conectar aquí una salida simple.
    </string>
    <string name="err_customShapeHasNoPin_N">La forma personalizada no define un pin {0}</string>
    <string name="err_hdlMultipleOutputsConnectedToNet_N_N_N">Varias salidas se conectan a otras.
        Este tipo de interconexión no está soportado para exportación HDL. ({0}, {1}, {2})
    </string>
    <string name="err_unnamedNet">red sin nombre</string>
    <string name="err_vgaModeNotDetected_N">No se detectó modo de vídeo ({0})</string>
    <string name="key_intFormat_oct">octal</string>
    <string name="key_mirror">Reflejo</string>
    <string name="key_mirror_tt">Refleja el componente del circuito</string>
    <string name="key_addValueToGraph">Mostrar en gráfico de medida</string>
    <string name="key_addValueToGraph_tt">Muestra el valor en el gráfico de medida.</string>
    <string name="key_tunnelRenameDialog">Muestra el cuadro de diálogo para renombrar los túneles</string>
    <string name="key_tunnelRenameDialog_tt">Si se fija, se muestra un cuadro de diálogo para renombrar automáticamente
        todos los túneles que tienen el mismo nombre después de que se renombra un túnel.
    </string>
    <string name="key_switchActsAsInput">El switch se comporta como una entrada</string>
    <string name="key_switchActsAsInput_tt">Si se analiza el modelo, el switch se comporta como una entrada, en la que
        "abierto" corresponde a '0' y "cerrado" a '1'.
    </string>
    <string name="menu_exportSVGSettings">Ajustes de exportación SVG</string>
    <string name="key_SVG_LaTeX">Texto en notación LaTeX</string>
    <string name="key_SVG_LaTeX_tt">El texto se introduce en notación LaTeX. Se necesita Inkscape para procesamiento
        posterior.
    </string>
    <string name="key_SVG_pinsInMathMode">Etiquetas de pin en modo Math</string>
    <string name="key_SVG_pinsInMathMode_tt">Para etiquetas de pines, usar el modo math incluso si no contiene
        índices.
    </string>
    <string name="key_SVG_hideTest">Oculta los Casos de Prueba</string>
    <string name="key_SVG_hideTest__">Los Casos de Prueba no se exportan.</string>
    <string name="key_SVG_noShapeFilling">Formas no rellenas</string>
    <string name="key_SVG_noShapeFilling_tt">Los polígonos no están rellenos.</string>
    <string name="key_SVG_smallIO">Entradas y salidas pequeñas</string>
    <string name="key_SVG_smallIO_tt">Entradas y salidas se representan como pequeños círculos.</string>
    <string name="key_SVG_noPinMarker">Abandonar el marcador de pines</string>
    <string name="key_SVG_noPinMarker_tt">Los marcadores de pines azul y rojo se omiten en los símbolos.</string>
    <string name="key_SVG_highContrast">Alto contraste</string>
    <string name="key_SVG_highContrast_tt">Los cables y el texto de los pines se muestran en negro.</string>
    <string name="key_SVG_monochrome">Monocromo</string>
    <string name="key_SVG_monochrome_tt">Sólo se usan grises.</string>
    <string name="key_SVG_thinnerLines">Líneas delgadas</string>
    <string name="key_SVG_thinnerLines_tt">Si se marca, las líneas se dibujan un poco más delgadas.</string>
    <string name="key_equalsInsteadOfPlus">Usa la tecla "Igual"</string>
    <string name="key_equalsInsteadOfPlus_tt">Usa la tecla igual en lugar de la tecla más.
        Ésto es especialmente útil si el carácter "más" no es una tecla primaria, sino la segunda asignación de la tecla
        igual, por ejemplo, en un teclado americano o francés.
    </string>
    <string name="key_snapToGrid">Ajustarse a la rejilla</string>
    <string name="key_snapToGrid_tt">Si se fija, el componente se alinea con la rejilla.</string>
    <string name="menu_table_createFunctionFixture">Exportar el caso de prueba</string>
    <string name="menu_table_createFunctionFixture_tt">Crea la descripción de un caso de prueba que puede usarse en un
        caso de prueba.
    </string>
    <string name="menu_table_createFunctionFixture_isSequential">¡El caso de prueba sólo es funcional si el circuito es
        puramente combinacional!
    </string>
    <string name="menu_table_invert">Invierte todos los bits</string>
    <string name="menu_table_invert_tt">Convierte3 el "1" en "0" y viceversa. Las indeterminaciones no se modifican.
    </string>
    <string name="menu_tutorial">Empezar el tutorial</string>
    <string name="menu_tutorial_tt">Empieza el tutorial para el principiante.</string>
    <string name="msg_renameNet">Renombrar la red</string>
    <string name="msg_renameNet_N_OLD_NEW">Hay {0} túneles adicionales con el mismo nombre ''{1}''.
        ¿Quieres renombrarlos todos de {0} a ''{2}''?
    </string>
    <string name="msg_dataWillBeLost_n">¿Quieres realmente descartar los cambios del campo "{0}"?</string>
    <string name="btn_copyToClipboard">Portapapeles</string>
    <string name="btn_copyToClipboard_tt">Copia el texto al portapapeles.</string>
    <string name="msg_graphHelpTitle">Gráfico de medida</string>
    <string name="msg_graphHelp">&lt;html&gt;&lt;body&gt;
        &lt;h3&gt;¿Qué puede verse en el gráfico?&lt;/h3&gt;
        A diferencia de un analizador lógico, el eje X del gráfico de medida no muestra el tiempo.
        En su lugar, se muestra un contador, que cuenta los cambios en el estado del circuito.
        Cuando quiera que haya un cambio en el circuito, el contador se incrementa y se muestra el nuevo estado.&lt;br/&gt;
        También puedes pensar que es un analizador lógico clásico que no guarda ningún data para su optimización si nada
        ha cambiado en el circuito.
        Sin embargo, esto también quiere decir que no es posible leer del gráfico tanto si ha pasado mucho o poco tiempo
        entre dos cambios en el circuito.&lt;br/&gt;
        Este comportamiento está provocado por la naturaleza de la simulación: la simulación del circuito no entiende el
        concepto "tiempo". Se hace un cambio en el ciruito, y se calcula el cambio en el estado del mismo, hasta que se
        estabiliza de nuevo. Cuando se llega al siguiente esado, el efecto se vuelve a calcular, y así sucesivamente.
        Estos cambios se cuentan, y el valor del contador se muestra en el eje X del gráfico.&lt;br/&gt;
        Entre otras cosas, esto también significa que un circuito no puede ser overclockeado, puesto que los efectos del
        flanco de bajada del reloj no se calculan hasta que el circuito ha sido estabilizado tras el flanco de subida
        anterior.
        &lt;/body&gt;&lt;/html&gt;
    </string>
    <string name="elem_StepperMotorUnipolar">Motor paso a paso, unipolar</string>
    <string name="elem_StepperMotorUnipolar_tt">Motor paso a paso unipolar, con dos interruptores limitadores de
        posición.
        Están soportados el control normal (full step), medio paso (half step) o modo wave.
    </string>
    <string name="elem_StepperMotorUnipolar_pin_S0">Switch de posición límite 0. Vale 1 cuando el ángulo del motor es
        0º
    </string>
    <string name="elem_StepperMotorUnipolar_pin_S1">Switch de posición límite 1. Vale 1 cuando el ángulo del motor es
        180º
    </string>
    <string name="elem_StepperMotorUnipolar_pin_P0">Fase 0</string>
    <string name="elem_StepperMotorUnipolar_pin_P1">Fase 1</string>
    <string name="elem_StepperMotorUnipolar_pin_P2">Fase 2</string>
    <string name="elem_StepperMotorUnipolar_pin_P3">Fase 3</string>
    <string name="elem_StepperMotorUnipolar_pin_com">Conexión de la bobina central común</string>
    <string name="elem_StepperMotorBipolar">Motor paso a paso, bipolar</string>
    <string name="elem_StepperMotorBipolar_tt">Motor paso a paso bipolar, con dos interruptores de posición límite.
        Están soportados el control normal (full step), medio paso (half step) o modo wave.
    </string>
    <string name="elem_StepperMotorBipolar_pin_S0">Switch de posición límite 0. Vale 1 cuando el ángulo del motor es
        0º
    </string>
    <string name="elem_StepperMotorBipolar_pin_S1">Switch de posición límite 1. Vale 1 cuando el ángulo del motor es
        180º.
    </string>
    <string name="elem_StepperMotorBipolar_pin_A+">Bobina A, positivo</string>
    <string name="elem_StepperMotorBipolar_pin_A-">Bobina A, negativo</string>
    <string name="elem_StepperMotorBipolar_pin_B+">Bobina B, positivo</string>
    <string name="elem_StepperMotorBipolar_pin_B-">Bobina B, negativo</string>
    <string name="elem_Stop">Parada</string>
    <string name="elem_Stop_tt">Un flanco de subida en la entrada para la simulación.
        Tiene el mismo efecto que presionar el botón "Stop" de la barra de herramientas.
    </string>
    <string name="elem_Stop_pin_stop">Un flanco de subida para la simulación.</string>
    <string name="err_ROM_noFileGivenToLoad">¡No existe nombre de fichero disponible para la recarga automática!
    </string>
    <string name="attr_panel_Options">Opciones</string>
    <string name="key_ghdlOptions">Opciones GHDL</string>
    <string name="key_ghdlOptions_tt">Opciones empleadas para procesar todos los pasos en GHDL</string>
    <string name="key_layoutShapeDelta">Separador de pines</string>
    <string name="key_layoutShapeDelta_tt">Utilizado por el tipo de forma de diseño. Fija la distancia al pin
        anterior.
    </string>
    <string name="key_colorScheme">Esquema de color</string>
    <string name="key_colorScheme_DEFAULT">Normal</string>
    <string name="key_colorScheme_DARK">Oscuro</string>
    <string name="key_colorScheme_COLOR_BLIND">rojo/verde daltónico</string>
    <string name="key_colorScheme_CUSTOM">Definido por el usuario</string>
    <string name="menu_colorSchemePreset">Predefinido</string>
    <string name="key_customColorScheme">Colores definidos por el usuario</string>
    <string name="colorName_BACKGROUND">Fondo</string>
    <string name="colorName_MAIN">Primer plano</string>
    <string name="colorName_WIRE">Cable</string>
    <string name="colorName_WIRE_HIGH">Cable ALTO</string>
    <string name="colorName_WIRE_LOW">Cable BAJO</string>
    <string name="colorName_WIRE_VALUE">Valor en el cable</string>
    <string name="colorName_WIRE_OUT">Salida</string>
    <string name="colorName_WIRE_Z">Cable en ALTA IMPEDANCIA</string>
    <string name="colorName_ERROR">Error</string>
    <string name="colorName_PASSED">Ok</string>
    <string name="colorName_PINS">Pines</string>
    <string name="colorName_GRID">Rejilla</string>
    <string name="colorName_TESTCASE">Caso de prueba</string>
    <string name="colorName_DISABLED">Deshabilitado</string>
    <string name="colorName_ASYNC">Asíncrono</string>
    <string name="colorName_HIGHLIGHT">Destacado</string>
    <string name="lib_displays">Displays</string>
    <string name="lib_mechanic">Mecánica</string>
    <string name="lib_peripherals">Periféricos</string>
    <string name="cli_cli">Interfaz de línea de comandos</string>
    <string name="cli_nonOptionalArgumentMissing_N">El argumento no-opcional {0} no se encuentra.</string>
    <string name="cli_notABool_N">El valor {0} no es booleano.</string>
    <string name="cli_notANumber_N">El valor {0} no es un número.</string>
    <string name="cli_noArgument_N_available">El argumento {0} no está definido.</string>
    <string name="cli_notEnoughArgumentsGiven">No hay suficientes argumentos.</string>
    <string name="cli_toMuchArguments">Hay demasiados argumentos.</string>
    <string name="cli_invalidType_N">Tipo no válido.</string>
    <string name="cli_command_N_hasNoSubCommand_N">El comando {0} no tiene subcomando {1}.</string>
    <string name="cli_options">Opciones:</string>
    <string name="cli_help_test">El primer nombre de archivo específica el circuito que se va a probar.
        Si se especifica un segundo nombre de archivo, los casos de prueba se ejecutan para este archivo.
        Si no se especifica el segundo nombre de archivo, los casos de prueba se ejecutan para el primer archivo.
    </string>
    <string name="cli_help_test_circ">Nombre del archivo que se va a probar.</string>
    <string name="cli_help_test_tests">Nombre del archivo con casos de prueba.</string>
    <string name="cli_help_test_allowMissingInputs">Permite que no haya entradas en el circuito que están definidas en
        el caso de prueba.
        Esto puede ser útil si hay varias posibles soluciones que dependen de diferentes entradas.
    </string>
    <string name="cli_thereAreTestFailures">Las pruebas han fallado.</string>
    <string name="cli_errorExecutingTests">Hubo un eerror durante la ejecución de las pruebas.</string>
    <string name="cli_help_svg">Puede usarse para crear un archivo SVG a partir de un circuito.</string>
    <string name="cli_help_svg_dig">Nombre del archivo del circuito.</string>
    <string name="cli_help_svg_svg">Nombre del archivo SVG que se va a escribir.</string>
    <string name="cli_help_svg_ieee">Uso de los símbolos IEEE.</string>
    <string name="cli_errorCreatingSVG">Error al crear el archivo SVG.</string>
    <string name="cli_help_stats">Crea un archivo CSV que contiene las estadísticas del circuito.
        Todos los componentes se listan en un archivo CSV.
    </string>
    <string name="cli_help_stats_dig">Nombre del archivo del circuito.</string>
    <string name="cli_help_stats_csv">Nombre del archivo CSV que se va a crear.
        Si no está indicada esta opción, se escribe la tabla en stdout.
    </string>
    <string name="cli_errorCreatingStats">Error al crear el archivo de estadísticas.</string>
    <string name="menu_table_exportTablePlainText">Exporta texto plano</string>
    <string name="elem_ScopeTrigger">Gráfica de datos activos</string>
    <string name="elem_ScopeTrigger_short">Rango</string>
    <string name="elem_ScopeTrigger_tt">Muestra una gráfica de los valores medidos, por lo que los valores medidos se guardan solo si la señal de entrada cambia.
		El guardado tiene lugar cuando el circuito se ha estabilizado.
		La activación no comienza la medida en un rango real, pero cada evento de activación almacena un simple valor de medida para cada una de las señales mostradas.
		Como entrada directa solo está el activador. Las entradas y salidas de los circuitos, flip-flops y registros y el componente sonda pueden usarse como señales.
		Esto puede activarse en los respectivos componentes.</string>
    <string name="elem_ScopeTrigger_pin_T">Un cambio en esta entrada provoca el almacenamiento de los valores medidos</string>
    <string name="elem_NotConnected">No conectado</string>
    <string name="elem_NotConnected_tt">Este componente puede emplearse para poner un cable en alta impedancia.
		Si una entrada de una puerta lógica está en alta impedancia, el valor leído en ella estará indeterminado.
		Observa que en realidad en muchos casos, puede ocurrir un excesivo consumo de corriente e incluso un daño si una entrada no está fijada a alta o baja, sino que permanece desconectada.</string>
    <string name="elem_NotConnected_pin_out">Esta salida siempre proporciona alta impedancia.</string>
    <string name="err_notConnectedNotAllowed">¡El símbolo No Conectado no se permmite aquí!</string>
    <string name="elem_ROMDualPort">Puerto dual ROM</string>
    <string name="elem_ROMDualPort_short">ROM</string>
    <string name="elem_ROMDualPort_tt">Componente de memoria no volátil.
		Los datos almacenados pueden ser editados en el diálogo de propiedades.</string>
    <string name="elem_ROMDualPort_pin_A1">Este pin define la dirección de la palabra de datos que va a mostrarse en D1.</string>
    <string name="elem_ROMDualPort_pin_D1">La palabra de datos seleccionada si la entrada s1 está en valor alto.</string>
    <string name="elem_ROMDualPort_pin_s1">Si la entrada está en alto, la salida D1 está activdada. Si está en bajo, la salida de datos estará en estado de alta impedancia.</string>
    <string name="elem_ROMDualPort_pin_A2">Este pin define la dirección de la palabra de datos que va a mostrarse en D2.</string>
    <string name="elem_ROMDualPort_pin_D2">La palabra de datos seleccionada si la entrada s2 está en valor alto.</string>
    <string name="elem_ROMDualPort_pin_s2">Si la entrada está en alto, la salida D2 estará activada. Si está en bajo, la salida de datos estará en estado de alta impedancia.</string>
    <string name="elem_PRNG">Generador de números aleatorios</string>
    <string name="elem_PRNG_tt">Puede emplearse para generar números aleatorios.
		Cuando se inicia la simulación, el generador se reinicia, de forma que una nueva secuencia de números pseudoaleatorios se genera en cada inicio.
		El generador puede lanzarse en la simulación en marcha con un valor de inicio para generar una secuencia de números pseudoaleatorios definida.</string>
    <string name="elem_PRNG_short">PRNG</string>
    <string name="elem_PRNG_pin_S">Nuevo valor de inicio del generador</string>
    <string name="elem_PRNG_pin_se">Activo, se reinicia el generador de números aleatorios con el valor de inciio en el siguiente flanco de subida del reloj.</string>
    <string name="elem_PRNG_pin_ne">Activo, sale un nuevo  número aleatorio en el siguiente flanco de subida del reloj.</string>
    <string name="elem_PRNG_pin_C">Entrada de reloj.</string>
    <string name="elem_PRNG_pin_R">Salida del número pseudoaleatorio</string>
    <string name="elem_GenericInitCode">Inicialización genérica</string>
    <string name="elem_GenericInitCode_tt">Código que se ejecuta para iniciar un circuito genéico.
		Si se va a iniciar un circuito genérico, este componente tiene que estar presente.</string>
    <string name="elem_GenericCode">Código</string>
    <string name="elem_GenericCode_tt">Código que se ejecuta cuando se concreta un circuito genérico.
		Puede usarse, por ejemplo, para añadir componentes o cables a un circuito.</string>
    <string name="err_hdlTestCaseHasGenericCode">¡Casos de prueba con parametrización genérica no están soportados en la exportación a HDL!</string>
    <string name="err_multipleRomsFound">¡Encontradas varias memorias para programas! Solo se permite una memoria para programa.</string>
    <string name="err_noMemoryFound">¡No se ha encontrado la memoria "{0}" en este modelo!</string>
    <string name="err_multipleMemoriesFound">¡Múltiples memorias "{0}" encontradas en el modelo!</string>
    <string name="err_noGenericInitCode">No hay código de inicialización para los componentes genéricos.
		Hay que añadir un componente al circuito para que arranque.</string>
    <string name="err_multipleGenericInitCodes">Múltiples códigos de inicilización para los elementos genéricos.</string>
    <string name="err_inGenericInitCode">Error en el análisis del código de inicialización genérico.</string>
    <string name="err_virtualSignal_N_DeclaredTwiceInLine_N">¡Señal virtual {0} declarada dos veces en la línea {1}!</string>
    <string name="key_remainderPositive">Resto siempre positivo</string>
    <string name="key_remainderPositive_tt">Si está activado, el resto de una división con signo será siempre positivo.</string>
    <string name="key_trigger">Disparador</string>
    <string name="key_trigger_tt">Condición de disparo para la grabación de datos.</string>
    <string name="key_trigger_rising">flanco de subida</string>
    <string name="key_trigger_falling">flanco de bajada</string>
    <string name="key_trigger_both">ambos flancos</string>
    <string name="mod_modifiedByRunningModel">Cambios hechos por la simulación que está en marcha.</string>
    <string name="menu_scale">Fijar escalado</string>
    <string name="msg_supportsHDL">Exportable a VHDL/Verilog.</string>
    <string name="msg_errorSettingModelToTestCase">Error al fijar la fila del caso de prueba.</string>
    <string name="msg_keyAsGenericAttribute">Nombre que se va a usar en circuitos genéricos: {0}</string>
    <string name="attr_createConcreteCircuitLabel">Crear un circuito particular</string>
    <string name="attr_createConcreteCircuit">Crear</string>
    <string name="attr_createConcreteCircuit_tt">Crea un circuito particular a partir de este circuito genérico, usando los parámetros indicados en este elemento.</string>
    <string name="attr_createConcreteCircuitErr">¡Error al crear el circuito particular!</string>
    <string name="msg_fsm_optimizer">Optimizador de FSM</string>
    <string name="menu_fsm_optimize_state_numbers">Optimiza los números de los estados</string>
    <string name="menu_fsm_optimize_state_numbers_tt">Optimiza los números de los estados, de modo que la implementación cueste lo menos posible.
		El tiempo de ejecución se incremente muy lentamente con la complejidad de la máquina (O(n!)).</string>
    <string name="menu_fsm_optimize_state_numbers_err">¡Error durante la optimización!</string>
    <string name="msg_fsm_optimizer_initial">Complejidad inicial:</string>
    <string name="msg_fsm_optimizer_best">Lo mejor hasta ahora:</string>
    <string name="msg_search">búsqueda</string>
    <string name="elem_PinControl">Control de pin</string>
    <string name="elem_RAMAsync">RANm asíncrona</string>
    <string name="elem_RAMAsync_tt">Siempre y cuando se habilite, se almacena. Corresponde a una RAM muy simple, donde las líneas
		de direcciones y de datos están directamente conectadas a los decodificadores de las celdas de memoria.</string>
    <string name="elem_RAMAsync_pin_A">Dirección en la que se produce la lectura o la escritura</string>
    <string name="elem_RAMAsync_pin_D">Datos que se van a almacenar</string>
    <string name="elem_RAMAsync_pin_we">Habilitación de escritura. Siempre y cuando esta entrada esté a 1, el valor aplicado a D se almacena
		en la dirección aplicada a A, tanto si A o D han cambiado o no.</string>
    <string name="elem_RAMAsync_pin_Q">Salida de los datos almacenados</string>
    <string name="err_writeInCodeComponentsOnly">Las variables globales solo se pueden escribir en componentes de código.</string>
    <string name="err_csvNoHeaderFound">¡No se ha encontrado encabezado!</string>
    <string name="err_csvNoOutputValuesFound">¡No se han encontrado valores de salida!</string>
    <string name="err_csvNotEnoughValues">¡No hay suficientes valores en una línea!</string>
    <string name="err_csvToManyValues">¡Demasiados valores en una línea!</string>
    <string name="key_intFormat_fixed">Punto fijo</string>
    <string name="key_intFormat_fixedSigned">Punto fijo con signo</string>
    <string name="key_intFormat_floating">Punto flotante</string>
    <string name="key_fixedPoint">Dígitos de punto fijo</string>
    <string name="key_fixedPoint_tt">Número de dígitos binarios para fracciones</string>
    <string name="key_iverilogOptions">Opciones de IVerilog</string>
    <string name="key_iverilogOptions_tt">Opciones que se usan para todos los pasos de procesamiento con IVerilog.</string>
    <string name="menu_table_exportCSV">CSV</string>
    <string name="menu_table_exportCSV_tt">Fichero CSV que contiene la tabla de verdad completa.</string>
    <string name="menu_table_exportCSVCondensed">CSV, implicantes primos</string>
    <string name="menu_table_exportCSVCondensed_tt">Fichero CSV que contiene solo los implicantes primos</string>
    <string name="msg_truthTableCSV">Valores separados por comas, CSV</string>
    <string name="menu_createBehavioralFixture">Crear caso de prueba para corrección de comportamiento</string>
    <string name="menu_createBehavioralFixture_tt">Crea un accesorio de comportamiento del circuito.
		Un accesorio de comportamiento es un caso de prueba que arregla el comportamiento actual.</string>
    <string name="msg_fixesCreated_N">Accesorios: {0}</string>
    <string name="btn_createTestLine">Crear accesorio</string>
    <string name="btn_createTestLine_tt">Crea un nuevo accesorio en el caso de prueba.</string>
    <string name="btn_BehavioralFixtureComplete">Completo</string>
    <string name="btn_BehavioralFixtureComplete_tt">Crea el componente "caso de prueba"</string>
    <string name="msg_errorCreatingTestCase">Error en la creación del caso de prueba.</string>
    <string name="msg_errorPastingData">¡Error al pegar los datos!</string>
    <string name="elem_Telnet">Telnet</string>
    <string name="elem_Telnet_tt">Permite una conexión Telnet al circuito.
		Es posible recibir y enviar caracteres vía Telnet.</string>
    <string name="elem_Telnet_pin_out">Salida de datos</string>
    <string name="elem_Telnet_pin_av">Muestra un 1 si hay algún dato presente.</string>
    <string name="elem_Telnet_pin_in">El dato que se va a enviar.</string>
    <string name="elem_Telnet_pin_C">Entrada de reloj.</string>
    <string name="elem_Telnet_pin_wr">Si se activa, se envía el byte de datos de entrada.</string>
    <string name="elem_Telnet_pin_rd">Si se activa, se muestra un byte recibido.</string>
    <string name="elem_VGA_short">VGA</string>
    <string name="elem_ExternalFile">Archivo externo</string>
    <string name="elem_ExternalFile_tt">Componente para ejecutar un proceso externo para calcular la función lógica.
		Se usa para especificar el comportamiento de un componente en VHDL o en Verilog.
		La simulación real del comportamiento debe hacerse con un simulador externo.
		De momento, sólo están soportados el simulador ghdl para VHDL y el Icarus Verilog para Verilog.
		¡La etiqueta del componente debe coincidir con el nombre de la entidad o módulo!</string>
    <string name="err_errorLoadingHDLFile_N">Error cargando el archivo HDL {0}</string>
    <string name="err_emptyLabelIsNotAllowed">¡No está permitida una etiqueta vacía!</string>
    <string name="err_errorWritingFile_N">Error escribiendo archivo {0}</string>
    <string name="err_circuitContainsNoComponents">¡El circuito no contiene componentes!</string>
    <string name="err_couldNotCreateServer">¡No se pudo iniciar el servidor!</string>
    <string name="key_small">Forma pequeña</string>
    <string name="key_small_tt">Si se selecciona, se usará una forma más pequeña.</string>
    <string name="key_lastDataFile">Archivo</string>
    <string name="key_lastDataFile_tt">Archivo a cargar en la ROM.</string>
    <string name="key_CodeFile">Código del programa</string>
    <string name="key_CodeFile_tt">El archivo que contiene el código del programa a ejecutar por la aplicación externa.</string>
    <string name="key_probeMode">Modo display</string>
    <string name="key_probeMode_tt">Define si se muestra el valor o un contador.</string>
    <string name="key_probeMode_VALUE">Muestra valor</string>
    <string name="key_probeMode_UP">Cuenta en flanco de subida</string>
    <string name="key_probeMode_DOWN">Cuenta en flanco de bajada</string>
    <string name="key_probeMode_BOTH">Cuenta ambos flancos</string>
    <string name="key_telnetEscape">Modo Telnet</string>
    <string name="key_telnetEscape_tt">Si se activa, se evalúan los comandos de control Telnet.
		Además, el servidor envía los comandos SGA y ECHO. Si esta opción se desactiva,
		el servidor es un simple servidor TCP.</string>
    <string name="key_port">Puerto</string>
    <string name="key_port_tt">Puerto que va a ser abierto por el servidor.</string>
    <string name="key_skipHDL">Saltar la exportación en Verilog/VHDL</string>
    <string name="key_skipHDL_tt">Se salta la generación del interior del circuito en la exportación a Verilog/VHDL.
		Se mantienen las referencias al circuito, haciendo posible anular la implementación.</string>
    <string name="lib_decoration">Decoración</string>
    <string name="lib_generic">Genérica</string>
    <string name="lib_hdl">VHDL/Verilog</string>
    <string name="cli_help_test_verbose">Si se activa, en caso de error se muestra el valor de la tabla.</string>
    <string name="menu_copy_tt">Copiar al portapapeles</string>
    <string name="key_defaultsDC">Fijar los valores no definidos a "X"</string>
    <string name="key_defaultsDC_tt">Pone todos los valores indefinidos (siguiente estado y salidas) como "Indiferente"</string>
    <string name="key_persistTime">Persistencia de la visión</string>
    <string name="key_persistTime_tt">Especifica la duración del resplandor. A mayor valor, mayor la duración del resplandor</string>
    <string name="key_oscillationDetectionCounter">Detección de oscilación</string>
    <string name="key_oscillationDetectionCounter_tt">Cantidad de tiempos de propagación de puerta en el que se detecta una oscilación si el circuito no ha sido estabilizado</string>
    <string name="key_openRemotePort">Permitir conexión remota</string>
    <string name="key_openRemotePort_tt">Si se marca, se abre un puerto TCP/IP, a través del cual se puede controlar el simulador</string>
    <string name="key_remotePort">Número de puerto</string>
    <string name="key_remotePort_tt">Puerto en el que se abre el servidor remoto</string>
    <string name="msg_bigEndian">Big Endian</string>
    <string name="key_bigEndian">Usa big endian en la importación</string>
    <string name="key_bigEndian_tt">Usa el orden del bite big endian en la importación</string>
    <string name="menu_table_createCircuitMore">Variantes del circuito</string>
    <string name="menu_table_maxInputs_N">Usa puertas con un máximo de {0} entradas</string>
    <string name="menu_presentationMode">Modo presentación</string>
    <string name="menu_presentationMode_tt">Modo simplificado que, por ejemplo, omite los casos de prueba, lo cual puede ser útil para presentaciones.</string>
    <string name="menu_find">Encontrar</string>
    <string name="menu_find_tt">Encuentra entiquetas, nombres de redes y números de pines.</string>
    <string name="menu_calcMaxPathLen">Longitud máxima de la ruta</string>
    <string name="menu_calcMaxPathLen_tt">La longitud máxima de la ruta es el camino más largo entre una de las entradas y una de las salidas</string>
    <string name="msg_maxPathLen">El camino más largo tiene {0} puertas.</string>
    <string name="msg_couldNotCalculateMaxPathLen">No se pudo calcular la longitud del camino.</string>
    <string name="key_source">Origen de datos</string>
    <string name="key_source_noData">no se cargan datos</string>
    <string name="key_source_file">archivo</string>
    <string name="key_source_dataField">datos almacenados</string>
    <string name="err_could_not_load_rom">¡No se pudieron cargar datos de la ROM!</string>
</resources>
