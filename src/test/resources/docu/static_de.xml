<?xml version="1.0" encoding="UTF-8" ?>
<root>
    <chapter heading="Digital">
        <subchapter heading="Einführung">
            <par>
                Digital ist ein Simulator für digitale Schaltkreise. Ein Schaltung besteht dabei aus einer
                Anzahl logischer Gatter, welche miteinander durch Leitungen verbunden sind.
                Das Verhalten der Gesamtschaltung kann simuliert werden.
                Der Anwender kann mit der laufenden Simulation über bestimmte Elemente interagieren, indem er z.B.
                Knöpfe betätigt oder Eingangswerte setzt.
            </par>
            <par>
                Auf diese Weise können die meisten Grundschaltungen der Digitaltechnik aufgebaut werden. Im Ordner
                <e>examples</e>
                finden sich viele Beispiele bis hin zum funktionsfähigen 16-Bit Single Cycle Harvard Prozessor.
            </par>
            <par>
                Der Simulator kennt dabei zwei Modi: Im Bearbeitungsmodus kann die Schaltung bearbeitet werden.
                In diesem Modus ist die eigentliche Simulation nicht aktiv.
                Der Simulationsmodus wird durch den <e>Start</e>-Knopf aktiviert. Beim Wechsel in diesen Modus wird die
                Schaltung zunächst auf Konsistenz überprüft.
                Enthält die Schaltung keine Fehler, wird die Simulation aktiviert.
                Jetzt kann mit der laufenden Simulation interagiert werden.
                Möchte man die Schaltung weiter bearbeiten, muss man die Simulation zunächst wieder stoppen.
            </par>
        </subchapter>
        <subchapter heading="Erste Schritte">
            <par><image src="scr00.png"/></par>
            <par>
                Als erstes Beispiel soll eine Schaltung mit einem Exklusiv-Oder Gatter aufgebaut werden.
                Im Hauptfenster erlaubt das Menü <e>Bauteile</e>, die verschiedenen Komponenten auszuwählen.
                Danach werden diese auf dem Zeichenfeld positioniert. Das Positionieren kann mit der ESC-Taste
                jederzeit abgebrochen werden.
                Als erstes soll der Schaltung ein Eingang hinzugefügt werden. Dieser lässt sich später interaktiv
                mit der Maus steuern.
            </par>
            <par><image src="scr01.png"/></par>
            <par>
                Nach der Auswahl kann der erste Eingang auf die Zeichenfläche gesetzt werden.
                Der rote Punkt markiert den Leitungsanschluss. Hier wird später eine Verbindungsleitung
                angeschlossen. Rot zeigt an, dass dieser Anschluss aktiv ist. Er definiert also einen
                Signalwert.
            </par>
            <par><image src="scr02.png"/></par>
            <par>
                Auf die gleiche Art und Weise wird ein zweiter Eingang hinzugefügt. Am besten setzt man
                ihn direkt unter den ersten Eingang.
            </par>
            <par><image src="scr03.png"/></par>
            <par>
                Danach wird das Exklusiv-Oder Gatter ausgewählt. Dieses Gatter stellt die eigentliche
                logische Funktion dar.
            </par>
            <par><image src="scr04.png"/></par>
            <par>
                Dieses kann nun ebenfalls in die Schaltung eingefügt werden. Am besten setzt man es so,
                dass die spätere Verdrahtung möglichst einfach wird. Die blauen Punkte bezeichnen die
                Eingänge des Gatters.
            </par>
            <par><image src="scr05.png"/></par>
            <par>
                Jetzt wählt man einen Ausgang aus. Dieser kann verwendet werden, um einen Zustand
                anzuzeigen oder um später Signale an eine einbettende Schaltung weiterzugeben.
            </par>
            <par><image src="scr06.png"/></par>
            <par>
                Auch der Ausgang wird so positioniert, dass die Verdrahtung möglichst einfach wird.
                Er hat einen blauen Punkt, verfügt also über einen Eingang.
            </par>
            <par><image src="scr07.png"/></par>
            <par>
                Damit sind alle erforderlichen Komponenten vorhanden. Jetzt ist die Verdrahtung zu ergänzen.
                Mit der Maus kann direkt eine Verbindungsleitung gezogen werden. Die blauen und roten
                Punkte sind miteinander zu verbinden. Es muss dabei immer genau ein roter Punkt mit einer beliebigen
                Anzahl blauer Punkte verbunden werden. Nur der Einsatz von Threestate-Ausgängen erlaubt es,
                von dieser Regel abzuweichen und mehrere rote Punkte miteinander zu verbinden.
                Verbindungsleitungen werden immer senkrecht oder waagerecht gezogen. Mit der
                Taste 'D' kann in den Diagonalmodus gewechselt werden.
                Sind alle noch fehlenden Leitungen ergänzt, ist eine erste Schaltung komplett.
            </par>
            <par><image src="scr08.png"/></par>
            <par>
                Um mit der Schaltung interagieren zu können, ist die Simulation zu starten. Dazu kann der
                Start-Knopf in der Toolbar verwendet werden.
                Nach dem Starten der Simulation ändert sich die Farbe der Leitungen und die Ein- und Ausgänge
                sind jetzt ausgefüllt. Ein helles Grün markiert eine logische '1' und ein dunkles Grün eine
                logische '0'. In obiger Abbildung findet sich auf allen Leitungen eine logische '0'.
            </par>
            <par><image src="scr09.png"/></par>
            <par>
                Durch Klicken mit der Maus können die Eingänge umgeschaltet werden. Da die Simulation jetzt
                aktiv ist, verändert sich der Ausgang entsprechend der aktuellen Eingangszustände.
                Die Schaltung verhält sich wie erwartet wie ein XOR-Gatter.
            </par>
            <par><image src="scr10.png"/></par>
            <par>
                Um die Schaltung weiter bearbeiten zu können, muss die Simulation zunächst gestoppt werden.
                Dies geschieht am einfachsten mit dem Stopp-Knopf in der ToolBar.
                Durch Klicken mit der rechten Maustaste auf eine Komponente (Control-Click unter MacOS) öffnet sich
                ein Dialog, welcher die Eigenschaften dieser Komponente anzeigt. Für den ersten Eingang kann über
                diesen Dialog die Bezeichnung 'A' festgelegt werden.
            </par>
            <par><image src="scr11.png"/></par>
            <par>
                Auf diese Weise können die Bezeichnungen für die übrigen Ein- und Ausgänge definiert werden.
                Im Hauptmenü im Menü <e>Analyse</e> findet sich der Menüpunkt <e>Analyse</e>. Dieser ermittelt
                die Wahrheitstabelle der aktuellen Schaltung.
                Diese kann nur ermittelt werden, wenn alle Ein- und Ausgänge mit einer Bezeichnung versehen sind.
            </par>
            <par><image src="scr12.png"/></par>
            <par>
                Es öffnet sich ein Fenster, welches die Wahrheitstabelle der aktuellen Schaltung zeigt. Unter der
                Tabelle findet sich der algebraische Ausdruck, welcher zu der Schaltung gehört. Gibt es mehrere
                mögliche algebraische Ausdrücke, öffnet sich ein separates Fenster, welches alle Ausdrücke
                anzeigt.
            </par>
            <par><image src="scr13.png"/></par>
            <par>
                Der Tabellendialog hat in seinem Hauptmenü den Menüeintrag <e>KV-Tafel</e>. Über diesen lässt sich die
                Wahrheitstabelle in Form einer KV-Tafel anzeigen.
            </par>
            <par><image src="scr14.png"/></par>
            <par>
                Oben in diesem Dialog gibt es eine Auswahlbox, über welche der gewünschte Ausdruck in der KV-Tafel
                ausgewählt werden kann. Auf diese Weise lässt sich z.B. verdeutlichen, wie sich mehrere äquivalente
                algebraische Ausdrücke ergeben können. In diesem Beispiel gibt es jedoch nur einen minimalen Ausdruck.
                Durch Klicken in der KV-Tafel lässt sich die Wahrheitstabelle bearbeiten.
            </par>
        </subchapter>
        <subchapter heading="Verbindungsleitungen">
            <par>
                Alle Elemente müssen über Leitungen verbunden werden. Es ist nicht möglich, zwei Elemente direkt
                miteinander zu verbinden, indem man sie direkt nebeneinander platziert.
            </par>
            <par>
                Zudem gibt es nur Verbindungen zwischen einem Leitungsende und einem Bauteil. Wird ein Bauteil mitten
                auf eine Leitung gesetzt, wird keine Verbindung zwischen dem Bauteil und der Leitung hergestellt.
                Daher muss an jedem Bauteileanschluss, welcher mit einem anderen verbunden werden soll, eine Leitung
                tatsächlich enden bzw. beginnen.
                Selbst wenn das Tunnel-Element verwendet wird, muss es eine Leitung zwischen dem Pin und dem
                Tunnel-Element geben.
            </par>
            <par>
                Soll ein Element incl. der angeschlossenen Verbindungsleitungen verschoben werden, ist das Element mit
                der Rechteckauswahl auszuwählen. Danach lässt es sich mit der Maus verschieben. Wenn ein Element
                per Mausklick selektiert wird, wird nur das Bauteil allein - also ohne die angeschlossenen Leitungen
                mitzunehmen - verschoben.
            </par>
            <par>
                Mit STRG-Click kann ein einzelner Leitungsabschnitt selektiert werden, um diesen zu verschieben oder zu
                löschen.
                Wird beim Zeichnen einer Leitung die Taste D gedrückt, kann eine diagonale Leitung gezogen werden.
                Die Taste S erlaubt das aufsplitten eines Leitungssegments in zwei Segmente.
            </par>
        </subchapter>
        <subchapter heading="Hierarchisches Design">
            <par>
                Wenn eine komplexe Schaltung aufgebaut wird, kann diese schnell sehr unübersichtlich werden.
                Um hier die Übersicht zu behalten, können die verschiedenen Teile einer Schaltung in unterschiedlichen
                Dateien gespeichert werden. Dieser Mechanismuss erlaubt es auch, eine einmal erstellte Teilschaltung
                mehrfach in einer weiteren Schaltung zu verwenden. Dieses Vorgehen bietet zudem den Vorteil, dass die
                Dateien unabhängig voneinander in einem Versionskontrollsystem abgelegt und Änderungen verfolgt werden
                können.
            </par>
            <par><image src="scr20.png"/></par>
            <par>
                Als Beispiel sei ein 4 Bit Addierer betrachtet: Zunächst wir ein einfacher Halbaddierer aufgebaut.
                Dieser besteht aus einem XOR-Gatter und einem UND-Gatter. Die Summe der beiden Bits 'A' und 'B' wird
                an den Ausgängen 'S' und 'C' ausgegeben. Diese Schaltung wird in der Datei <e>halfAdder.dig</e>
                gespeichert.
            </par>
            <par><image src="scr21.png"/></par>
            <par>
                Aus zwei Halbaddierern kann nun ein Volladdierer aufgebaut werden. Dazu erzeugt man eine neue leere
                Datei und speichert die leere Datei unter dem Name <e>fullAdder.dig</e> im selben Ordner wie zuvor den
                Halbaddierer. Danach kann der Halbaddier über das Menu <e>Bauteile</e><arrow/><e>Benutzerdefiniert</e>
                der neuen Schaltung hinzugefügt werden.
                Die Reihenfolge der Pins am Gehäuse des Halbaddierers kann im Halbaddierer im Menu
                <e>Bearbeiten</e><arrow/><e>Sortieren der Eingänge</e> bzw. <e>Bearbeiten</e><arrow/><e>Sortieren der Ausgänge</e>
                verändert werden.
                Der Volladdierer addiert die drei Bits 'A', 'B' und 'Ci' und gibt die Summe an 'S' und 'Co' aus.
            </par>
            <par><image src="scr22.png"/></par>
            <par>
                Um die korrekte Funktion des Volladdierers zu überprüfen, sollte ein Testfall angelegt werden.
                Im Testfall wird die Warheitstabelle hinterlegt, welche die Schaltung erfüllen soll. Auf diese Weise
                kann automatisch überprüft werden, ob das tatsächlich der Fall ist.
            </par>
            <par><image src="scr23.png"/></par>
            <par>
                Über den Testfall-Editor oder den Testknopf in der Toolbar können die Tests ausgeführt werden.
                Die in der Tabelle grün hinterlegten Felder zeigen an, dass die Ausgabe der Schaltung mit der Vorgabe
                in der Wertetabelle des Testfalls übereinstimmt.
            </par>
            <par><image src="scr24.png"/></par>
            <par>
                Nun lassen sich die Volladdierer zu einem so gen. Ripple-Carry Addierer zusammensetzen. Dabei wird
                der Carry-Ausgang einer Addition als Carry-Eingang an die Addition des nächst höherwertigen Bits
                weitergegeben, genau so, wie es bei der schriftlichen Addition üblich ist. Dieser 4-Bit Addierer soll
                auf korrekte Funktion überprüft werden. Dazu wurde auch hier ein Testfall eingefügt.
            </par>
            <par><image src="scr25.png"/></par>
            <par>
                Dieser Testfall führt einen 100% Test durch, was nur bei relativ einfachen Schaltungen möglich ist:
                Alle möglichen 512 Eingangskombinationen werden an die
                Schaltung angelegt, und es wird überprüft, ob die Ausgabe der Schaltung korrekt ist.
                In der ersten Zeile sind die Eingangs- und Ausgangssignale aufgelistet. Darunter würden in je einer Zeile
                die anzulegenden Eingangswerte und die zu überprüfenden Ausgangswerte angegeben, wie in einer Wahrheitstabelle.
                In diesem Beispiel sind jedoch 512 Zeilen erforderlich.
                Diese einzugeben, wäre eine mühsame und fehleranfällige Aufgabe.
                Einfacher und zuverlässiger ist es, die erforderlichen Zeilen automatisch erzeugen zu lassen.
                Dazu werden die
                Variablen <e>A</e> und <e>B</e> jeweils von 0 bis 15 durchlaufen. Die jeweiligen Werte von <e>A</e> und
                <e>B</e> werden dann den Eingängen 'A[n]' und 'B[n]' zugewiesen. Dann wird überprüft, ob die Schaltung den
                Wert <e>A+B</e> ausgibt. Das wird dann noch einmal mit gesetztem Carry-Bit geprüft, wobei sich
                in diesem Fall <e>A+B+1</e> ergeben muss. Die Details der Test-Syntax liefert der Hilfe-Dialog.
            </par>
            <par>
                Wird eine Schaltung in eine andere eingebunden, wird in der einbindenden Schaltung nur
                der Dateiname gespeichert, nicht die Schaltung selbst. Die entsprechenden
                Dateien der eingebundenen Schaltungen müssen daher zur Laufzeit der Simulation im Dateisystem
                gefunden werden. Um die verschiedenen Arbeitsweisen der Nutzer bestmöglich zu unterstützen und dennoch
                auf eine komplexe Verwaltung von Importpfaden usw. zu verzichten, ist eine etwas ungewöhnliche
                Import-Strategie implementiert.
            </par>
            <par>
                In einer Schaltung sind nur die Dateinamen der eingebetteten Schaltungen gespeichert, kein kompletter
                Pfad. Soll die Datei geöffnet werden,
                werden alle Unterordner nach einer Datei des entsprechenden Namens durchsucht. Wird
                eine passende Datei gefunden, wird diese importiert. Dabei kommt es nur auf den Dateinamen der
                einzulesenden
                Datei an, nicht auf deren Pfad. Entsprechend wird eine Fehlermeldung erzeugt, wenn sich in
                verschiedenen
                Unterordnern mehrere Dateien gleichen Namens befinden, da dann Mehrdeutigkeiten entstehen.
            </par>
            <par>
                Eine geeignete Projektstruktur sieht daher wie folgt aus: In einem eigenen Ordner befindet sich die
                Wurzelschaltung. Alle importierten Schaltungen müssen sich im selben Ordner oder in Unterordnern
                befinden.
                Alle Schaltungen müssen unterschiedliche Namen haben, es darf also nicht vorkommen, dass sich in
                verschiedenen Ordnern Schaltungen gleichen Namens befinden.
            </par>
        </subchapter>
    </chapter>
    <chapter heading="Simulation">
        <subchapter heading="Gatterlaufzeiten">
            <par>
                Bei der Simulation wird davon ausgegangen, dass jedes Gatter eine bestimmte Laufzeit hat, und dass diese
                Laufzeit für alle Gatter identisch ist. Die Laufzeit eines jeden Elementes aus der Bibliothek hat
                genau diese Laufzeit, unabhängig von seiner Komplexität.
                Das Und-Gatter hat also dieselbe Signalverzögerung wie der Multiplizierer.
                Ausgenommen davon sind Dioden, Leitungssplitter für die Erzeugung von Datenbussen und
                Schalter. Diese Elemente haben keine Gatterlaufzeit bzw. diese beträgt Null.
            </par>
            <par>
                Soll ein Gatter - z.B. der Multiplikator - mit einer längeren Laufzeit versehen werden, muss in die
                Schaltung ein Verzögerungsglied am Ausgang des Multiplikators eingefügt werden.
            </par>
            <par>
                Wird eine Schaltung in eine andere Schaltung eingebettet, um ein hierarchisches Design zu erstellen,
                behalten die eingebetteten Schaltungen ihre Laufzeiten. Wird also ein komplexes Schaltnetz
                eingebettet, bei welchem ein Signal
                von einem Eingang bis zu einem Ausgang drei Gatter passiern muss, beträgt dessen Laufzeit auch als
                eingebettete Schaltung drei Gatterlaufzeiten. Es gibt keine zusätzlichen Verzögerungen durch
                das Einbetten einer Schaltung. Sind nicht alle Ausgangssignale einer eingebetteten Schaltung gleich
                schnell, werden sich die Signale in der einbettenden Schaltung ebenso verhalten.
                Generell verändert das Einbetten einer Schaltung in eine andere deren Laufzeitverhalten nicht. Die
                Schaltung verhält sich exakt so, als befänden sich alle Elemente auf derselben Ebene.
            </par>
        </subchapter>
    </chapter>
    <chapter heading="Analyse">
        <subchapter heading="Schaltungsanalyse und Synthese">
            <par>
                Eine vorliegende Schaltung kann über den Menüeintrag <e>Analyse</e> analysiert werden. Bei rein
                kombinatorischen Schaltungen wird eine Wahrheitstabelle erzeugt. Diese Wahrheitstabelle kann beliebig
                bearbeitet werden.
                Aus dieser Wahrheitstabelle lässt sich nach einer Bearbeitung eine neue Schaltung erzeugen.
            </par>
            <par>
                Neben rein kombinatorischen Schaltungen lassen sich auch Schaltwerke analysieren bzw. erzeugen.
                Anstelle einer einfachen Wahrheitstabelle entsteht eine sogenannte Zustandsfolgetabelle.
                Jedes Flipflop taucht dabei auf der
            Eingangsseite und der Ausgangsseite der Zustandsfolgetabelle auf. In dieser Tabelle findet sich auf der
            rechten Seite der abhängigen Signale der Folgezustand, der nach dem nächsten Taktsignal eintreten wird,
            abhängig vom aktuellen Zustand der Flipflops. Damit eine Analyse möglich ist, müssen die Flipflops benannt
            werden.
        </par>
        <par>
            Dabei gilt folgende Namenskonvention: Der Folgezustand eines Bits auf der rechten Seite der Tabelle wird
            durch ein angehängtes kleines 'n+1' gekennzeichnet. Der dazu gehörige aktuelle Zustand wird durch ein
            angehängtes 'n' ausgezeichnet. Gibt es also eine Zustandsvariable 'A', dann kennzeichnet 'An' den aktuellen
            Zustand und 'An+1' den Folgezustand. Finden sich in der Wahrheitstabelle auf der linken und rechten Seite
            Signale,
            die diesem Muster entsprechen, wird davon ausgegangen, dass es sich um eine Zustandsfolgetabelle handelt und
            bei der Synthese wird entsprechend ein Schaltwerk anstelle eines Schaltnetzes erzeugt.
        </par>
            <par>
                Zu beachten ist dabei, dass die zu analysierende Schaltung neben den eingebauten D- und JK-Flipflops nur
                rein kombinatorische Elemente enthalten darf. Wird ein Flipflop z.B. aus NOR-Gattern aufgebaut, kann
                diese
                Schaltung nicht als Flipflop erkannt und daher auch nicht entsprechend analysiert werden.
            </par>
        </subchapter>
        <subchapter heading="Ausdrücke">
            <par>
                Über den Menüeintrag <e>Ausdruck</e> ist es möglich, eine Boolsche Funktion einzugeben und diese dann
                in eine Schaltung überführen zu lassen.
            </par>
        </subchapter>
        <subchapter heading="Zustandsdiagramme">
            <par>
                Über den Menüeintrag <e>Endlicher Automat</e> ist ein Editor für Zustandsdiagramme verfügbar.
                Dieser elaubt die grafische Erstellung von Zustandsautomaten indem Zustände und Zustandsübergänge
                gezeichnet werden.
                Dabei können in den verschiedenen Zuständen unterschiedliche Ausgänge gesetzt werden.
                Indem Übergänge mit Bedingungen versehen werden, können Eingangssignale erzeugt werden.
                Da Ausgangswerte auch an Übergängen gesetzt werden können, is es möglich, auch Mealy-Automaten zu
                erstellen.
            </par>
            <par>
                Der auf diese Weise definierte Automat kann dann automatisiert in eine Zustandsübergangstabelle
                überführt
                werden, aus welcher dann in einem weiteren Schritt eine Schaltung erzeugt werden kann, welche den
                ursprünglichen Automaten implementiert.
                Wird dann die Simulation dieser Schaltung gestartet, lässt sich der aktuelle Zustand auch im
                noch geöffneten Zustandsdiagramm verfolgen.
            </par>
        </subchapter>
    </chapter>
    <chapter heading="Hardware">
        <subchapter heading="GAL16v8 bzw. GAL22v10">
            <par>
                Im Menü der Schaltungserzeugung der Warheitstabelle finden sich auch Funktionen um so gen. JEDEC Dateien
                zu erzeugen. Dabei handelt es sich
                um ein spezielles Dateiformat, welches die Fuse-Map eines PLD beschreibt. Diese JEDEC Datei kann
                mit Hilfe eines speziellen Programmers in ein entsprechendes PLD geschrieben werden, um dieses zu
                konfigurieren.
                Zur Zeit werden Bausteine des Typs <e>GAL16v8</e> und <e>GAL22v10</e> bzw. Fuse-Map-Kompatible
                Bausteine unterstützt.
            </par>
        </subchapter>
        <subchapter heading="ATF150xAS">
            <par>
                Die Bausteine der
                <a href="https://www.microchip.com/design-centers/programmable-logic/spld-cpld/cpld-atf15xx-family">
                    <e>ATF150x</e></a>-Familie
                sind einfache CPLDs mit bis zu 128 Makrozellen. Diese sind im PLCC Gehäuse verfügbar, was sie
                für Laborversuche gut geeignet erscheinen lässt:
                Sollte ein IC bei Versuchen zerstört werden, kann es einfach ersetzt werden.
                Zudem ist mit dem
                <a href="https://www.microchip.com/design-centers/programmable-logic/spld-cpld/tools/hardware/atdh1150usb">
                    <e>ATDH1150USB</e>
                </a>
                ein einfach zu benutzender, günstiger Programmer erhältlich, mit welchem der Baustein in seiner Schaltung
                (In System) programmiert werden kann. Mit dem
                <a href="https://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=ATF15XX-DK3-U">
                    <e>ATF15XX-DK3-U</e>
                </a>
                ist zudem ein geeignetes Evaluations-Board verfügbar.
                Für die Programmierung ist die Software
                <a href="https://www.microchip.com/design-centers/programmable-logic/spld-cpld/tools/software/atmisp">
                    <e>ATMISP</e>
                </a>
                erforderlich, welche auf der ATMEL/Microchip Webseite erhältlich ist.
            </par>
            <par>
                Leider sind die Details der Fuse-Map nicht öffentlich zugänglich, so dass kein geeigneter Fitter für
                diesen Baustein in Digital integriert werden kann, wie das bei den <e>GAL16v8</e> und
                <e>GAL22v10</e>
                Bausteinen möglich ist.
            </par>
            <par>
                Daher muss auf einen der von ATMEL bereitgestellten Fitter <e>fit150[x].exe</e> zurückgegriffen werden.
                Diese Programme erzeugen aus einer geeigneten <e>TT2</e> Datei eine <e>JEDEC</e>-Datei, welche dann
                in den entsprechenden Chip übertragen werden kann.
                Digital startet den Fitter automatisch, wenn eine <e>TT2</e> Datei erzeugt wird. Dazu muss in den
                Digital-Einstellungen der Pfad zu den <e>fit150[x].exe</e> Dateien angegeben werden.
                Es wird zudem eine Projektdatei <e>*.chn</e> erzeugt, welche dann direkt mit
                <a href="https://www.microchip.com/design-centers/programmable-logic/spld-cpld/tools/software/atmisp">
                    <e>ATMISP</e>
                </a>
                geöffnet werden kann, um die <e>JEDEC</e>-Datei zu brennen.
            </par>
            <par>
                Aus rechtlichen Gründen können die Fitter <e>fit150[n].exe</e> nicht mit Digital ausgeliefert werden.
                Diese finden sich jedoch nach der Installation von
                <a href="https://www.microchip.com/design-centers/programmable-logic/spld-cpld/tools/software/wincupl">
                    <e>WinCupl</e>
                </a>
                im Ordner <e>WinCupl\Fitters</e>.
                <a href="https://www.microchip.com/design-centers/programmable-logic/spld-cpld/tools/software/wincupl">
                    <e>WinCupl</e>
                </a>
                wiederum ist auf der ATMEL/Microchip Webseite verfügbar.
                Unter Linux lassen sich die Fitter ebenfalls von Digital starten, wenn <e>wine</e> installiert
                ist.
            </par>
        </subchapter>
        <subchapter heading="Export zu VHDL oder Verilog">
            <par>
                Eine Schaltung kann zu VHDL oder Verilog exportiert werden. Dabei wird eine Datei erzeugt,
                welche die komplette Beschreibung der Schaltung enthält. Der erzeugte VHDL Code wurde mit
                <a href="https://www.xilinx.com/products/design-tools/vivado.html">Xilinx Vivado</a>
                und dem Open Source VHDL Simulator <a href="http://ghdl.free.fr/">ghdl</a> getestet.
                Der Verilog Code mit dem Verilog Simulator <a href="http://iverilog.icarus.com/">Icarus Verilog</a>.
            </par>
            <par>
                Wenn eine Schaltung Testfälle enthält, wird anhand der Testdaten eine Test-Bench erzeugt.
                Diese kann verwendet werden, um die korrekte Funktion der Schaltung in einer HDL-Simulation zu
                überprüfen.
            </par>
            <par>
                Für spezielle Boards können zusätzliche Dateien erzeugt werden. Zur Zeit werden nur das
                <a href="https://reference.digilentinc.com/reference/programmable-logic/basys-3/start">BASYS3</a>
                Board und die Boards <a href="https://numato.com/product/mimas-spartan-6-fpga-development-board">Mimas</a>
                und <a href="https://numato.com/product/mimas-v2-spartan-6-fpga-development-board-with-ddr-sdram">Mimas V2</a> unterstützt.
                Dabei wird eine Constraints-Datei erzeugt, welche die Zuordnung der Pins beinhaltet. Die Bezeichnung der
                Pins kann den entsprechenden Datenblättern entnommen werden und ist als Pinnummer bei den Ein- und Ausgängen
                einzutragen.
            </par>
            <par>
                Beim BASYS3 Board wird, wenn die Taktfrequenz niedrig ist, ein Frequenzteiler in den HDL Code integriert,
                um den Boardtakt entsprechend zu teilen. Wenn die in der Schaltung gewählte Taktfrequenz über 4.7MHz
                liegt, wird die MMCM Einheit des Artix-7 zur Takterzeugung verwendet.
                Dies stellt sicher, dass die für die Taktverteilung vorgesehenen FPGA-Resourcen auch tatsächlich
                verwendet werden.
                Der enthaltene Beispiel-Prozessor läuft z.B. mit 20MHz, und wenn auf den Multiplizierer in der ALU
                verzichtet werden kann, sind auch 30MHz möglich.
            </par>
            <!--par>
                Auch bei den Mimas-Boards wird der Spartan 6 DCM für die Takterzeugung verwendet.
            </par-->
            <par>
                Soll eine Schaltung auf einem BASYS3 Board betrieben werden, wird eine Vivado Projektdatei angelegt,
                die direkt mit Vivado geöffnet werden kann. Es lässt sich dann  der Bitstream erzeugen und mit dem
                Hardware-Manager kann dieser in ein BASYS3 Board übertragen werden.
            </par>
            <par>
                Um neben der HDL Datei auch die erforderliche Constraints-Datei erzeugen zu lassen, muss in den
                Einstellungen das Entsprechende Board konfiguriert werden. Dazu kann im Feld "Toolchain Konfiguration"
                die entspechende XML-Datei ausgewählt werden. Die verfügbaren Konfgurationen finden sich im Ordner
                <e>examples/hdl</e> und haben die Dateiendung <e>.config</e>.
                Wurde die Konfiguration erfolgreich eingebunden, erscheint ein weiteres Menü, welches die
                Board-Spezifischen Funktionen zugänglich macht.
            </par>
        </subchapter>
    </chapter>
    <chapter heading="Benutzerdefinierter Schaltungssymbole">
        <par>
            Digital bietet zwar einige Optionen, die die Erscheinungsform einer Schaltung festlegen, wenn diese
            in eine andere eingebettet wird, in manchen Fällen kann es jedoch sinnvoll sein, ein spezielles
            eigenes Symbol für eine Teilschaltung zu verwenden.
            Ein Beispiel ist die Darstellung der ALU in dem Prozessor, welcher in den Beispielen enthalten ist.
            In diesem Kapitel wird beschrieben, wie eine solches spezielles Symbol für eine Schaltung definiert wird.
        </par>
        <par>
            Digital bietet keinen Editor für das Erstellen eines speziellen Symbols an. Statt dessen ist ein kleiner
            Umweg für das Erstellen von Schaltungssymbolen erforderlich:
            Zunächst wird die Schaltung geöffnet, welche durch ein spezielles Symbol repräsentiert werden soll.
            Dann wird für diese Schaltung ein SVG-Template erstellt. In diesem Template wird die Schaltung durch
            ein einfaches Rechteck repräsentiert. Es finden sich darin auch alle Pins der Schaltung,
            repräsentiert durch blaue (Eingänge) und rote (Ausgänge) Kreise.
            Um zu sehen, welcher Kreis zu welchem Pin gehört, kann man sich in den Objekteigenschaften die ID des
            Kreises ansehen. Diese ID hat die Form <e>pin:[Name]</e> oder <e>pin+:[Name]</e>. Bei der letzteren
            Variante wird der Pin beim Reimport zu Digital mit einem Label versehen. Wünscht man kein solches Label,
            kann das <e>+</e> entfernt werden.
        </par>
        <par>
            Diese SVG-Datei kann jetzt bearbeitet werden. Am besten geeignet ist das Open-Source Programm
            <a href="https://inkscape.org/de/">Inkscape</a> welches kostenlos verfügbar ist.
            Die Pins können frei verschoben werden, werden jedoch beim Reimport auf den nächstgelegenen Rasterpunkt
            verschoben.
        </par>
        <par>
            Wenn schon existierende SVG Dateien verwendet werden sollen, ist es das einfachste das erstellte
            Template zu öffnen, und die bereits vorhandene Grafik per Copy&amp;Paste in das Template einzufügen.
        </par>
        <par>
            Wenn die Datei gespeichert wurde, kann diese mit Digital importiert werden. Dabei wird die Datei
            eingelesen und alle notwendigen Informationen werden extrahiert und in der Schaltung gespeichert.
            Für die weitere Verwendung der Schaltung ist die SVG-Datei also nicht mehr erforderlich.
        </par>
        <par>
            Noch eine Anmerkung: SVG ist ein sehr mächtiges und flexibles Dateiformat. Es können extrem
            komplexe Grafiken damit beschrieben werden. Der in Digital integrierte Importer ist nicht in der
            Lage alle denkbaren SVG-Dateien fehlerfrei zu importieren. Wenn eine Datei nicht importiert werden kann,
            oder nicht so erscheint wie erwartet, ist evtl. einiges Experimentieren erforderlich, bevor das
            gewünschte Ergebnis erreicht ist.
        </par>
    </chapter>
    <chapter heading="Generische Schaltungen">
        <par>
            Es kommt vor, dass eine Teilschaltung erstellt wurde, und diese soll in
            veschiedenen Varianten verwendet werden. Vorstellbar ist z.B. ein spezieller Zähler, der für verschiedene
            Bitbreiten benötigt wird. Würde man nun je eine Teilschaltung für 4,5 und 6 Bits erstellen, wäre die
            Pflege der Schaltung in Zukunft schwierig, da bei jeder Änderung mehrere Teilschaltungen zu bearbeiten sind,
            die bis auf einen Parameter - die Bitbreite - identisch sind.
        </par>
        <par>
            Um dies zu verhindern, kann eine generische Teilschaltung erstellt werden, die sich parametrisieren
            lässt. Dazu muss in den Schaltungseinstellung der Schaltung das Häckchen "Schaltung ist generisch" gesetzt
            werden. Danach enthält der Parameter-Dialog jeder Komponente der Schaltung das zusätzliche Feld
            "generische Parametrisierung". In diesem Feld kann Programmcode angegeben werden, welcher die Parameter
            der Komponente verändern kann. Jeder Parameter hat einen Namen und kann als Attribut des Feldes <e>this</e>
            modifiziert werden. Wie die Parameter benannt sind, kann dem Hilfedialog der Komponente entnommen werden.
            Möchte man die Bitbreite eines Addierers ändern, kann die Zeile <e>this.Bits=1;</e> verwendet werden.
        </par>
        <par>
            Auf diese Weise kann man jedoch noch keine parametrisierbare Schaltung erstellen. Es ist noch erforderlich
            auf Parameter zuzugreifen, die gesetzt werden, wenn die Schaltung verwendet wird. Dies geschieht über das
            Feld "args". Will man die Bitbreite von außen setzen, kann man schreiben: <e>this.Bits=args.bitWidth;</e>.
            Der Name des Argumentes - hier <e>bitWidth</e> - ist dabei beliebig. Wenn diese Teilschaltung verwendet wird,
            ist dieses Argument zu setzen.
        </par>
        <par>
            Wird die Schaltung verwendet, und der Parameter-Dialog der eingebetteten Schaltung geöffnet, hat auch
            dieser ein Feld "generische Parametrisierung". Hier kann mit der Anweisung <e>bitWidth:=5;</e> die zu
            verwendende Bitbreite gesetzt werden.
        </par>
        <par>
            Wenn eine generische Schaltung direkt gestartet werden soll, ist das ohne Weiteres nicht möglich, da die
            erforderlichen Argumente fehlen, die bei der Einbettung der Schaltung angegeben werden müssen.
            Diese fehlenden Argumente würden zu entsprechenden Fehlermeldungen führen.
            Um den Test der Schaltung zu vereinfachen, kann daher die
            Komponente <e>Generische Initialisierung</e> der Schaltung hinzugefügt werden. In dieser Komponente lassen sich
            die Argumente setzen, die aus einer einbettenden Schaltung kommen würden.
            Auf diese Weise kann auch eine generische Schaltung direkt simuliert werden, was die Erstellung sehr
            erleichtert. Wird die Schaltung eingebettet, wird diese Komponente ignoriert.
            Sie wird nur für den direkten Start der Simulation benötigt.
        </par>
        <par>
            Unter Umständen kann es sinnvoll sein, nicht nur die Attribute der Komponenten einer Schaltung zu verändern,
            sondern ganz neue Komponenten und Leitungen abhängig von den übergebenen Argumenten hinzuzufügen.
            Dazu kann die Komponente <e>Code</e> verwendet werden. Wird sie der Schaltung hinzugefügt, wird der enhaltene
            Code beim Start der Simulation ausgeführt.
            Hier kann mit der Funktion <e>addWire([x1],[y1],[x2],[y2])</e> eine Leitung hinzugefügt werden und über
            die Funktionen <e>addComponent([Name],[x],[y])</e> kann eine neue Komponente <e>[Name]</e> an der
            Position ([x],[y]) hinzugefügt werden. Der Rückgabewert der Funktion <e>addComponent([Name],[x],[y])</e>
            erlaubt das Setzen der Parameter der Komponente.
        </par>
        <par>
            Die Beispielschaltung <e>examples/generic/modify/Conway/GenericConway.dig</e> zeigt, wie auf diese Weise
            auch eine komplexere Schaltung zusammengesetzt werden kann.
        </par>
        <par>
            Eine andere Möglichkeit eine Schaltung zu erzeugen ist Rekursion: Es ist möglich, abhängig von den Argumenten,
            eine Schaltung durch eine andere zu ersetzen. Zu diesem Zweck steht die Funktion <e>setCircuit([Name])</e>
            zur Verfügung. Wird sie im Definitionsteil einer eingebetteten Schaltung aufgerufen, kann die einzufügende Schaltung
            durch eine andere ersetzt werden. Dies erlaubt die rekursive Definition einer Schaltung. Wie in anderen
            Programmiersprachen auch, ist auf eine geeignete Abbruchbedingung zu achten.
        </par>
        <par>
            Im Ordner <e>examples/generic</e> findet sich ein Beispiel für einen Medwedew Gray-Code-Zähler, dessen
            Bitbreite konfigurierbar ist. Hier wird ein Gray-Code-Zähler aufgebaut, indem einer initialen Schaltung
            rekursiv weitere Bits hinzugefügt werden, bis die erforderliche Bitzahl des Zählers erreicht ist.
        </par>
    </chapter>
    <chapter heading="Skriptgesteuertes Testen">
        <par>
            Wenn Studenten Aufgaben mit Digital erledigen sollen, kann es hilfreich sein, die von den Studenten
            abgegebenen Schaltungen in einem automatischen Prozess überprüfen zu können.
            Um diese Überprüfung durchzuführen, kann Digital über die Kommandozeile gestartet werden.
            Der Aufruf geschieht dabei wie folgt:
        </par>
        <par>
            <code>
                java -cp Digital.jar CLI test [zu testende Datei] [-tests [optionale Datei
                mit Testfällen]]
            </code>
        </par>
        <par>
            Wird nur die zu testende Datei angegeben, werden die Testfälle in dieser Datei ausgeführt.
            Auf diese Weise können die Testfälle ausgeführt werden, welche die Studenten selbst erstellt haben.
        </par>
        <par>
            Wird ein zweiter Dateiname angegeben, werden die Testfälle aus der zweiten Datei entnommen und die erste
            Schaltung wird mit diesen Testfällen überprüft. Die zweite Datei wird also in der Regel die Musterlösung
            enthalten, deren Testfälle vollständig und korrekt sind. Die in der zweiten Datei enthaltene Schaltung
            wird dabei ignoriert. Nur die Testfälle werden daraus entnommen.
        </par>
        <par>
            Um eine abgegebene Schaltung gegen eine Musterlösung testen zu können, müssen die Signalnamen der
            Ein- und Ausgänge in beiden Schaltungen übereinstimmen.
        </par>
    </chapter>
    <chapter heading="Häufig gestellte Fragen">
        <faq>
            <question>Wie kann ich eine Leitung verschieben?</question>
            <answer>Mit der Rechteckauswahl einen Endpunkt auswählen und dann mit der Maus verschieben.
                Alternativ kann eine einzelne Leitung mit STRG+Mausklick selektiert werden.
            </answer>
        </faq>
        <faq>
            <question>Wie kann ich eine Leitung löschen?</question>
            <answer>Mit der Rechteckauswahl einen Endpunkt auswählen und dann <e>Entfernen</e> drücken bzw. auf den
                Papierkorb klicken.
                Alternativ kann eine einzelne Leitung mit STRG+Mausklick selektiert werden.
            </answer>
        </faq>
        <faq>
            <question>Wie kann ich ein Element verschieben und dabei alle angeschlossenen Leitungen mitnehmen?
            </question>
            <answer>Das Bauteil mit der Rechteckauswahl auswählen. Die Auswahl muss das Bauteil komplett enthalten.
                Dann kann das Bauteil zusammen mit den Leitungen verschoben werden.
            </answer>
        </faq>
        <faq>
            <question>Ich habe ein Element, das nicht mit einer Leitung verbunden ist, obwohl die Pins auf der Leitung
                liegen.
            </question>
            <answer>Pins werden nur mit einer Leitung verbunden, wenn ein Endpunkt der Leitung auf dem Pin liegt.
            </answer>
        </faq>
        <faq>
            <question>Wenn die Pinnamen einer Schaltung etwas länger sind, sind die Namen nicht mehr zu lesen, wenn
                die Schaltung eingebettet wird. Was kann ich tun?</question>
            <answer>Unter <e>Bearbeiten<arrow/>Schaltungsattribute bearbeiten</e> kann die Breite des Blockes
                vergrößert werden.</answer>
        </faq>
        <faq>
            <question>Die Pins in einer eingebetteten Schaltung haben eine ungünstige Reihenfolge. Wie kann diese
                verändert werden?</question>
            <answer>Unter <e>Bearbeiten<arrow/>Sortieren der Eingänge</e> bzw. <e>Bearbeiten<arrow/>Sortieren der
                Ausgänge</e> kann die Reihenfolge verändert werden.</answer>
        </faq>

        <faq>
            <question>Wenn die Simulation gestartet wird, ist die Leitung grau. Was bedeutet das?</question>
            <answer>Mit Hellgrün und Dunkelgrün wird eine logische 1 bzw. 0 dargestellt. Grau bedeutet, dass die Leitung
                hochohmig ist.
            </answer>
        </faq>
        <faq>
            <question>Ich habe eine Wahrheitstabelle. Wie kann ich daraus die minimalen Schaltfunktionen erzeugen?
            </question>
            <answer>Im Menü <e>Analyse<arrow/>Synthese</e>
                auswählen und dann die Wahrheitstabelle eingeben.
                In der Statusleiste des Fensters findet sich die Schaltfunktion.
                Geben Sie mehr als eine abhängige Größe an, öffnet sich ein neues Fenster, in welchem alle
                Schaltfunktionen angezeigt werden.
            </answer>
        </faq>
        <faq>
            <question>Ich habe eine Wahrheitstabelle eingegeben, es wird jedoch mehr als eine Schaltfunktion für
                das gesuchte Signal angezeigt. Welche ist richtig?
            </question>
            <answer>Wenn eine Schaltfunktion minimiert wird, kann es mehrere minimierte Schaltfunktionen gleicher
                Komplexität geben (gleiche Anzahl von Termen).
                Digital zeigt alle möglichen Lösungen an und alle liefern die selbe Wahrheitstabelle.
                In den Don't Care-Zeilen der Wahrheitstabelle kann es natürlich Unterschiede zwischen den verschiedenen
                Funktionen geben.
            </answer>
        </faq>
        <faq>
            <question>Ich habe eine Wahrheitstabelle. Wie kann ich daraus eine Schaltung erzeugen?</question>
            <answer>Im Menü
                <e>Analyse<arrow/>Synthese
                </e>
                auswählen und dann die Wahrheitstabelle eingeben.
                Unter <e>Neu</e> bzw. mit <e>Spalten hinzufügen</e> können Variablen hinzugefügt werden.
                Im Menü mit
                <e>Erzeugen<arrow/>Schaltung
                </e>
                dann eine Schaltung erzeugen.
            </answer>
        </faq>
        <faq>
            <question>Wie kann ich die Signalnamen in der Wahrheitstabelle verändern?</question>
            <answer>Mit einem Rechtsklick auf den Signalnamen im Tabellenkopf kann der Name bearbeitet werden.</answer>
        </faq>
        <faq>
            <question>Ich habe eine Schaltfunktion. Wie kann ich daraus eine Schaltung erzeugen?</question>
            <answer>Im Menü
                <e>Analyse<arrow/>Ausdruck
                </e>
                auswählen und dann die Funktion eingeben.
            </answer>
        </faq>
        <faq>
            <question>Ich habe eine Schaltfunktion. Wie kann ich daraus eine Wahrheitstabelle erzeugen?</question>
            <answer>Im Menü
                <e>Analyse<arrow/>Ausdruck
                </e>
                auswählen und dann die Funktion eingeben.
                Dann die Schaltung erzeugen und im Menü
                <e>Analyse<arrow/>Analyse
                </e>
                die Wahrheitstabelle erzeugen.
            </answer>
        </faq>
        <faq>
            <question>Wie kann ich aus einer Schaltung eine JEDEC-Datei erzeugen?</question>
            <answer>Im Menü
                <e>Analyse<arrow/>Analyse
                </e>
                auswählen und dann im neuen Fenster im Menü
                <e>Erzeugen<arrow/>Bausteine
                </e>
                den entsprechenden Baustein auswählen.
            </answer>
        </faq>
        <faq>
            <question>Wie kann ich bei der Erzeugung einer JEDEC-Datei die Pinnummern der Signale festlegen?</question>
            <answer>Bei den entsprechenden Eingängen und Ausgängen in der Schaltung kann im Attribute-Dialog
                eine Pinnummer zugewiesen werden.
            </answer>
        </faq>
        <faq>
            <question>Ich habe eine JEDEC Datei erzeugt. Wie bekomme ich diese in ein <e>GAL16v8</e> bzw. <e>
                GAL22v10</e>?
            </question>
            <answer>Für die Programmierung von GAL's ist eine entsprechende Zusatz-Hardware, ein so gen. GAL-Programmer
                erforderlich.
            </answer>
        </faq>
        <faq>
            <question>Ich habe eine Schaltung erstellt, welche ich in vielen anderen Schaltungen verwenden möchte.
                Wie kann ich das ermöglichen, ohne die Datei immer wieder in die entsprechenden Ordner zu kopieren?
            </question>
            <answer>Die Schaltung kann im "lib" Ordner gespeichert werden. Dann ist sie in allen anderen Schaltungen
                verfügbar.
            </answer>
        </faq>
    </chapter>
    <chapter heading="Tastenbelegung" newpage="true">
        <shortcuts>
            <shortcut key="Leertaste">Starten und stoppen der Simulation</shortcut>
            <shortcut key="F6">Anzeigen der Messwerttabelle</shortcut>
            <shortcut key="F7">Run to Break</shortcut>
            <shortcut key="F8">Starten der Testfälle</shortcut>
            <shortcut key="C">Einen Taktschritt ausführen (nur bei gestarteter Simulation und nur, wenn es genau ein
                Taktelement in der Schaltung gibt)
            </shortcut>
            <shortcut key="V">Einen Gatterschritt ausführen.</shortcut>
            <shortcut key="B">Alle Gatterschritte ausführen, bis sich die Schaltung stabilisiert hat, oder, wenn
                ein Break-Element vorhanden ist, bis zum Break.</shortcut>
            <shortcut key="F9">Analyse der Schaltung</shortcut>
            <shortcut key="STRG-A">Alles auswählen</shortcut>
            <shortcut key="STRG-X">Ausschneiden der selektierten Elemente und kopieren in die Zwischenablage</shortcut>
            <shortcut key="STRG-C">Kopieren der selektierten Elemente in die Zwischenablage</shortcut>
            <shortcut key="STRG-V">Einfügen der Elemente aus der Zwischenablage.</shortcut>
            <shortcut key="STRG-D">Aktuelle Auswahl duplizieren ohne die Zwischenablage zu verändern.</shortcut>
            <shortcut key="R">Rotieren der Elemente beim Einfügen</shortcut>
            <shortcut key="L">Zuletzt eingefügtes Element noch einmal einfügen</shortcut>
            <shortcut key="T">Einfügen eines Tunnels</shortcut>
            <shortcut key="STRG-N">Neue Schaltung</shortcut>
            <shortcut key="STRG-O">Schaltung öffnen</shortcut>
            <shortcut key="STRG-S">Speichern der Schaltung</shortcut>
            <shortcut key="STRG-Z">Letzte Änderung zurücknehmen</shortcut>
            <shortcut key="STRG-Y">Zurückgenommene Änderung erneut anwenden</shortcut>
            <shortcut key="P">Programmieren einer Diode oder eines FG-FET</shortcut>
            <shortcut key="D">Beim Ziehen einer rechteckigen Leitung in den Diagonalmodus wechseln</shortcut>
            <shortcut key="F">Beim Ziehen einer rechteckigen Leitung die Orientierung wechseln</shortcut>
            <shortcut key="S">Leitung in zwei Leitungen teilen</shortcut>
            <shortcut key="Q">Bauteil unter der Maus kopieren</shortcut>
            <shortcut key="STRG-Q">Bauteil unter der Maus mit Default-Werten kopieren</shortcut>
            <shortcut key="ESC">Abbrechen der aktuellen Aktion</shortcut>
            <shortcut key="Entfernen">Löschen der selektierten Elemente</shortcut>
            <shortcut key="Rückschritt">Löschen der selektierten Elemente</shortcut>
            <shortcut key="+">Erhöht die Anzahl der Eingänge in dem Element, auf welches die Maus zeigt. Bei Konstanten
                wird der Wert erhöht.
            </shortcut>
            <shortcut key="-">Erniedrigt die Anzahl der Eingänge in dem Element, auf welches die Maus zeigt. Bei
                Konstanten wird der Wert verringert.
            </shortcut>
            <shortcut key="STRG +">Vergrößern</shortcut>
            <shortcut key="STRG -">Verkleinern</shortcut>
            <shortcut key="F1">Einpassen</shortcut>
            <shortcut key="F5">Baumansicht der Bauteile ein- oder ausblenden</shortcut>
        </shortcuts>
    </chapter>
</root>
